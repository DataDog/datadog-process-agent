// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: agent.proto

package model

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// status section in https://docs.docker.com/engine/api/v1.29/#tag/Container
type ContainerState int32

const (
	ContainerState_unknown    ContainerState = 0
	ContainerState_created    ContainerState = 1
	ContainerState_restarting ContainerState = 2
	ContainerState_running    ContainerState = 3
	ContainerState_paused     ContainerState = 4
	ContainerState_exited     ContainerState = 5
	ContainerState_dead       ContainerState = 6
)

var ContainerState_name = map[int32]string{
	0: "unknown",
	1: "created",
	2: "restarting",
	3: "running",
	4: "paused",
	5: "exited",
	6: "dead",
}

var ContainerState_value = map[string]int32{
	"unknown":    0,
	"created":    1,
	"restarting": 2,
	"running":    3,
	"paused":     4,
	"exited":     5,
	"dead":       6,
}

func (x ContainerState) String() string {
	return proto.EnumName(ContainerState_name, int32(x))
}

func (ContainerState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{0}
}

// https://blog.couchbase.com/docker-health-check-keeping-containers-healthy/
// health can be: starting, healthy, unhealthy
type ContainerHealth int32

const (
	ContainerHealth_unknownHealth ContainerHealth = 0
	ContainerHealth_starting      ContainerHealth = 1
	ContainerHealth_healthy       ContainerHealth = 2
	ContainerHealth_unhealthy     ContainerHealth = 3
)

var ContainerHealth_name = map[int32]string{
	0: "unknownHealth",
	1: "starting",
	2: "healthy",
	3: "unhealthy",
}

var ContainerHealth_value = map[string]int32{
	"unknownHealth": 0,
	"starting":      1,
	"healthy":       2,
	"unhealthy":     3,
}

func (x ContainerHealth) String() string {
	return proto.EnumName(ContainerHealth_name, int32(x))
}

func (ContainerHealth) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{1}
}

// Process state codes in http://wiki.preshweb.co.uk/doku.php?id=linux:psflags
type ProcessState int32

const (
	ProcessState_U ProcessState = 0
	ProcessState_D ProcessState = 1
	ProcessState_R ProcessState = 2
	ProcessState_S ProcessState = 3
	ProcessState_T ProcessState = 4
	ProcessState_W ProcessState = 5
	ProcessState_X ProcessState = 6
	ProcessState_Z ProcessState = 7
)

var ProcessState_name = map[int32]string{
	0: "U",
	1: "D",
	2: "R",
	3: "S",
	4: "T",
	5: "W",
	6: "X",
	7: "Z",
}

var ProcessState_value = map[string]int32{
	"U": 0,
	"D": 1,
	"R": 2,
	"S": 3,
	"T": 4,
	"W": 5,
	"X": 6,
	"Z": 7,
}

func (x ProcessState) String() string {
	return proto.EnumName(ProcessState_name, int32(x))
}

func (ProcessState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{2}
}

type ConnectionType int32

const (
	ConnectionType_tcp ConnectionType = 0
	ConnectionType_udp ConnectionType = 1
)

var ConnectionType_name = map[int32]string{
	0: "tcp",
	1: "udp",
}

var ConnectionType_value = map[string]int32{
	"tcp": 0,
	"udp": 1,
}

func (x ConnectionType) String() string {
	return proto.EnumName(ConnectionType_name, int32(x))
}

func (ConnectionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{3}
}

type ConnectionFamily int32

const (
	ConnectionFamily_v4 ConnectionFamily = 0
	ConnectionFamily_v6 ConnectionFamily = 1
)

var ConnectionFamily_name = map[int32]string{
	0: "v4",
	1: "v6",
}

var ConnectionFamily_value = map[string]int32{
	"v4": 0,
	"v6": 1,
}

func (x ConnectionFamily) String() string {
	return proto.EnumName(ConnectionFamily_name, int32(x))
}

func (ConnectionFamily) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{4}
}

type ConnectionDirection int32

const (
	ConnectionDirection_none     ConnectionDirection = 0
	ConnectionDirection_outgoing ConnectionDirection = 1
	ConnectionDirection_incoming ConnectionDirection = 2
)

var ConnectionDirection_name = map[int32]string{
	0: "none",
	1: "outgoing",
	2: "incoming",
}

var ConnectionDirection_value = map[string]int32{
	"none":     0,
	"outgoing": 1,
	"incoming": 2,
}

func (x ConnectionDirection) String() string {
	return proto.EnumName(ConnectionDirection_name, int32(x))
}

func (ConnectionDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{5}
}

type ResCollector struct {
	Header  *ResCollector_Header `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Message string               `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Status  *CollectorStatus     `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ResCollector) Reset()         { *m = ResCollector{} }
func (m *ResCollector) String() string { return proto.CompactTextString(m) }
func (*ResCollector) ProtoMessage()    {}
func (*ResCollector) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{0}
}
func (m *ResCollector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResCollector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResCollector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResCollector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResCollector.Merge(m, src)
}
func (m *ResCollector) XXX_Size() int {
	return m.Size()
}
func (m *ResCollector) XXX_DiscardUnknown() {
	xxx_messageInfo_ResCollector.DiscardUnknown(m)
}

var xxx_messageInfo_ResCollector proto.InternalMessageInfo

func (m *ResCollector) GetHeader() *ResCollector_Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ResCollector) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ResCollector) GetStatus() *CollectorStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Header must exist at position 1 for compatibility
// with older version of the Agent. We should be able
// to drop this at some point.
type ResCollector_Header struct {
	Type int32 `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *ResCollector_Header) Reset()         { *m = ResCollector_Header{} }
func (m *ResCollector_Header) String() string { return proto.CompactTextString(m) }
func (*ResCollector_Header) ProtoMessage()    {}
func (*ResCollector_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{0, 0}
}
func (m *ResCollector_Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResCollector_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResCollector_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResCollector_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResCollector_Header.Merge(m, src)
}
func (m *ResCollector_Header) XXX_Size() int {
	return m.Size()
}
func (m *ResCollector_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_ResCollector_Header.DiscardUnknown(m)
}

var xxx_messageInfo_ResCollector_Header proto.InternalMessageInfo

func (m *ResCollector_Header) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

type CollectorProc struct {
	HostName  string      `protobuf:"bytes,2,opt,name=hostName,proto3" json:"hostName,omitempty"`
	Processes []*Process  `protobuf:"bytes,3,rep,name=processes,proto3" json:"processes,omitempty"`
	Host      *Host       `protobuf:"bytes,4,opt,name=host,proto3" json:"host,omitempty"`
	Info      *SystemInfo `protobuf:"bytes,5,opt,name=info,proto3" json:"info,omitempty"`
	GroupId   int32       `protobuf:"varint,6,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize int32       `protobuf:"varint,7,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	// Optional metadata fields
	Kubernetes *KubeMetadataPayload `protobuf:"bytes,8,opt,name=kubernetes,proto3" json:"kubernetes,omitempty"`
	Ecs        *ECSMetadataPayload  `protobuf:"bytes,9,opt,name=ecs,proto3" json:"ecs,omitempty"`
	Containers []*Container         `protobuf:"bytes,10,rep,name=containers,proto3" json:"containers,omitempty"`
}

func (m *CollectorProc) Reset()         { *m = CollectorProc{} }
func (m *CollectorProc) String() string { return proto.CompactTextString(m) }
func (*CollectorProc) ProtoMessage()    {}
func (*CollectorProc) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{1}
}
func (m *CollectorProc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectorProc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectorProc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectorProc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectorProc.Merge(m, src)
}
func (m *CollectorProc) XXX_Size() int {
	return m.Size()
}
func (m *CollectorProc) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectorProc.DiscardUnknown(m)
}

var xxx_messageInfo_CollectorProc proto.InternalMessageInfo

func (m *CollectorProc) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *CollectorProc) GetProcesses() []*Process {
	if m != nil {
		return m.Processes
	}
	return nil
}

func (m *CollectorProc) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *CollectorProc) GetInfo() *SystemInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *CollectorProc) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *CollectorProc) GetGroupSize() int32 {
	if m != nil {
		return m.GroupSize
	}
	return 0
}

func (m *CollectorProc) GetKubernetes() *KubeMetadataPayload {
	if m != nil {
		return m.Kubernetes
	}
	return nil
}

func (m *CollectorProc) GetEcs() *ECSMetadataPayload {
	if m != nil {
		return m.Ecs
	}
	return nil
}

func (m *CollectorProc) GetContainers() []*Container {
	if m != nil {
		return m.Containers
	}
	return nil
}

type CollectorCommands struct {
	HostName  string              `protobuf:"bytes,2,opt,name=hostName,proto3" json:"hostName,omitempty"`
	Commands  []*CollectorCommand `protobuf:"bytes,3,rep,name=commands,proto3" json:"commands,omitempty"`
	Host      *Host               `protobuf:"bytes,4,opt,name=host,proto3" json:"host,omitempty"`
	Info      *SystemInfo         `protobuf:"bytes,5,opt,name=info,proto3" json:"info,omitempty"`
	GroupId   int32               `protobuf:"varint,6,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize int32               `protobuf:"varint,7,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
}

func (m *CollectorCommands) Reset()         { *m = CollectorCommands{} }
func (m *CollectorCommands) String() string { return proto.CompactTextString(m) }
func (*CollectorCommands) ProtoMessage()    {}
func (*CollectorCommands) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{2}
}
func (m *CollectorCommands) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectorCommands) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectorCommands.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectorCommands) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectorCommands.Merge(m, src)
}
func (m *CollectorCommands) XXX_Size() int {
	return m.Size()
}
func (m *CollectorCommands) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectorCommands.DiscardUnknown(m)
}

var xxx_messageInfo_CollectorCommands proto.InternalMessageInfo

func (m *CollectorCommands) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *CollectorCommands) GetCommands() []*CollectorCommand {
	if m != nil {
		return m.Commands
	}
	return nil
}

func (m *CollectorCommands) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *CollectorCommands) GetInfo() *SystemInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *CollectorCommands) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *CollectorCommands) GetGroupSize() int32 {
	if m != nil {
		return m.GroupSize
	}
	return 0
}

type CollectorConnections struct {
	HostName    string        `protobuf:"bytes,2,opt,name=hostName,proto3" json:"hostName,omitempty"`
	Connections []*Connection `protobuf:"bytes,3,rep,name=connections,proto3" json:"connections,omitempty"`
	// Post-resolved field
	Host *Host `protobuf:"bytes,4,opt,name=host,proto3" json:"host,omitempty"`
	// Message batching metadata
	GroupId   int32 `protobuf:"varint,5,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize int32 `protobuf:"varint,6,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
}

func (m *CollectorConnections) Reset()         { *m = CollectorConnections{} }
func (m *CollectorConnections) String() string { return proto.CompactTextString(m) }
func (*CollectorConnections) ProtoMessage()    {}
func (*CollectorConnections) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{3}
}
func (m *CollectorConnections) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectorConnections) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectorConnections.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectorConnections) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectorConnections.Merge(m, src)
}
func (m *CollectorConnections) XXX_Size() int {
	return m.Size()
}
func (m *CollectorConnections) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectorConnections.DiscardUnknown(m)
}

var xxx_messageInfo_CollectorConnections proto.InternalMessageInfo

func (m *CollectorConnections) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *CollectorConnections) GetConnections() []*Connection {
	if m != nil {
		return m.Connections
	}
	return nil
}

func (m *CollectorConnections) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *CollectorConnections) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *CollectorConnections) GetGroupSize() int32 {
	if m != nil {
		return m.GroupSize
	}
	return 0
}

type CollectorRealTime struct {
	HostName string         `protobuf:"bytes,2,opt,name=hostName,proto3" json:"hostName,omitempty"`
	Stats    []*ProcessStat `protobuf:"bytes,3,rep,name=stats,proto3" json:"stats,omitempty"`
	// Post-resolved fields
	HostId         int32            `protobuf:"varint,4,opt,name=hostId,proto3" json:"hostId,omitempty"`
	OrgId          int32            `protobuf:"varint,5,opt,name=orgId,proto3" json:"orgId,omitempty"`
	GroupId        int32            `protobuf:"varint,6,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize      int32            `protobuf:"varint,7,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	NumCpus        int32            `protobuf:"varint,8,opt,name=numCpus,proto3" json:"numCpus,omitempty"`
	TotalMemory    int64            `protobuf:"varint,9,opt,name=totalMemory,proto3" json:"totalMemory,omitempty"`
	ContainerStats []*ContainerStat `protobuf:"bytes,10,rep,name=containerStats,proto3" json:"containerStats,omitempty"`
}

func (m *CollectorRealTime) Reset()         { *m = CollectorRealTime{} }
func (m *CollectorRealTime) String() string { return proto.CompactTextString(m) }
func (*CollectorRealTime) ProtoMessage()    {}
func (*CollectorRealTime) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{4}
}
func (m *CollectorRealTime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectorRealTime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectorRealTime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectorRealTime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectorRealTime.Merge(m, src)
}
func (m *CollectorRealTime) XXX_Size() int {
	return m.Size()
}
func (m *CollectorRealTime) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectorRealTime.DiscardUnknown(m)
}

var xxx_messageInfo_CollectorRealTime proto.InternalMessageInfo

func (m *CollectorRealTime) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *CollectorRealTime) GetStats() []*ProcessStat {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *CollectorRealTime) GetHostId() int32 {
	if m != nil {
		return m.HostId
	}
	return 0
}

func (m *CollectorRealTime) GetOrgId() int32 {
	if m != nil {
		return m.OrgId
	}
	return 0
}

func (m *CollectorRealTime) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *CollectorRealTime) GetGroupSize() int32 {
	if m != nil {
		return m.GroupSize
	}
	return 0
}

func (m *CollectorRealTime) GetNumCpus() int32 {
	if m != nil {
		return m.NumCpus
	}
	return 0
}

func (m *CollectorRealTime) GetTotalMemory() int64 {
	if m != nil {
		return m.TotalMemory
	}
	return 0
}

func (m *CollectorRealTime) GetContainerStats() []*ContainerStat {
	if m != nil {
		return m.ContainerStats
	}
	return nil
}

type CollectorContainer struct {
	HostName   string       `protobuf:"bytes,1,opt,name=hostName,proto3" json:"hostName,omitempty"`
	Info       *SystemInfo  `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
	Containers []*Container `protobuf:"bytes,3,rep,name=containers,proto3" json:"containers,omitempty"`
	GroupId    int32        `protobuf:"varint,4,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize  int32        `protobuf:"varint,5,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	// Optional metadata fields
	Kubernetes *KubeMetadataPayload `protobuf:"bytes,6,opt,name=kubernetes,proto3" json:"kubernetes,omitempty"`
	Ecs        *ECSMetadataPayload  `protobuf:"bytes,7,opt,name=ecs,proto3" json:"ecs,omitempty"`
	// Post-resolved fields
	Host *Host `protobuf:"bytes,8,opt,name=host,proto3" json:"host,omitempty"`
}

func (m *CollectorContainer) Reset()         { *m = CollectorContainer{} }
func (m *CollectorContainer) String() string { return proto.CompactTextString(m) }
func (*CollectorContainer) ProtoMessage()    {}
func (*CollectorContainer) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{5}
}
func (m *CollectorContainer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectorContainer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectorContainer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectorContainer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectorContainer.Merge(m, src)
}
func (m *CollectorContainer) XXX_Size() int {
	return m.Size()
}
func (m *CollectorContainer) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectorContainer.DiscardUnknown(m)
}

var xxx_messageInfo_CollectorContainer proto.InternalMessageInfo

func (m *CollectorContainer) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *CollectorContainer) GetInfo() *SystemInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *CollectorContainer) GetContainers() []*Container {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *CollectorContainer) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *CollectorContainer) GetGroupSize() int32 {
	if m != nil {
		return m.GroupSize
	}
	return 0
}

func (m *CollectorContainer) GetKubernetes() *KubeMetadataPayload {
	if m != nil {
		return m.Kubernetes
	}
	return nil
}

func (m *CollectorContainer) GetEcs() *ECSMetadataPayload {
	if m != nil {
		return m.Ecs
	}
	return nil
}

func (m *CollectorContainer) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

type CollectorContainerRealTime struct {
	HostName string           `protobuf:"bytes,1,opt,name=hostName,proto3" json:"hostName,omitempty"`
	Stats    []*ContainerStat `protobuf:"bytes,2,rep,name=stats,proto3" json:"stats,omitempty"`
	// Used for normalization at host-level.
	NumCpus     int32 `protobuf:"varint,3,opt,name=numCpus,proto3" json:"numCpus,omitempty"`
	TotalMemory int64 `protobuf:"varint,4,opt,name=totalMemory,proto3" json:"totalMemory,omitempty"`
	// Post-resolved fields
	HostId    int32 `protobuf:"varint,5,opt,name=hostId,proto3" json:"hostId,omitempty"`
	GroupId   int32 `protobuf:"varint,6,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize int32 `protobuf:"varint,7,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
}

func (m *CollectorContainerRealTime) Reset()         { *m = CollectorContainerRealTime{} }
func (m *CollectorContainerRealTime) String() string { return proto.CompactTextString(m) }
func (*CollectorContainerRealTime) ProtoMessage()    {}
func (*CollectorContainerRealTime) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{6}
}
func (m *CollectorContainerRealTime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectorContainerRealTime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectorContainerRealTime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectorContainerRealTime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectorContainerRealTime.Merge(m, src)
}
func (m *CollectorContainerRealTime) XXX_Size() int {
	return m.Size()
}
func (m *CollectorContainerRealTime) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectorContainerRealTime.DiscardUnknown(m)
}

var xxx_messageInfo_CollectorContainerRealTime proto.InternalMessageInfo

func (m *CollectorContainerRealTime) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *CollectorContainerRealTime) GetStats() []*ContainerStat {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *CollectorContainerRealTime) GetNumCpus() int32 {
	if m != nil {
		return m.NumCpus
	}
	return 0
}

func (m *CollectorContainerRealTime) GetTotalMemory() int64 {
	if m != nil {
		return m.TotalMemory
	}
	return 0
}

func (m *CollectorContainerRealTime) GetHostId() int32 {
	if m != nil {
		return m.HostId
	}
	return 0
}

func (m *CollectorContainerRealTime) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *CollectorContainerRealTime) GetGroupSize() int32 {
	if m != nil {
		return m.GroupSize
	}
	return 0
}

type CollectorReqStatus struct {
	HostName string `protobuf:"bytes,2,opt,name=hostName,proto3" json:"hostName,omitempty"`
}

func (m *CollectorReqStatus) Reset()         { *m = CollectorReqStatus{} }
func (m *CollectorReqStatus) String() string { return proto.CompactTextString(m) }
func (*CollectorReqStatus) ProtoMessage()    {}
func (*CollectorReqStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{7}
}
func (m *CollectorReqStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectorReqStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectorReqStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectorReqStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectorReqStatus.Merge(m, src)
}
func (m *CollectorReqStatus) XXX_Size() int {
	return m.Size()
}
func (m *CollectorReqStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectorReqStatus.DiscardUnknown(m)
}

var xxx_messageInfo_CollectorReqStatus proto.InternalMessageInfo

func (m *CollectorReqStatus) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

type CollectorCommand struct {
	// Tagged union, meaning the command field will contain either one of the 6 choices, to distinguish between the commands
	//
	// Types that are valid to be assigned to Command:
	//	*CollectorCommand_UpdateProcess
	//	*CollectorCommand_UpdateProcessMetrics
	//	*CollectorCommand_DeleteProcess
	//	*CollectorCommand_UpdateContainer
	//	*CollectorCommand_UpdateContainerMetrics
	//	*CollectorCommand_DeleteContainer
	Command isCollectorCommand_Command `protobuf_oneof:"command"`
}

func (m *CollectorCommand) Reset()         { *m = CollectorCommand{} }
func (m *CollectorCommand) String() string { return proto.CompactTextString(m) }
func (*CollectorCommand) ProtoMessage()    {}
func (*CollectorCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{8}
}
func (m *CollectorCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectorCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectorCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectorCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectorCommand.Merge(m, src)
}
func (m *CollectorCommand) XXX_Size() int {
	return m.Size()
}
func (m *CollectorCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectorCommand.DiscardUnknown(m)
}

var xxx_messageInfo_CollectorCommand proto.InternalMessageInfo

type isCollectorCommand_Command interface {
	isCollectorCommand_Command()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CollectorCommand_UpdateProcess struct {
	UpdateProcess *Process `protobuf:"bytes,1,opt,name=updateProcess,proto3,oneof" json:"updateProcess,omitempty"`
}
type CollectorCommand_UpdateProcessMetrics struct {
	UpdateProcessMetrics *Process `protobuf:"bytes,2,opt,name=updateProcessMetrics,proto3,oneof" json:"updateProcessMetrics,omitempty"`
}
type CollectorCommand_DeleteProcess struct {
	DeleteProcess *Process `protobuf:"bytes,3,opt,name=deleteProcess,proto3,oneof" json:"deleteProcess,omitempty"`
}
type CollectorCommand_UpdateContainer struct {
	UpdateContainer *Container `protobuf:"bytes,10,opt,name=updateContainer,proto3,oneof" json:"updateContainer,omitempty"`
}
type CollectorCommand_UpdateContainerMetrics struct {
	UpdateContainerMetrics *Container `protobuf:"bytes,11,opt,name=updateContainerMetrics,proto3,oneof" json:"updateContainerMetrics,omitempty"`
}
type CollectorCommand_DeleteContainer struct {
	DeleteContainer *Container `protobuf:"bytes,12,opt,name=deleteContainer,proto3,oneof" json:"deleteContainer,omitempty"`
}

func (*CollectorCommand_UpdateProcess) isCollectorCommand_Command()          {}
func (*CollectorCommand_UpdateProcessMetrics) isCollectorCommand_Command()   {}
func (*CollectorCommand_DeleteProcess) isCollectorCommand_Command()          {}
func (*CollectorCommand_UpdateContainer) isCollectorCommand_Command()        {}
func (*CollectorCommand_UpdateContainerMetrics) isCollectorCommand_Command() {}
func (*CollectorCommand_DeleteContainer) isCollectorCommand_Command()        {}

func (m *CollectorCommand) GetCommand() isCollectorCommand_Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *CollectorCommand) GetUpdateProcess() *Process {
	if x, ok := m.GetCommand().(*CollectorCommand_UpdateProcess); ok {
		return x.UpdateProcess
	}
	return nil
}

func (m *CollectorCommand) GetUpdateProcessMetrics() *Process {
	if x, ok := m.GetCommand().(*CollectorCommand_UpdateProcessMetrics); ok {
		return x.UpdateProcessMetrics
	}
	return nil
}

func (m *CollectorCommand) GetDeleteProcess() *Process {
	if x, ok := m.GetCommand().(*CollectorCommand_DeleteProcess); ok {
		return x.DeleteProcess
	}
	return nil
}

func (m *CollectorCommand) GetUpdateContainer() *Container {
	if x, ok := m.GetCommand().(*CollectorCommand_UpdateContainer); ok {
		return x.UpdateContainer
	}
	return nil
}

func (m *CollectorCommand) GetUpdateContainerMetrics() *Container {
	if x, ok := m.GetCommand().(*CollectorCommand_UpdateContainerMetrics); ok {
		return x.UpdateContainerMetrics
	}
	return nil
}

func (m *CollectorCommand) GetDeleteContainer() *Container {
	if x, ok := m.GetCommand().(*CollectorCommand_DeleteContainer); ok {
		return x.DeleteContainer
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CollectorCommand) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CollectorCommand_UpdateProcess)(nil),
		(*CollectorCommand_UpdateProcessMetrics)(nil),
		(*CollectorCommand_DeleteProcess)(nil),
		(*CollectorCommand_UpdateContainer)(nil),
		(*CollectorCommand_UpdateContainerMetrics)(nil),
		(*CollectorCommand_DeleteContainer)(nil),
	}
}

type CollectorStatus struct {
	ActiveClients int32 `protobuf:"varint,1,opt,name=activeClients,proto3" json:"activeClients,omitempty"`
	Interval      int32 `protobuf:"varint,2,opt,name=interval,proto3" json:"interval,omitempty"`
}

func (m *CollectorStatus) Reset()         { *m = CollectorStatus{} }
func (m *CollectorStatus) String() string { return proto.CompactTextString(m) }
func (*CollectorStatus) ProtoMessage()    {}
func (*CollectorStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{9}
}
func (m *CollectorStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectorStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectorStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectorStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectorStatus.Merge(m, src)
}
func (m *CollectorStatus) XXX_Size() int {
	return m.Size()
}
func (m *CollectorStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectorStatus.DiscardUnknown(m)
}

var xxx_messageInfo_CollectorStatus proto.InternalMessageInfo

func (m *CollectorStatus) GetActiveClients() int32 {
	if m != nil {
		return m.ActiveClients
	}
	return 0
}

func (m *CollectorStatus) GetInterval() int32 {
	if m != nil {
		return m.Interval
	}
	return 0
}

type Process struct {
	Key     uint32       `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Pid     int32        `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
	Host    *Host        `protobuf:"bytes,3,opt,name=host,proto3" json:"host,omitempty"`
	Command *Command     `protobuf:"bytes,4,opt,name=command,proto3" json:"command,omitempty"`
	User    *ProcessUser `protobuf:"bytes,5,opt,name=user,proto3" json:"user,omitempty"`
	// 6 is deprecated
	Memory                 *MemoryStat  `protobuf:"bytes,7,opt,name=memory,proto3" json:"memory,omitempty"`
	Cpu                    *CPUStat     `protobuf:"bytes,8,opt,name=cpu,proto3" json:"cpu,omitempty"`
	CreateTime             int64        `protobuf:"varint,9,opt,name=createTime,proto3" json:"createTime,omitempty"`
	Container              *Container   `protobuf:"bytes,10,opt,name=container,proto3" json:"container,omitempty"`
	OpenFdCount            int32        `protobuf:"varint,11,opt,name=openFdCount,proto3" json:"openFdCount,omitempty"`
	State                  ProcessState `protobuf:"varint,12,opt,name=state,proto3,enum=datadog.process_agent.ProcessState" json:"state,omitempty"`
	IoStat                 *IOStat      `protobuf:"bytes,13,opt,name=ioStat,proto3" json:"ioStat,omitempty"`
	ContainerId            string       `protobuf:"bytes,14,opt,name=containerId,proto3" json:"containerId,omitempty"`
	ContainerKey           uint32       `protobuf:"varint,15,opt,name=containerKey,proto3" json:"containerKey,omitempty"`
	VoluntaryCtxSwitches   uint64       `protobuf:"varint,16,opt,name=voluntaryCtxSwitches,proto3" json:"voluntaryCtxSwitches,omitempty"`
	InvoluntaryCtxSwitches uint64       `protobuf:"varint,17,opt,name=involuntaryCtxSwitches,proto3" json:"involuntaryCtxSwitches,omitempty"`
	ByteKey                []byte       `protobuf:"bytes,18,opt,name=byteKey,proto3" json:"byteKey,omitempty"`
	ContainerByteKey       []byte       `protobuf:"bytes,19,opt,name=containerByteKey,proto3" json:"containerByteKey,omitempty"`
	Tags                   []string     `protobuf:"bytes,20,rep,name=tags,proto3" json:"tags,omitempty"`
}

func (m *Process) Reset()         { *m = Process{} }
func (m *Process) String() string { return proto.CompactTextString(m) }
func (*Process) ProtoMessage()    {}
func (*Process) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{10}
}
func (m *Process) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Process) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Process.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Process) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Process.Merge(m, src)
}
func (m *Process) XXX_Size() int {
	return m.Size()
}
func (m *Process) XXX_DiscardUnknown() {
	xxx_messageInfo_Process.DiscardUnknown(m)
}

var xxx_messageInfo_Process proto.InternalMessageInfo

func (m *Process) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *Process) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *Process) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *Process) GetCommand() *Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *Process) GetUser() *ProcessUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Process) GetMemory() *MemoryStat {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *Process) GetCpu() *CPUStat {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *Process) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *Process) GetContainer() *Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *Process) GetOpenFdCount() int32 {
	if m != nil {
		return m.OpenFdCount
	}
	return 0
}

func (m *Process) GetState() ProcessState {
	if m != nil {
		return m.State
	}
	return ProcessState_U
}

func (m *Process) GetIoStat() *IOStat {
	if m != nil {
		return m.IoStat
	}
	return nil
}

func (m *Process) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

func (m *Process) GetContainerKey() uint32 {
	if m != nil {
		return m.ContainerKey
	}
	return 0
}

func (m *Process) GetVoluntaryCtxSwitches() uint64 {
	if m != nil {
		return m.VoluntaryCtxSwitches
	}
	return 0
}

func (m *Process) GetInvoluntaryCtxSwitches() uint64 {
	if m != nil {
		return m.InvoluntaryCtxSwitches
	}
	return 0
}

func (m *Process) GetByteKey() []byte {
	if m != nil {
		return m.ByteKey
	}
	return nil
}

func (m *Process) GetContainerByteKey() []byte {
	if m != nil {
		return m.ContainerByteKey
	}
	return nil
}

func (m *Process) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type Command struct {
	Args   []string `protobuf:"bytes,1,rep,name=args,proto3" json:"args,omitempty"`
	Cwd    string   `protobuf:"bytes,3,opt,name=cwd,proto3" json:"cwd,omitempty"`
	Root   string   `protobuf:"bytes,4,opt,name=root,proto3" json:"root,omitempty"`
	OnDisk bool     `protobuf:"varint,5,opt,name=onDisk,proto3" json:"onDisk,omitempty"`
	Ppid   int32    `protobuf:"varint,6,opt,name=ppid,proto3" json:"ppid,omitempty"`
	Pgroup int32    `protobuf:"varint,7,opt,name=pgroup,proto3" json:"pgroup,omitempty"`
	Exe    string   `protobuf:"bytes,8,opt,name=exe,proto3" json:"exe,omitempty"`
}

func (m *Command) Reset()         { *m = Command{} }
func (m *Command) String() string { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()    {}
func (*Command) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{11}
}
func (m *Command) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Command) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Command.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Command) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command.Merge(m, src)
}
func (m *Command) XXX_Size() int {
	return m.Size()
}
func (m *Command) XXX_DiscardUnknown() {
	xxx_messageInfo_Command.DiscardUnknown(m)
}

var xxx_messageInfo_Command proto.InternalMessageInfo

func (m *Command) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Command) GetCwd() string {
	if m != nil {
		return m.Cwd
	}
	return ""
}

func (m *Command) GetRoot() string {
	if m != nil {
		return m.Root
	}
	return ""
}

func (m *Command) GetOnDisk() bool {
	if m != nil {
		return m.OnDisk
	}
	return false
}

func (m *Command) GetPpid() int32 {
	if m != nil {
		return m.Ppid
	}
	return 0
}

func (m *Command) GetPgroup() int32 {
	if m != nil {
		return m.Pgroup
	}
	return 0
}

func (m *Command) GetExe() string {
	if m != nil {
		return m.Exe
	}
	return ""
}

type ProcessUser struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Uid  int32  `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	Gid  int32  `protobuf:"varint,3,opt,name=gid,proto3" json:"gid,omitempty"`
	Euid int32  `protobuf:"varint,4,opt,name=euid,proto3" json:"euid,omitempty"`
	Egid int32  `protobuf:"varint,5,opt,name=egid,proto3" json:"egid,omitempty"`
	Suid int32  `protobuf:"varint,6,opt,name=suid,proto3" json:"suid,omitempty"`
	Sgid int32  `protobuf:"varint,7,opt,name=sgid,proto3" json:"sgid,omitempty"`
}

func (m *ProcessUser) Reset()         { *m = ProcessUser{} }
func (m *ProcessUser) String() string { return proto.CompactTextString(m) }
func (*ProcessUser) ProtoMessage()    {}
func (*ProcessUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{12}
}
func (m *ProcessUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessUser.Merge(m, src)
}
func (m *ProcessUser) XXX_Size() int {
	return m.Size()
}
func (m *ProcessUser) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessUser.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessUser proto.InternalMessageInfo

func (m *ProcessUser) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProcessUser) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ProcessUser) GetGid() int32 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *ProcessUser) GetEuid() int32 {
	if m != nil {
		return m.Euid
	}
	return 0
}

func (m *ProcessUser) GetEgid() int32 {
	if m != nil {
		return m.Egid
	}
	return 0
}

func (m *ProcessUser) GetSuid() int32 {
	if m != nil {
		return m.Suid
	}
	return 0
}

func (m *ProcessUser) GetSgid() int32 {
	if m != nil {
		return m.Sgid
	}
	return 0
}

type Container struct {
	Type        string  `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id          string  `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Name        string  `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Image       string  `protobuf:"bytes,4,opt,name=image,proto3" json:"image,omitempty"`
	CpuLimit    float32 `protobuf:"fixed32,5,opt,name=cpuLimit,proto3" json:"cpuLimit,omitempty"`
	MemoryLimit uint64  `protobuf:"varint,6,opt,name=memoryLimit,proto3" json:"memoryLimit,omitempty"`
	// 7 is removed, do not use.
	State      ContainerState  `protobuf:"varint,8,opt,name=state,proto3,enum=datadog.process_agent.ContainerState" json:"state,omitempty"`
	Health     ContainerHealth `protobuf:"varint,9,opt,name=health,proto3,enum=datadog.process_agent.ContainerHealth" json:"health,omitempty"`
	Created    int64           `protobuf:"varint,10,opt,name=created,proto3" json:"created,omitempty"`
	Rbps       float32         `protobuf:"fixed32,11,opt,name=rbps,proto3" json:"rbps,omitempty"`
	Wbps       float32         `protobuf:"fixed32,12,opt,name=wbps,proto3" json:"wbps,omitempty"`
	Key        uint32          `protobuf:"varint,13,opt,name=key,proto3" json:"key,omitempty"`
	NetRcvdPs  float32         `protobuf:"fixed32,14,opt,name=netRcvdPs,proto3" json:"netRcvdPs,omitempty"`
	NetSentPs  float32         `protobuf:"fixed32,15,opt,name=netSentPs,proto3" json:"netSentPs,omitempty"`
	NetRcvdBps float32         `protobuf:"fixed32,16,opt,name=netRcvdBps,proto3" json:"netRcvdBps,omitempty"`
	NetSentBps float32         `protobuf:"fixed32,17,opt,name=netSentBps,proto3" json:"netSentBps,omitempty"`
	UserPct    float32         `protobuf:"fixed32,18,opt,name=userPct,proto3" json:"userPct,omitempty"`
	SystemPct  float32         `protobuf:"fixed32,19,opt,name=systemPct,proto3" json:"systemPct,omitempty"`
	TotalPct   float32         `protobuf:"fixed32,20,opt,name=totalPct,proto3" json:"totalPct,omitempty"`
	MemRss     uint64          `protobuf:"varint,21,opt,name=memRss,proto3" json:"memRss,omitempty"`
	MemCache   uint64          `protobuf:"varint,22,opt,name=memCache,proto3" json:"memCache,omitempty"`
	Host       *Host           `protobuf:"bytes,23,opt,name=host,proto3" json:"host,omitempty"`
	Started    int64           `protobuf:"varint,24,opt,name=started,proto3" json:"started,omitempty"`
	ByteKey    []byte          `protobuf:"bytes,25,opt,name=byteKey,proto3" json:"byteKey,omitempty"`
	Tags       []string        `protobuf:"bytes,26,rep,name=tags,proto3" json:"tags,omitempty"`
}

func (m *Container) Reset()         { *m = Container{} }
func (m *Container) String() string { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()    {}
func (*Container) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{13}
}
func (m *Container) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Container) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Container.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Container) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Container.Merge(m, src)
}
func (m *Container) XXX_Size() int {
	return m.Size()
}
func (m *Container) XXX_DiscardUnknown() {
	xxx_messageInfo_Container.DiscardUnknown(m)
}

var xxx_messageInfo_Container proto.InternalMessageInfo

func (m *Container) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Container) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Container) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Container) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Container) GetCpuLimit() float32 {
	if m != nil {
		return m.CpuLimit
	}
	return 0
}

func (m *Container) GetMemoryLimit() uint64 {
	if m != nil {
		return m.MemoryLimit
	}
	return 0
}

func (m *Container) GetState() ContainerState {
	if m != nil {
		return m.State
	}
	return ContainerState_unknown
}

func (m *Container) GetHealth() ContainerHealth {
	if m != nil {
		return m.Health
	}
	return ContainerHealth_unknownHealth
}

func (m *Container) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Container) GetRbps() float32 {
	if m != nil {
		return m.Rbps
	}
	return 0
}

func (m *Container) GetWbps() float32 {
	if m != nil {
		return m.Wbps
	}
	return 0
}

func (m *Container) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *Container) GetNetRcvdPs() float32 {
	if m != nil {
		return m.NetRcvdPs
	}
	return 0
}

func (m *Container) GetNetSentPs() float32 {
	if m != nil {
		return m.NetSentPs
	}
	return 0
}

func (m *Container) GetNetRcvdBps() float32 {
	if m != nil {
		return m.NetRcvdBps
	}
	return 0
}

func (m *Container) GetNetSentBps() float32 {
	if m != nil {
		return m.NetSentBps
	}
	return 0
}

func (m *Container) GetUserPct() float32 {
	if m != nil {
		return m.UserPct
	}
	return 0
}

func (m *Container) GetSystemPct() float32 {
	if m != nil {
		return m.SystemPct
	}
	return 0
}

func (m *Container) GetTotalPct() float32 {
	if m != nil {
		return m.TotalPct
	}
	return 0
}

func (m *Container) GetMemRss() uint64 {
	if m != nil {
		return m.MemRss
	}
	return 0
}

func (m *Container) GetMemCache() uint64 {
	if m != nil {
		return m.MemCache
	}
	return 0
}

func (m *Container) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *Container) GetStarted() int64 {
	if m != nil {
		return m.Started
	}
	return 0
}

func (m *Container) GetByteKey() []byte {
	if m != nil {
		return m.ByteKey
	}
	return nil
}

func (m *Container) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// ProcessStat is used for real-time process messages. It should only contain
// data that can change for a running process (and relevant information to
// generate a key). We will send a lot of these in the real-time messages so
// it's critical to keep this small.
type ProcessStat struct {
	Pid int32 `protobuf:"varint,1,opt,name=pid,proto3" json:"pid,omitempty"`
	// In milliseconds
	CreateTime  int64       `protobuf:"varint,2,opt,name=createTime,proto3" json:"createTime,omitempty"`
	Memory      *MemoryStat `protobuf:"bytes,3,opt,name=memory,proto3" json:"memory,omitempty"`
	Cpu         *CPUStat    `protobuf:"bytes,4,opt,name=cpu,proto3" json:"cpu,omitempty"`
	Nice        int32       `protobuf:"varint,5,opt,name=nice,proto3" json:"nice,omitempty"`
	Threads     int32       `protobuf:"varint,7,opt,name=threads,proto3" json:"threads,omitempty"`
	OpenFdCount int32       `protobuf:"varint,8,opt,name=openFdCount,proto3" json:"openFdCount,omitempty"`
	Key         uint32      `protobuf:"varint,9,opt,name=key,proto3" json:"key,omitempty"`
	// we need container id because we need to do the scoring by container
	ContainerId    string         `protobuf:"bytes,10,opt,name=containerId,proto3" json:"containerId,omitempty"`
	ContainerState ContainerState `protobuf:"varint,11,opt,name=containerState,proto3,enum=datadog.process_agent.ContainerState" json:"containerState,omitempty"`
	ProcessState   ProcessState   `protobuf:"varint,12,opt,name=processState,proto3,enum=datadog.process_agent.ProcessState" json:"processState,omitempty"`
	IoStat         *IOStat        `protobuf:"bytes,19,opt,name=ioStat,proto3" json:"ioStat,omitempty"`
	// DEPRECATED: All container-level stats (except ID) have moved into ContainerStat.
	// These will be removed in the future.
	// These stats are from the container level but are stored per-process
	// because we don't send a container primitive yet.
	ContainerHealth        ContainerHealth `protobuf:"varint,15,opt,name=containerHealth,proto3,enum=datadog.process_agent.ContainerHealth" json:"containerHealth,omitempty"`
	ContainerRbps          float32         `protobuf:"fixed32,16,opt,name=containerRbps,proto3" json:"containerRbps,omitempty"`
	ContainerWbps          float32         `protobuf:"fixed32,17,opt,name=containerWbps,proto3" json:"containerWbps,omitempty"`
	ContainerKey           uint32          `protobuf:"varint,18,opt,name=containerKey,proto3" json:"containerKey,omitempty"`
	ContainerNetRcvdPs     float32         `protobuf:"fixed32,20,opt,name=containerNetRcvdPs,proto3" json:"containerNetRcvdPs,omitempty"`
	ContainerNetSentPs     float32         `protobuf:"fixed32,21,opt,name=containerNetSentPs,proto3" json:"containerNetSentPs,omitempty"`
	ContainerNetRcvdBps    float32         `protobuf:"fixed32,22,opt,name=containerNetRcvdBps,proto3" json:"containerNetRcvdBps,omitempty"`
	ContainerNetSentBps    float32         `protobuf:"fixed32,23,opt,name=containerNetSentBps,proto3" json:"containerNetSentBps,omitempty"`
	VoluntaryCtxSwitches   uint64          `protobuf:"varint,24,opt,name=voluntaryCtxSwitches,proto3" json:"voluntaryCtxSwitches,omitempty"`
	InvoluntaryCtxSwitches uint64          `protobuf:"varint,25,opt,name=involuntaryCtxSwitches,proto3" json:"involuntaryCtxSwitches,omitempty"`
	ByteKey                []byte          `protobuf:"bytes,26,opt,name=byteKey,proto3" json:"byteKey,omitempty"`
	ContainerByteKey       []byte          `protobuf:"bytes,27,opt,name=containerByteKey,proto3" json:"containerByteKey,omitempty"`
	Tags                   []string        `protobuf:"bytes,28,rep,name=tags,proto3" json:"tags,omitempty"`
}

func (m *ProcessStat) Reset()         { *m = ProcessStat{} }
func (m *ProcessStat) String() string { return proto.CompactTextString(m) }
func (*ProcessStat) ProtoMessage()    {}
func (*ProcessStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{14}
}
func (m *ProcessStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessStat.Merge(m, src)
}
func (m *ProcessStat) XXX_Size() int {
	return m.Size()
}
func (m *ProcessStat) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessStat.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessStat proto.InternalMessageInfo

func (m *ProcessStat) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *ProcessStat) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *ProcessStat) GetMemory() *MemoryStat {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *ProcessStat) GetCpu() *CPUStat {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *ProcessStat) GetNice() int32 {
	if m != nil {
		return m.Nice
	}
	return 0
}

func (m *ProcessStat) GetThreads() int32 {
	if m != nil {
		return m.Threads
	}
	return 0
}

func (m *ProcessStat) GetOpenFdCount() int32 {
	if m != nil {
		return m.OpenFdCount
	}
	return 0
}

func (m *ProcessStat) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *ProcessStat) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

func (m *ProcessStat) GetContainerState() ContainerState {
	if m != nil {
		return m.ContainerState
	}
	return ContainerState_unknown
}

func (m *ProcessStat) GetProcessState() ProcessState {
	if m != nil {
		return m.ProcessState
	}
	return ProcessState_U
}

func (m *ProcessStat) GetIoStat() *IOStat {
	if m != nil {
		return m.IoStat
	}
	return nil
}

func (m *ProcessStat) GetContainerHealth() ContainerHealth {
	if m != nil {
		return m.ContainerHealth
	}
	return ContainerHealth_unknownHealth
}

func (m *ProcessStat) GetContainerRbps() float32 {
	if m != nil {
		return m.ContainerRbps
	}
	return 0
}

func (m *ProcessStat) GetContainerWbps() float32 {
	if m != nil {
		return m.ContainerWbps
	}
	return 0
}

func (m *ProcessStat) GetContainerKey() uint32 {
	if m != nil {
		return m.ContainerKey
	}
	return 0
}

func (m *ProcessStat) GetContainerNetRcvdPs() float32 {
	if m != nil {
		return m.ContainerNetRcvdPs
	}
	return 0
}

func (m *ProcessStat) GetContainerNetSentPs() float32 {
	if m != nil {
		return m.ContainerNetSentPs
	}
	return 0
}

func (m *ProcessStat) GetContainerNetRcvdBps() float32 {
	if m != nil {
		return m.ContainerNetRcvdBps
	}
	return 0
}

func (m *ProcessStat) GetContainerNetSentBps() float32 {
	if m != nil {
		return m.ContainerNetSentBps
	}
	return 0
}

func (m *ProcessStat) GetVoluntaryCtxSwitches() uint64 {
	if m != nil {
		return m.VoluntaryCtxSwitches
	}
	return 0
}

func (m *ProcessStat) GetInvoluntaryCtxSwitches() uint64 {
	if m != nil {
		return m.InvoluntaryCtxSwitches
	}
	return 0
}

func (m *ProcessStat) GetByteKey() []byte {
	if m != nil {
		return m.ByteKey
	}
	return nil
}

func (m *ProcessStat) GetContainerByteKey() []byte {
	if m != nil {
		return m.ContainerByteKey
	}
	return nil
}

func (m *ProcessStat) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// ContainerStat is used for real-time container messages. It should only contain
// data that can change for a running container (and relevant information to
// generate a key). We will send a lot of these in the real-time messages so
// it's critical to keep this small (basically no strings except ID)
type ContainerStat struct {
	Id         string          `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	UserPct    float32         `protobuf:"fixed32,2,opt,name=userPct,proto3" json:"userPct,omitempty"`
	SystemPct  float32         `protobuf:"fixed32,3,opt,name=systemPct,proto3" json:"systemPct,omitempty"`
	TotalPct   float32         `protobuf:"fixed32,4,opt,name=totalPct,proto3" json:"totalPct,omitempty"`
	CpuLimit   float32         `protobuf:"fixed32,5,opt,name=cpuLimit,proto3" json:"cpuLimit,omitempty"`
	MemRss     uint64          `protobuf:"varint,6,opt,name=memRss,proto3" json:"memRss,omitempty"`
	MemCache   uint64          `protobuf:"varint,7,opt,name=memCache,proto3" json:"memCache,omitempty"`
	MemLimit   uint64          `protobuf:"varint,8,opt,name=memLimit,proto3" json:"memLimit,omitempty"`
	Rbps       float32         `protobuf:"fixed32,9,opt,name=rbps,proto3" json:"rbps,omitempty"`
	Wbps       float32         `protobuf:"fixed32,10,opt,name=wbps,proto3" json:"wbps,omitempty"`
	NetRcvdPs  float32         `protobuf:"fixed32,11,opt,name=netRcvdPs,proto3" json:"netRcvdPs,omitempty"`
	NetSentPs  float32         `protobuf:"fixed32,12,opt,name=netSentPs,proto3" json:"netSentPs,omitempty"`
	NetRcvdBps float32         `protobuf:"fixed32,13,opt,name=netRcvdBps,proto3" json:"netRcvdBps,omitempty"`
	NetSentBps float32         `protobuf:"fixed32,14,opt,name=netSentBps,proto3" json:"netSentBps,omitempty"`
	State      ContainerState  `protobuf:"varint,15,opt,name=state,proto3,enum=datadog.process_agent.ContainerState" json:"state,omitempty"`
	Health     ContainerHealth `protobuf:"varint,16,opt,name=health,proto3,enum=datadog.process_agent.ContainerHealth" json:"health,omitempty"`
	// Post-resolved fields
	Key     uint32 `protobuf:"varint,17,opt,name=key,proto3" json:"key,omitempty"`
	Started int64  `protobuf:"varint,18,opt,name=started,proto3" json:"started,omitempty"`
	ByteKey []byte `protobuf:"bytes,19,opt,name=byteKey,proto3" json:"byteKey,omitempty"`
}

func (m *ContainerStat) Reset()         { *m = ContainerStat{} }
func (m *ContainerStat) String() string { return proto.CompactTextString(m) }
func (*ContainerStat) ProtoMessage()    {}
func (*ContainerStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{15}
}
func (m *ContainerStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerStat.Merge(m, src)
}
func (m *ContainerStat) XXX_Size() int {
	return m.Size()
}
func (m *ContainerStat) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerStat.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerStat proto.InternalMessageInfo

func (m *ContainerStat) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ContainerStat) GetUserPct() float32 {
	if m != nil {
		return m.UserPct
	}
	return 0
}

func (m *ContainerStat) GetSystemPct() float32 {
	if m != nil {
		return m.SystemPct
	}
	return 0
}

func (m *ContainerStat) GetTotalPct() float32 {
	if m != nil {
		return m.TotalPct
	}
	return 0
}

func (m *ContainerStat) GetCpuLimit() float32 {
	if m != nil {
		return m.CpuLimit
	}
	return 0
}

func (m *ContainerStat) GetMemRss() uint64 {
	if m != nil {
		return m.MemRss
	}
	return 0
}

func (m *ContainerStat) GetMemCache() uint64 {
	if m != nil {
		return m.MemCache
	}
	return 0
}

func (m *ContainerStat) GetMemLimit() uint64 {
	if m != nil {
		return m.MemLimit
	}
	return 0
}

func (m *ContainerStat) GetRbps() float32 {
	if m != nil {
		return m.Rbps
	}
	return 0
}

func (m *ContainerStat) GetWbps() float32 {
	if m != nil {
		return m.Wbps
	}
	return 0
}

func (m *ContainerStat) GetNetRcvdPs() float32 {
	if m != nil {
		return m.NetRcvdPs
	}
	return 0
}

func (m *ContainerStat) GetNetSentPs() float32 {
	if m != nil {
		return m.NetSentPs
	}
	return 0
}

func (m *ContainerStat) GetNetRcvdBps() float32 {
	if m != nil {
		return m.NetRcvdBps
	}
	return 0
}

func (m *ContainerStat) GetNetSentBps() float32 {
	if m != nil {
		return m.NetSentBps
	}
	return 0
}

func (m *ContainerStat) GetState() ContainerState {
	if m != nil {
		return m.State
	}
	return ContainerState_unknown
}

func (m *ContainerStat) GetHealth() ContainerHealth {
	if m != nil {
		return m.Health
	}
	return ContainerHealth_unknownHealth
}

func (m *ContainerStat) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *ContainerStat) GetStarted() int64 {
	if m != nil {
		return m.Started
	}
	return 0
}

func (m *ContainerStat) GetByteKey() []byte {
	if m != nil {
		return m.ByteKey
	}
	return nil
}

type SystemInfo struct {
	Uuid string     `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Os   *OSInfo    `protobuf:"bytes,2,opt,name=os,proto3" json:"os,omitempty"`
	Cpus []*CPUInfo `protobuf:"bytes,3,rep,name=cpus,proto3" json:"cpus,omitempty"`
	// 4 is deprecated
	TotalMemory int64 `protobuf:"varint,5,opt,name=totalMemory,proto3" json:"totalMemory,omitempty"`
}

func (m *SystemInfo) Reset()         { *m = SystemInfo{} }
func (m *SystemInfo) String() string { return proto.CompactTextString(m) }
func (*SystemInfo) ProtoMessage()    {}
func (*SystemInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{16}
}
func (m *SystemInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SystemInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SystemInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemInfo.Merge(m, src)
}
func (m *SystemInfo) XXX_Size() int {
	return m.Size()
}
func (m *SystemInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SystemInfo proto.InternalMessageInfo

func (m *SystemInfo) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *SystemInfo) GetOs() *OSInfo {
	if m != nil {
		return m.Os
	}
	return nil
}

func (m *SystemInfo) GetCpus() []*CPUInfo {
	if m != nil {
		return m.Cpus
	}
	return nil
}

func (m *SystemInfo) GetTotalMemory() int64 {
	if m != nil {
		return m.TotalMemory
	}
	return 0
}

type OSInfo struct {
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Platform      string `protobuf:"bytes,2,opt,name=platform,proto3" json:"platform,omitempty"`
	Family        string `protobuf:"bytes,3,opt,name=family,proto3" json:"family,omitempty"`
	Version       string `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	KernelVersion string `protobuf:"bytes,5,opt,name=kernelVersion,proto3" json:"kernelVersion,omitempty"`
}

func (m *OSInfo) Reset()         { *m = OSInfo{} }
func (m *OSInfo) String() string { return proto.CompactTextString(m) }
func (*OSInfo) ProtoMessage()    {}
func (*OSInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{17}
}
func (m *OSInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OSInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSInfo.Merge(m, src)
}
func (m *OSInfo) XXX_Size() int {
	return m.Size()
}
func (m *OSInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OSInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OSInfo proto.InternalMessageInfo

func (m *OSInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OSInfo) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *OSInfo) GetFamily() string {
	if m != nil {
		return m.Family
	}
	return ""
}

func (m *OSInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *OSInfo) GetKernelVersion() string {
	if m != nil {
		return m.KernelVersion
	}
	return ""
}

type IOStat struct {
	ReadRate       float32 `protobuf:"fixed32,1,opt,name=readRate,proto3" json:"readRate,omitempty"`
	WriteRate      float32 `protobuf:"fixed32,2,opt,name=writeRate,proto3" json:"writeRate,omitempty"`
	ReadBytesRate  float32 `protobuf:"fixed32,3,opt,name=readBytesRate,proto3" json:"readBytesRate,omitempty"`
	WriteBytesRate float32 `protobuf:"fixed32,4,opt,name=writeBytesRate,proto3" json:"writeBytesRate,omitempty"`
}

func (m *IOStat) Reset()         { *m = IOStat{} }
func (m *IOStat) String() string { return proto.CompactTextString(m) }
func (*IOStat) ProtoMessage()    {}
func (*IOStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{18}
}
func (m *IOStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IOStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IOStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IOStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IOStat.Merge(m, src)
}
func (m *IOStat) XXX_Size() int {
	return m.Size()
}
func (m *IOStat) XXX_DiscardUnknown() {
	xxx_messageInfo_IOStat.DiscardUnknown(m)
}

var xxx_messageInfo_IOStat proto.InternalMessageInfo

func (m *IOStat) GetReadRate() float32 {
	if m != nil {
		return m.ReadRate
	}
	return 0
}

func (m *IOStat) GetWriteRate() float32 {
	if m != nil {
		return m.WriteRate
	}
	return 0
}

func (m *IOStat) GetReadBytesRate() float32 {
	if m != nil {
		return m.ReadBytesRate
	}
	return 0
}

func (m *IOStat) GetWriteBytesRate() float32 {
	if m != nil {
		return m.WriteBytesRate
	}
	return 0
}

type Label struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Label) Reset()         { *m = Label{} }
func (m *Label) String() string { return proto.CompactTextString(m) }
func (*Label) ProtoMessage()    {}
func (*Label) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{19}
}
func (m *Label) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Label) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Label.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Label) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Label.Merge(m, src)
}
func (m *Label) XXX_Size() int {
	return m.Size()
}
func (m *Label) XXX_DiscardUnknown() {
	xxx_messageInfo_Label.DiscardUnknown(m)
}

var xxx_messageInfo_Label proto.InternalMessageInfo

func (m *Label) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Label) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type HistogramItem struct {
	Quantile float32 `protobuf:"fixed32,1,opt,name=quantile,proto3" json:"quantile,omitempty"`
	Value    float32 `protobuf:"fixed32,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *HistogramItem) Reset()         { *m = HistogramItem{} }
func (m *HistogramItem) String() string { return proto.CompactTextString(m) }
func (*HistogramItem) ProtoMessage()    {}
func (*HistogramItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{20}
}
func (m *HistogramItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HistogramItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HistogramItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HistogramItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HistogramItem.Merge(m, src)
}
func (m *HistogramItem) XXX_Size() int {
	return m.Size()
}
func (m *HistogramItem) XXX_DiscardUnknown() {
	xxx_messageInfo_HistogramItem.DiscardUnknown(m)
}

var xxx_messageInfo_HistogramItem proto.InternalMessageInfo

func (m *HistogramItem) GetQuantile() float32 {
	if m != nil {
		return m.Quantile
	}
	return 0
}

func (m *HistogramItem) GetValue() float32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type Histogram struct {
	Items []*HistogramItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *Histogram) Reset()         { *m = Histogram{} }
func (m *Histogram) String() string { return proto.CompactTextString(m) }
func (*Histogram) ProtoMessage()    {}
func (*Histogram) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{21}
}
func (m *Histogram) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Histogram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Histogram.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Histogram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Histogram.Merge(m, src)
}
func (m *Histogram) XXX_Size() int {
	return m.Size()
}
func (m *Histogram) XXX_DiscardUnknown() {
	xxx_messageInfo_Histogram.DiscardUnknown(m)
}

var xxx_messageInfo_Histogram proto.InternalMessageInfo

func (m *Histogram) GetItems() []*HistogramItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type Metric struct {
	Labels    []*Label   `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty"`
	Histogram *Histogram `protobuf:"bytes,2,opt,name=histogram,proto3" json:"histogram,omitempty"`
}

func (m *Metric) Reset()         { *m = Metric{} }
func (m *Metric) String() string { return proto.CompactTextString(m) }
func (*Metric) ProtoMessage()    {}
func (*Metric) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{22}
}
func (m *Metric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metric.Merge(m, src)
}
func (m *Metric) XXX_Size() int {
	return m.Size()
}
func (m *Metric) XXX_DiscardUnknown() {
	xxx_messageInfo_Metric.DiscardUnknown(m)
}

var xxx_messageInfo_Metric proto.InternalMessageInfo

func (m *Metric) GetLabels() []*Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Metric) GetHistogram() *Histogram {
	if m != nil {
		return m.Histogram
	}
	return nil
}

type Connection struct {
	Pid int32 `protobuf:"varint,1,opt,name=pid,proto3" json:"pid,omitempty"`
	// 2 is deprecated
	// 3 is deprecated
	// 4 is deprecated
	Laddr *Addr `protobuf:"bytes,5,opt,name=laddr,proto3" json:"laddr,omitempty"`
	Raddr *Addr `protobuf:"bytes,6,opt,name=raddr,proto3" json:"raddr,omitempty"`
	// 7 is deprecated
	BytesSentPerSecond     float32             `protobuf:"fixed32,8,opt,name=bytesSentPerSecond,proto3" json:"bytesSentPerSecond,omitempty"`
	BytesReceivedPerSecond float32             `protobuf:"fixed32,9,opt,name=bytesReceivedPerSecond,proto3" json:"bytesReceivedPerSecond,omitempty"`
	Family                 ConnectionFamily    `protobuf:"varint,10,opt,name=family,proto3,enum=datadog.process_agent.ConnectionFamily" json:"family,omitempty"`
	Type                   ConnectionType      `protobuf:"varint,11,opt,name=type,proto3,enum=datadog.process_agent.ConnectionType" json:"type,omitempty"`
	PidCreateTime          int64               `protobuf:"varint,12,opt,name=pidCreateTime,proto3" json:"pidCreateTime,omitempty"`
	Namespace              string              `protobuf:"bytes,50,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Direction              ConnectionDirection `protobuf:"varint,51,opt,name=direction,proto3,enum=datadog.process_agent.ConnectionDirection" json:"direction,omitempty"`
	ConnectionIdentifier   string              `protobuf:"bytes,52,opt,name=connectionIdentifier,proto3" json:"connectionIdentifier,omitempty"`
	DetectedProtocol       string              `protobuf:"bytes,53,opt,name=detectedProtocol,proto3" json:"detectedProtocol,omitempty"`
	Metrics                []*Metric           `protobuf:"bytes,54,rep,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *Connection) Reset()         { *m = Connection{} }
func (m *Connection) String() string { return proto.CompactTextString(m) }
func (*Connection) ProtoMessage()    {}
func (*Connection) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{23}
}
func (m *Connection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Connection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Connection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Connection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Connection.Merge(m, src)
}
func (m *Connection) XXX_Size() int {
	return m.Size()
}
func (m *Connection) XXX_DiscardUnknown() {
	xxx_messageInfo_Connection.DiscardUnknown(m)
}

var xxx_messageInfo_Connection proto.InternalMessageInfo

func (m *Connection) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *Connection) GetLaddr() *Addr {
	if m != nil {
		return m.Laddr
	}
	return nil
}

func (m *Connection) GetRaddr() *Addr {
	if m != nil {
		return m.Raddr
	}
	return nil
}

func (m *Connection) GetBytesSentPerSecond() float32 {
	if m != nil {
		return m.BytesSentPerSecond
	}
	return 0
}

func (m *Connection) GetBytesReceivedPerSecond() float32 {
	if m != nil {
		return m.BytesReceivedPerSecond
	}
	return 0
}

func (m *Connection) GetFamily() ConnectionFamily {
	if m != nil {
		return m.Family
	}
	return ConnectionFamily_v4
}

func (m *Connection) GetType() ConnectionType {
	if m != nil {
		return m.Type
	}
	return ConnectionType_tcp
}

func (m *Connection) GetPidCreateTime() int64 {
	if m != nil {
		return m.PidCreateTime
	}
	return 0
}

func (m *Connection) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Connection) GetDirection() ConnectionDirection {
	if m != nil {
		return m.Direction
	}
	return ConnectionDirection_none
}

func (m *Connection) GetConnectionIdentifier() string {
	if m != nil {
		return m.ConnectionIdentifier
	}
	return ""
}

func (m *Connection) GetDetectedProtocol() string {
	if m != nil {
		return m.DetectedProtocol
	}
	return ""
}

func (m *Connection) GetMetrics() []*Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type Addr struct {
	Host *Host  `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	Ip   string `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
	Port int32  `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *Addr) Reset()         { *m = Addr{} }
func (m *Addr) String() string { return proto.CompactTextString(m) }
func (*Addr) ProtoMessage()    {}
func (*Addr) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{24}
}
func (m *Addr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Addr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Addr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Addr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Addr.Merge(m, src)
}
func (m *Addr) XXX_Size() int {
	return m.Size()
}
func (m *Addr) XXX_DiscardUnknown() {
	xxx_messageInfo_Addr.DiscardUnknown(m)
}

var xxx_messageInfo_Addr proto.InternalMessageInfo

func (m *Addr) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *Addr) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Addr) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type MemoryStat struct {
	Rss    uint64 `protobuf:"varint,1,opt,name=rss,proto3" json:"rss,omitempty"`
	Vms    uint64 `protobuf:"varint,2,opt,name=vms,proto3" json:"vms,omitempty"`
	Swap   uint64 `protobuf:"varint,3,opt,name=swap,proto3" json:"swap,omitempty"`
	Shared uint64 `protobuf:"varint,4,opt,name=shared,proto3" json:"shared,omitempty"`
	Text   uint64 `protobuf:"varint,5,opt,name=text,proto3" json:"text,omitempty"`
	Lib    uint64 `protobuf:"varint,6,opt,name=lib,proto3" json:"lib,omitempty"`
	Data   uint64 `protobuf:"varint,7,opt,name=data,proto3" json:"data,omitempty"`
	Dirty  uint64 `protobuf:"varint,8,opt,name=dirty,proto3" json:"dirty,omitempty"`
}

func (m *MemoryStat) Reset()         { *m = MemoryStat{} }
func (m *MemoryStat) String() string { return proto.CompactTextString(m) }
func (*MemoryStat) ProtoMessage()    {}
func (*MemoryStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{25}
}
func (m *MemoryStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryStat.Merge(m, src)
}
func (m *MemoryStat) XXX_Size() int {
	return m.Size()
}
func (m *MemoryStat) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryStat.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryStat proto.InternalMessageInfo

func (m *MemoryStat) GetRss() uint64 {
	if m != nil {
		return m.Rss
	}
	return 0
}

func (m *MemoryStat) GetVms() uint64 {
	if m != nil {
		return m.Vms
	}
	return 0
}

func (m *MemoryStat) GetSwap() uint64 {
	if m != nil {
		return m.Swap
	}
	return 0
}

func (m *MemoryStat) GetShared() uint64 {
	if m != nil {
		return m.Shared
	}
	return 0
}

func (m *MemoryStat) GetText() uint64 {
	if m != nil {
		return m.Text
	}
	return 0
}

func (m *MemoryStat) GetLib() uint64 {
	if m != nil {
		return m.Lib
	}
	return 0
}

func (m *MemoryStat) GetData() uint64 {
	if m != nil {
		return m.Data
	}
	return 0
}

func (m *MemoryStat) GetDirty() uint64 {
	if m != nil {
		return m.Dirty
	}
	return 0
}

type CPUStat struct {
	LastCpu    string           `protobuf:"bytes,1,opt,name=lastCpu,proto3" json:"lastCpu,omitempty"`
	TotalPct   float32          `protobuf:"fixed32,2,opt,name=totalPct,proto3" json:"totalPct,omitempty"`
	UserPct    float32          `protobuf:"fixed32,3,opt,name=userPct,proto3" json:"userPct,omitempty"`
	SystemPct  float32          `protobuf:"fixed32,4,opt,name=systemPct,proto3" json:"systemPct,omitempty"`
	NumThreads int32            `protobuf:"varint,5,opt,name=numThreads,proto3" json:"numThreads,omitempty"`
	Cpus       []*SingleCPUStat `protobuf:"bytes,6,rep,name=cpus,proto3" json:"cpus,omitempty"`
	Nice       int32            `protobuf:"varint,7,opt,name=nice,proto3" json:"nice,omitempty"`
	UserTime   int64            `protobuf:"varint,8,opt,name=userTime,proto3" json:"userTime,omitempty"`
	SystemTime int64            `protobuf:"varint,9,opt,name=systemTime,proto3" json:"systemTime,omitempty"`
}

func (m *CPUStat) Reset()         { *m = CPUStat{} }
func (m *CPUStat) String() string { return proto.CompactTextString(m) }
func (*CPUStat) ProtoMessage()    {}
func (*CPUStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{26}
}
func (m *CPUStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPUStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPUStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CPUStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPUStat.Merge(m, src)
}
func (m *CPUStat) XXX_Size() int {
	return m.Size()
}
func (m *CPUStat) XXX_DiscardUnknown() {
	xxx_messageInfo_CPUStat.DiscardUnknown(m)
}

var xxx_messageInfo_CPUStat proto.InternalMessageInfo

func (m *CPUStat) GetLastCpu() string {
	if m != nil {
		return m.LastCpu
	}
	return ""
}

func (m *CPUStat) GetTotalPct() float32 {
	if m != nil {
		return m.TotalPct
	}
	return 0
}

func (m *CPUStat) GetUserPct() float32 {
	if m != nil {
		return m.UserPct
	}
	return 0
}

func (m *CPUStat) GetSystemPct() float32 {
	if m != nil {
		return m.SystemPct
	}
	return 0
}

func (m *CPUStat) GetNumThreads() int32 {
	if m != nil {
		return m.NumThreads
	}
	return 0
}

func (m *CPUStat) GetCpus() []*SingleCPUStat {
	if m != nil {
		return m.Cpus
	}
	return nil
}

func (m *CPUStat) GetNice() int32 {
	if m != nil {
		return m.Nice
	}
	return 0
}

func (m *CPUStat) GetUserTime() int64 {
	if m != nil {
		return m.UserTime
	}
	return 0
}

func (m *CPUStat) GetSystemTime() int64 {
	if m != nil {
		return m.SystemTime
	}
	return 0
}

type SingleCPUStat struct {
	Name     string  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	TotalPct float32 `protobuf:"fixed32,2,opt,name=totalPct,proto3" json:"totalPct,omitempty"`
}

func (m *SingleCPUStat) Reset()         { *m = SingleCPUStat{} }
func (m *SingleCPUStat) String() string { return proto.CompactTextString(m) }
func (*SingleCPUStat) ProtoMessage()    {}
func (*SingleCPUStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{27}
}
func (m *SingleCPUStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SingleCPUStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SingleCPUStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SingleCPUStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SingleCPUStat.Merge(m, src)
}
func (m *SingleCPUStat) XXX_Size() int {
	return m.Size()
}
func (m *SingleCPUStat) XXX_DiscardUnknown() {
	xxx_messageInfo_SingleCPUStat.DiscardUnknown(m)
}

var xxx_messageInfo_SingleCPUStat proto.InternalMessageInfo

func (m *SingleCPUStat) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SingleCPUStat) GetTotalPct() float32 {
	if m != nil {
		return m.TotalPct
	}
	return 0
}

type CPUInfo struct {
	Number     int32  `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	Vendor     string `protobuf:"bytes,2,opt,name=vendor,proto3" json:"vendor,omitempty"`
	Family     string `protobuf:"bytes,3,opt,name=family,proto3" json:"family,omitempty"`
	Model      string `protobuf:"bytes,4,opt,name=model,proto3" json:"model,omitempty"`
	PhysicalId string `protobuf:"bytes,5,opt,name=physicalId,proto3" json:"physicalId,omitempty"`
	CoreId     string `protobuf:"bytes,6,opt,name=coreId,proto3" json:"coreId,omitempty"`
	Cores      int32  `protobuf:"varint,7,opt,name=cores,proto3" json:"cores,omitempty"`
	Mhz        int64  `protobuf:"varint,8,opt,name=mhz,proto3" json:"mhz,omitempty"`
	CacheSize  int32  `protobuf:"varint,9,opt,name=cacheSize,proto3" json:"cacheSize,omitempty"`
}

func (m *CPUInfo) Reset()         { *m = CPUInfo{} }
func (m *CPUInfo) String() string { return proto.CompactTextString(m) }
func (*CPUInfo) ProtoMessage()    {}
func (*CPUInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{28}
}
func (m *CPUInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPUInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPUInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CPUInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPUInfo.Merge(m, src)
}
func (m *CPUInfo) XXX_Size() int {
	return m.Size()
}
func (m *CPUInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CPUInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CPUInfo proto.InternalMessageInfo

func (m *CPUInfo) GetNumber() int32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *CPUInfo) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *CPUInfo) GetFamily() string {
	if m != nil {
		return m.Family
	}
	return ""
}

func (m *CPUInfo) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *CPUInfo) GetPhysicalId() string {
	if m != nil {
		return m.PhysicalId
	}
	return ""
}

func (m *CPUInfo) GetCoreId() string {
	if m != nil {
		return m.CoreId
	}
	return ""
}

func (m *CPUInfo) GetCores() int32 {
	if m != nil {
		return m.Cores
	}
	return 0
}

func (m *CPUInfo) GetMhz() int64 {
	if m != nil {
		return m.Mhz
	}
	return 0
}

func (m *CPUInfo) GetCacheSize() int32 {
	if m != nil {
		return m.CacheSize
	}
	return 0
}

type Host struct {
	Id          int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	OrgId       int32       `protobuf:"varint,2,opt,name=orgId,proto3" json:"orgId,omitempty"`
	Name        string      `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Tags        []*HostTags `protobuf:"bytes,4,rep,name=tags,proto3" json:"tags,omitempty"`
	AllTags     []string    `protobuf:"bytes,6,rep,name=allTags,proto3" json:"allTags,omitempty"`
	NumCpus     int32       `protobuf:"varint,7,opt,name=numCpus,proto3" json:"numCpus,omitempty"`
	TotalMemory int64       `protobuf:"varint,8,opt,name=totalMemory,proto3" json:"totalMemory,omitempty"`
}

func (m *Host) Reset()         { *m = Host{} }
func (m *Host) String() string { return proto.CompactTextString(m) }
func (*Host) ProtoMessage()    {}
func (*Host) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{29}
}
func (m *Host) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Host) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Host.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Host) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Host.Merge(m, src)
}
func (m *Host) XXX_Size() int {
	return m.Size()
}
func (m *Host) XXX_DiscardUnknown() {
	xxx_messageInfo_Host.DiscardUnknown(m)
}

var xxx_messageInfo_Host proto.InternalMessageInfo

func (m *Host) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Host) GetOrgId() int32 {
	if m != nil {
		return m.OrgId
	}
	return 0
}

func (m *Host) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Host) GetTags() []*HostTags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Host) GetAllTags() []string {
	if m != nil {
		return m.AllTags
	}
	return nil
}

func (m *Host) GetNumCpus() int32 {
	if m != nil {
		return m.NumCpus
	}
	return 0
}

func (m *Host) GetTotalMemory() int64 {
	if m != nil {
		return m.TotalMemory
	}
	return 0
}

type HostTags struct {
	SourceType uint32   `protobuf:"varint,1,opt,name=sourceType,proto3" json:"sourceType,omitempty"`
	Tags       []string `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
}

func (m *HostTags) Reset()         { *m = HostTags{} }
func (m *HostTags) String() string { return proto.CompactTextString(m) }
func (*HostTags) ProtoMessage()    {}
func (*HostTags) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{30}
}
func (m *HostTags) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HostTags) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HostTags.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HostTags) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostTags.Merge(m, src)
}
func (m *HostTags) XXX_Size() int {
	return m.Size()
}
func (m *HostTags) XXX_DiscardUnknown() {
	xxx_messageInfo_HostTags.DiscardUnknown(m)
}

var xxx_messageInfo_HostTags proto.InternalMessageInfo

func (m *HostTags) GetSourceType() uint32 {
	if m != nil {
		return m.SourceType
	}
	return 0
}

func (m *HostTags) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func init() {
	proto.RegisterEnum("datadog.process_agent.ContainerState", ContainerState_name, ContainerState_value)
	proto.RegisterEnum("datadog.process_agent.ContainerHealth", ContainerHealth_name, ContainerHealth_value)
	proto.RegisterEnum("datadog.process_agent.ProcessState", ProcessState_name, ProcessState_value)
	proto.RegisterEnum("datadog.process_agent.ConnectionType", ConnectionType_name, ConnectionType_value)
	proto.RegisterEnum("datadog.process_agent.ConnectionFamily", ConnectionFamily_name, ConnectionFamily_value)
	proto.RegisterEnum("datadog.process_agent.ConnectionDirection", ConnectionDirection_name, ConnectionDirection_value)
	proto.RegisterType((*ResCollector)(nil), "datadog.process_agent.ResCollector")
	proto.RegisterType((*ResCollector_Header)(nil), "datadog.process_agent.ResCollector.Header")
	proto.RegisterType((*CollectorProc)(nil), "datadog.process_agent.CollectorProc")
	proto.RegisterType((*CollectorCommands)(nil), "datadog.process_agent.CollectorCommands")
	proto.RegisterType((*CollectorConnections)(nil), "datadog.process_agent.CollectorConnections")
	proto.RegisterType((*CollectorRealTime)(nil), "datadog.process_agent.CollectorRealTime")
	proto.RegisterType((*CollectorContainer)(nil), "datadog.process_agent.CollectorContainer")
	proto.RegisterType((*CollectorContainerRealTime)(nil), "datadog.process_agent.CollectorContainerRealTime")
	proto.RegisterType((*CollectorReqStatus)(nil), "datadog.process_agent.CollectorReqStatus")
	proto.RegisterType((*CollectorCommand)(nil), "datadog.process_agent.CollectorCommand")
	proto.RegisterType((*CollectorStatus)(nil), "datadog.process_agent.CollectorStatus")
	proto.RegisterType((*Process)(nil), "datadog.process_agent.Process")
	proto.RegisterType((*Command)(nil), "datadog.process_agent.Command")
	proto.RegisterType((*ProcessUser)(nil), "datadog.process_agent.ProcessUser")
	proto.RegisterType((*Container)(nil), "datadog.process_agent.Container")
	proto.RegisterType((*ProcessStat)(nil), "datadog.process_agent.ProcessStat")
	proto.RegisterType((*ContainerStat)(nil), "datadog.process_agent.ContainerStat")
	proto.RegisterType((*SystemInfo)(nil), "datadog.process_agent.SystemInfo")
	proto.RegisterType((*OSInfo)(nil), "datadog.process_agent.OSInfo")
	proto.RegisterType((*IOStat)(nil), "datadog.process_agent.IOStat")
	proto.RegisterType((*Label)(nil), "datadog.process_agent.Label")
	proto.RegisterType((*HistogramItem)(nil), "datadog.process_agent.HistogramItem")
	proto.RegisterType((*Histogram)(nil), "datadog.process_agent.Histogram")
	proto.RegisterType((*Metric)(nil), "datadog.process_agent.Metric")
	proto.RegisterType((*Connection)(nil), "datadog.process_agent.Connection")
	proto.RegisterType((*Addr)(nil), "datadog.process_agent.Addr")
	proto.RegisterType((*MemoryStat)(nil), "datadog.process_agent.MemoryStat")
	proto.RegisterType((*CPUStat)(nil), "datadog.process_agent.CPUStat")
	proto.RegisterType((*SingleCPUStat)(nil), "datadog.process_agent.SingleCPUStat")
	proto.RegisterType((*CPUInfo)(nil), "datadog.process_agent.CPUInfo")
	proto.RegisterType((*Host)(nil), "datadog.process_agent.Host")
	proto.RegisterType((*HostTags)(nil), "datadog.process_agent.HostTags")
}

func init() { proto.RegisterFile("agent.proto", fileDescriptor_56ede974c0020f77) }

var fileDescriptor_56ede974c0020f77 = []byte{
	// 2902 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5a, 0x4b, 0x73, 0x1c, 0xb7,
	0xf1, 0xe7, 0xec, 0x7b, 0x9b, 0x5c, 0x6a, 0x05, 0xd1, 0xf2, 0x98, 0x96, 0xf9, 0xa7, 0xe7, 0xef,
	0xd8, 0x0c, 0xab, 0x2c, 0x39, 0xb2, 0xac, 0xf8, 0x91, 0x92, 0x63, 0xd1, 0x91, 0xc9, 0xb2, 0x24,
	0xb3, 0x40, 0xda, 0x4e, 0x39, 0x07, 0xd7, 0x70, 0x06, 0x5a, 0x4e, 0x69, 0x5e, 0x9e, 0xc1, 0x50,
	0xa2, 0x0f, 0xa9, 0x7c, 0x83, 0xf8, 0x90, 0x1c, 0x7c, 0xcc, 0x21, 0xb7, 0x7c, 0x85, 0x5c, 0x53,
	0xa9, 0xf8, 0xe2, 0xca, 0x29, 0xb9, 0xb9, 0xac, 0xf2, 0xa7, 0xc8, 0x25, 0xd5, 0x0d, 0xcc, 0x6b,
	0x9f, 0xa4, 0x92, 0x43, 0x4e, 0x8b, 0x6e, 0x74, 0x03, 0x0d, 0xa0, 0xfb, 0xd7, 0x0d, 0xcc, 0xc2,
	0xb2, 0x3d, 0x12, 0xa1, 0xbc, 0x1a, 0x27, 0x91, 0x8c, 0xd8, 0x33, 0xae, 0x2d, 0x6d, 0x37, 0x1a,
	0x21, 0xe9, 0x88, 0x34, 0xfd, 0x9c, 0x3a, 0xd7, 0x77, 0x47, 0x9e, 0x3c, 0xce, 0x8e, 0xae, 0x3a,
	0x51, 0x70, 0xed, 0x40, 0xda, 0xce, 0xc3, 0x4f, 0xbc, 0x54, 0xda, 0xd7, 0x52, 0x6c, 0xa6, 0xd2,
	0x96, 0xe2, 0x55, 0x2d, 0xff, 0x2a, 0xc9, 0x5f, 0xa3, 0xc1, 0xae, 0x51, 0xfb, 0xf3, 0xd8, 0x3e,
	0xf5, 0x23, 0xdb, 0x55, 0x13, 0x58, 0x7f, 0x33, 0x60, 0x85, 0x8b, 0x74, 0x27, 0xf2, 0x7d, 0xe1,
	0xc8, 0x28, 0x61, 0xb7, 0xa1, 0x73, 0x2c, 0x6c, 0x57, 0x24, 0xa6, 0xb1, 0x69, 0x6c, 0x2d, 0x5f,
	0xdf, 0xbe, 0x3a, 0xd5, 0x84, 0xab, 0x55, 0xa5, 0xab, 0xbb, 0xa4, 0xc1, 0xb5, 0x26, 0x33, 0xa1,
	0x1b, 0x88, 0x34, 0xb5, 0x47, 0xc2, 0x6c, 0x6c, 0x1a, 0x5b, 0x7d, 0x9e, 0x93, 0xec, 0x16, 0x74,
	0xd0, 0xbe, 0x2c, 0x35, 0x9b, 0x34, 0xfa, 0xcb, 0x33, 0x46, 0x2f, 0x86, 0x3e, 0x20, 0x69, 0xae,
	0xb5, 0xd6, 0xaf, 0x40, 0x47, 0xcd, 0xc5, 0x18, 0xb4, 0xe4, 0x69, 0x2c, 0xcc, 0xd6, 0xa6, 0xb1,
	0xd5, 0xe6, 0xd4, 0xb6, 0xfe, 0xde, 0x84, 0x41, 0xa1, 0xb9, 0x9f, 0x44, 0x0e, 0x5b, 0x87, 0xde,
	0x71, 0x94, 0xca, 0xfb, 0x76, 0x90, 0x9b, 0x52, 0xd0, 0xec, 0x67, 0xd0, 0xd7, 0x93, 0x0a, 0x34,
	0xa7, 0xb9, 0xb5, 0x7c, 0x7d, 0x63, 0x86, 0x39, 0xfb, 0x8a, 0xe2, 0xa5, 0x02, 0xbb, 0x06, 0x2d,
	0x1c, 0x89, 0xe6, 0x5f, 0xbe, 0xfe, 0xfc, 0x0c, 0xc5, 0xdd, 0x28, 0x95, 0x9c, 0x04, 0xd9, 0x1b,
	0xd0, 0xf2, 0xc2, 0x07, 0x91, 0xd9, 0x26, 0x85, 0x17, 0x67, 0x28, 0x1c, 0x9c, 0xa6, 0x52, 0x04,
	0x7b, 0xe1, 0x83, 0x88, 0x93, 0x38, 0xee, 0xe5, 0x28, 0x89, 0xb2, 0x78, 0xcf, 0x35, 0x3b, 0xb4,
	0xd4, 0x9c, 0x64, 0x57, 0xa0, 0x4f, 0xcd, 0x03, 0xef, 0x4b, 0x61, 0x76, 0xa9, 0xaf, 0x64, 0xb0,
	0x3d, 0x80, 0x87, 0xd9, 0x91, 0x48, 0x42, 0x21, 0x45, 0x6a, 0xf6, 0x68, 0xd2, 0x1f, 0x17, 0x93,
	0xd2, 0x64, 0xb9, 0x27, 0x7c, 0x98, 0x1d, 0x89, 0x7b, 0x42, 0xda, 0xd8, 0xb9, 0xaf, 0x78, 0xbc,
	0xa2, 0xcc, 0xde, 0x86, 0xa6, 0x70, 0x52, 0xb3, 0x4f, 0x63, 0x6c, 0x4d, 0x1f, 0xe3, 0x17, 0x3b,
	0x07, 0xe3, 0x43, 0xa0, 0x12, 0xfb, 0x39, 0x80, 0x13, 0x85, 0xd2, 0xf6, 0x42, 0x91, 0xa4, 0x26,
	0xd0, 0x2e, 0x6f, 0xce, 0x3c, 0x74, 0x2d, 0xc8, 0x2b, 0x3a, 0xd6, 0xef, 0x1a, 0x70, 0xb1, 0x38,
	0xd4, 0x9d, 0x28, 0x08, 0xec, 0xd0, 0x4d, 0xe7, 0x1e, 0xec, 0x0e, 0xf4, 0x1c, 0x2d, 0xa7, 0xcf,
	0xf5, 0x95, 0x45, 0x6e, 0xa6, 0xc7, 0xe5, 0x85, 0xe2, 0xff, 0xfa, 0xf9, 0x5a, 0xdf, 0x19, 0xb0,
	0x56, 0x31, 0x3f, 0x0c, 0x85, 0x23, 0xbd, 0x28, 0x5c, 0xb4, 0x33, 0xcb, 0x4e, 0x29, 0xaa, 0x37,
	0xe7, 0xc5, 0xd9, 0xc7, 0xa1, 0x25, 0x79, 0x55, 0xeb, 0xfc, 0x3b, 0x53, 0x59, 0x62, 0x7b, 0xce,
	0x12, 0x3b, 0xe3, 0x4b, 0xfc, 0x67, 0xf5, 0xe4, 0xb9, 0xb0, 0xfd, 0x43, 0x2f, 0x10, 0x73, 0xd7,
	0xf7, 0x26, 0xb4, 0x11, 0x28, 0xf2, 0x95, 0x59, 0xf3, 0xc3, 0x19, 0xb1, 0x85, 0x2b, 0x05, 0x76,
	0x19, 0x3a, 0x38, 0xca, 0x9e, 0xab, 0x01, 0x45, 0x53, 0x6c, 0x0d, 0xda, 0x51, 0x32, 0x2a, 0x2c,
	0x57, 0xc4, 0x53, 0x07, 0xa5, 0x09, 0xdd, 0x30, 0x0b, 0x76, 0xe2, 0x4c, 0x45, 0x64, 0x9b, 0xe7,
	0x24, 0xdb, 0x84, 0x65, 0x19, 0x49, 0xdb, 0xbf, 0x27, 0x82, 0x28, 0x39, 0xa5, 0x58, 0x6b, 0xf2,
	0x2a, 0x8b, 0xdd, 0x85, 0xd5, 0x22, 0x2a, 0x0e, 0x68, 0x91, 0x2a, 0x9a, 0x5e, 0x5a, 0x14, 0x4d,
	0xb4, 0xcc, 0x31, 0x5d, 0xeb, 0xeb, 0x26, 0xb0, 0xaa, 0xfb, 0xa8, 0xbe, 0xda, 0xe6, 0x1a, 0x63,
	0x9b, 0x9b, 0x3b, 0x78, 0xe3, 0x7c, 0x0e, 0x5e, 0x47, 0x80, 0xe6, 0xf9, 0x11, 0xa0, 0xba, 0xdb,
	0xad, 0x39, 0xbb, 0xdd, 0x9e, 0x0f, 0x81, 0x9d, 0xff, 0x02, 0x04, 0x76, 0x9f, 0x06, 0x02, 0xf3,
	0x78, 0xe9, 0x9d, 0x31, 0x5e, 0xac, 0xdf, 0x34, 0x60, 0x7d, 0xf2, 0x6c, 0xa6, 0x06, 0xc0, 0xf8,
	0x19, 0xbd, 0x9d, 0x07, 0x40, 0xe3, 0x1c, 0xbe, 0xa1, 0x43, 0xa0, 0xe2, 0x9c, 0xcd, 0xb9, 0xce,
	0xd9, 0x9a, 0x74, 0xce, 0x32, 0x7c, 0xda, 0xb5, 0xf0, 0x79, 0x5a, 0x74, 0x7b, 0xad, 0xe2, 0x9d,
	0x5c, 0x7c, 0xa1, 0xaa, 0x80, 0x79, 0xa1, 0x6f, 0xfd, 0xab, 0x09, 0xc3, 0x71, 0x38, 0x67, 0x77,
	0x60, 0x90, 0xc5, 0xae, 0x2d, 0x85, 0x8e, 0x78, 0x5d, 0xd3, 0x2c, 0x48, 0xf3, 0xbb, 0x4b, 0xbc,
	0xae, 0xc6, 0x0e, 0x61, 0xad, 0xc6, 0xb8, 0x27, 0x64, 0xe2, 0x39, 0xa9, 0x0e, 0x85, 0xc5, 0xc3,
	0x4d, 0xd5, 0x46, 0xeb, 0x5c, 0xe1, 0x8b, 0xd2, 0xba, 0xe6, 0x59, 0xad, 0xab, 0xa9, 0xb1, 0xbb,
	0x70, 0x41, 0x8d, 0x5f, 0x1c, 0xab, 0x09, 0x34, 0xd2, 0xc2, 0x30, 0xdb, 0x5d, 0xe2, 0xe3, 0xaa,
	0xec, 0x33, 0xb8, 0x3c, 0xc6, 0xca, 0x57, 0xbb, 0x7c, 0xe6, 0x41, 0x67, 0x8c, 0x80, 0x96, 0x2a,
	0xd3, 0x4b, 0x4b, 0x57, 0xce, 0x6e, 0xe9, 0x98, 0xea, 0xed, 0x3e, 0x74, 0x75, 0xba, 0xb6, 0x0e,
	0xe0, 0xc2, 0x58, 0xc9, 0xc8, 0x5e, 0x82, 0x81, 0xed, 0x48, 0xef, 0x44, 0xec, 0xf8, 0x9e, 0x08,
	0xa5, 0x3a, 0xfb, 0x36, 0xaf, 0x33, 0xd1, 0xa5, 0xbc, 0x50, 0x8a, 0xe4, 0xc4, 0xf6, 0xe9, 0x34,
	0xdb, 0xbc, 0xa0, 0xad, 0x3f, 0x77, 0xa0, 0x9b, 0xef, 0xf1, 0x10, 0x9a, 0x0f, 0xc5, 0x29, 0x8d,
	0x31, 0xe0, 0xd8, 0x44, 0x4e, 0xec, 0xb9, 0x5a, 0x09, 0x9b, 0x45, 0xa0, 0x37, 0xcf, 0x9a, 0x18,
	0xdf, 0x2c, 0x16, 0xa0, 0x93, 0xe9, 0xc6, 0xcc, 0x6d, 0x50, 0xe5, 0x49, 0x2e, 0xce, 0x6e, 0x42,
	0x2b, 0x4b, 0x45, 0xa2, 0x8b, 0x8d, 0x05, 0x79, 0xee, 0xe3, 0x54, 0x24, 0x9c, 0xe4, 0xd9, 0x5b,
	0xd0, 0x09, 0x54, 0x10, 0x77, 0xe7, 0xa2, 0xb8, 0x0a, 0x6b, 0x42, 0x07, 0xad, 0xc0, 0x5e, 0x83,
	0xa6, 0x13, 0x67, 0x1a, 0xc5, 0x66, 0x1a, 0xba, 0xff, 0x31, 0x29, 0xa1, 0x28, 0xdb, 0x00, 0x70,
	0x12, 0x61, 0x4b, 0x81, 0xb0, 0xa5, 0x53, 0x5a, 0x85, 0xc3, 0x6e, 0x41, 0xdf, 0x39, 0xaf, 0xc7,
	0xf2, 0x52, 0x05, 0x61, 0x29, 0x8a, 0x45, 0x78, 0xc7, 0xdd, 0x89, 0xb2, 0x50, 0x92, 0x7b, 0xb6,
	0x79, 0x95, 0xc5, 0xde, 0x52, 0x70, 0x28, 0xc8, 0xcb, 0x56, 0xaf, 0xff, 0xff, 0xe2, 0x7a, 0x40,
	0x28, 0x34, 0xc4, 0x6c, 0xd7, 0xf1, 0x22, 0xe4, 0x98, 0x03, 0xb2, 0xec, 0x85, 0x19, 0xba, 0x7b,
	0x1f, 0xa9, 0x5d, 0x52, 0xc2, 0x68, 0x53, 0x61, 0xe0, 0x9e, 0x6b, 0xae, 0x12, 0x4a, 0x55, 0x59,
	0xcc, 0x82, 0x95, 0x82, 0xfc, 0x50, 0x9c, 0x9a, 0x17, 0xc8, 0xa5, 0x6a, 0x3c, 0x76, 0x1d, 0xd6,
	0x4e, 0x22, 0x3f, 0x0b, 0xa5, 0x9d, 0x9c, 0xee, 0xc8, 0xc7, 0x07, 0x8f, 0x3c, 0xe9, 0x1c, 0x8b,
	0xd4, 0x1c, 0x6e, 0x1a, 0x5b, 0x2d, 0x3e, 0xb5, 0x8f, 0xdd, 0x84, 0xcb, 0x5e, 0x38, 0x55, 0xeb,
	0x22, 0x69, 0xcd, 0xe8, 0x45, 0x88, 0x3e, 0x3a, 0x95, 0x02, 0x4d, 0x61, 0x9b, 0xc6, 0xd6, 0x0a,
	0xcf, 0x49, 0xb6, 0x0d, 0xc3, 0xc2, 0xaa, 0xdb, 0x5a, 0xe4, 0x12, 0x89, 0x4c, 0xf0, 0xe9, 0x3a,
	0x66, 0x8f, 0x52, 0x73, 0x6d, 0xb3, 0xb9, 0xd5, 0xe7, 0xd4, 0xb6, 0xbe, 0x36, 0xa0, 0x9b, 0x23,
	0x31, 0x83, 0x96, 0x9d, 0x8c, 0x30, 0x08, 0xa9, 0x1f, 0xdb, 0x18, 0x41, 0xce, 0x23, 0x97, 0xc2,
	0xa5, 0xcf, 0xb1, 0x89, 0x52, 0x49, 0x14, 0xa9, 0xd2, 0xb2, 0xcf, 0xa9, 0x8d, 0xa9, 0x25, 0x0a,
	0xdf, 0xf7, 0xd2, 0x87, 0xe4, 0xec, 0x3d, 0xae, 0x29, 0x94, 0x8d, 0x31, 0x00, 0x55, 0x5e, 0xa1,
	0x36, 0xca, 0xc6, 0x94, 0x44, 0x74, 0x46, 0xd1, 0x14, 0xce, 0x24, 0x1e, 0x0b, 0xf2, 0xdd, 0x3e,
	0xc7, 0xa6, 0xf5, 0x7b, 0x03, 0x96, 0x2b, 0xe1, 0x81, 0xa3, 0x85, 0x65, 0x42, 0xa5, 0x36, 0x6a,
	0x65, 0x65, 0x84, 0x67, 0x9e, 0x8b, 0x9c, 0x91, 0xe7, 0xea, 0xf4, 0x88, 0x4d, 0xd4, 0x13, 0x28,
	0xa4, 0xaf, 0xa1, 0xd8, 0x26, 0x1e, 0x8a, 0xb5, 0x35, 0x4f, 0xcb, 0xa5, 0x59, 0x69, 0x6d, 0xaa,
	0xe5, 0x52, 0x94, 0xeb, 0x6a, 0xde, 0xc8, 0x73, 0xad, 0x1f, 0xda, 0xd0, 0x2f, 0xb1, 0x38, 0xbf,
	0xe4, 0x6a, 0xab, 0xb0, 0xcd, 0x56, 0xa1, 0xa1, 0x8d, 0xea, 0xf3, 0x86, 0x1a, 0x85, 0x2c, 0x6f,
	0x56, 0x2c, 0x5f, 0x83, 0xb6, 0x17, 0xe0, 0xf5, 0x5b, 0x6d, 0xa4, 0x22, 0x10, 0xeb, 0x9c, 0x38,
	0xbb, 0xeb, 0x05, 0x9e, 0x24, 0xdb, 0x1a, 0xbc, 0xa0, 0xd1, 0x6f, 0x55, 0x9c, 0xab, 0xee, 0x0e,
	0xb9, 0x4c, 0x95, 0xc5, 0xde, 0xc9, 0x63, 0xa9, 0x47, 0xb1, 0xf4, 0xa3, 0xb3, 0x94, 0x16, 0x45,
	0x34, 0xdd, 0xa2, 0x57, 0x05, 0x5f, 0x1e, 0x13, 0x0c, 0xac, 0xce, 0xb9, 0xf7, 0xe7, 0x78, 0x4f,
	0xd2, 0x5c, 0x6b, 0xa1, 0x93, 0x2a, 0xe0, 0x70, 0x09, 0x28, 0x9a, 0x3c, 0x27, 0xc9, 0x65, 0x8e,
	0x62, 0x95, 0x9c, 0x1a, 0x9c, 0xda, 0xc8, 0x7b, 0x84, 0xbc, 0x15, 0xc5, 0xc3, 0x76, 0x0e, 0xe0,
	0x83, 0x12, 0xc0, 0xaf, 0x40, 0x3f, 0x14, 0x92, 0x3b, 0x27, 0xee, 0x7e, 0x4a, 0x81, 0xda, 0xe0,
	0x25, 0x43, 0xf7, 0x1e, 0x88, 0x50, 0xee, 0xa7, 0x14, 0xa3, 0xaa, 0x57, 0x31, 0x10, 0xda, 0xb4,
	0xe8, 0xed, 0x58, 0x85, 0x65, 0x83, 0x57, 0x38, 0xba, 0x1f, 0x85, 0xb1, 0xff, 0x62, 0xd1, 0xaf,
	0x39, 0xb8, 0x1e, 0xc4, 0xe3, 0x7d, 0x47, 0x52, 0xd0, 0x35, 0x78, 0x4e, 0xe2, 0xbc, 0x29, 0x95,
	0xd0, 0xd8, 0x77, 0x49, 0xcd, 0x5b, 0x30, 0xf0, 0x08, 0xa9, 0xec, 0xc2, 0xce, 0x35, 0x75, 0x84,
	0x39, 0x8d, 0xce, 0x1f, 0x88, 0x80, 0xa7, 0xa9, 0xf9, 0x0c, 0x9d, 0x9e, 0xa6, 0x50, 0x27, 0x10,
	0xc1, 0x8e, 0xed, 0x1c, 0x0b, 0xf3, 0x32, 0xf5, 0x14, 0x74, 0x91, 0xb2, 0x9e, 0x3d, 0xc7, 0x5d,
	0x2e, 0x95, 0x76, 0x82, 0x07, 0x61, 0xaa, 0x83, 0xd0, 0x64, 0x15, 0x47, 0x9e, 0xab, 0xe3, 0x48,
	0x8e, 0x0d, 0xeb, 0x15, 0x6c, 0xf8, 0xa6, 0x57, 0xc4, 0x1f, 0xe1, 0xa6, 0xce, 0xa6, 0x46, 0x99,
	0x4d, 0xeb, 0xd9, 0xa3, 0x31, 0x91, 0x3d, 0xca, 0x54, 0xd6, 0x7c, 0xca, 0x54, 0xd6, 0x3a, 0x7b,
	0x2a, 0xc3, 0x20, 0xf3, 0x9c, 0xfc, 0x8e, 0x41, 0x6d, 0x5c, 0xb0, 0x3c, 0x4e, 0x84, 0xed, 0xa6,
	0x3a, 0x82, 0x73, 0x72, 0x3c, 0x31, 0xf5, 0x26, 0x13, 0x93, 0xf6, 0xc6, 0x7e, 0xe9, 0x8d, 0x63,
	0x89, 0x03, 0x26, 0x13, 0xc7, 0xbd, 0xb1, 0x0b, 0xa0, 0x20, 0x9f, 0x3f, 0x73, 0x24, 0x8e, 0x29,
	0xb3, 0x0f, 0x60, 0x25, 0xae, 0xe4, 0xbd, 0xf3, 0xa4, 0xc8, 0x9a, 0x62, 0x25, 0x53, 0x5e, 0x3a,
	0x4f, 0xa6, 0xdc, 0x87, 0x0b, 0x4e, 0x3d, 0xda, 0x29, 0xcc, 0xce, 0x8e, 0x0d, 0xe3, 0xea, 0x58,
	0xf1, 0x15, 0x2c, 0x7e, 0x54, 0xc4, 0x65, 0x9d, 0x59, 0x93, 0xfa, 0xf4, 0xa8, 0x88, 0xce, 0x3a,
	0x73, 0x22, 0x4b, 0xb3, 0x29, 0x59, 0xfa, 0x2a, 0xb0, 0x82, 0xbe, 0x5f, 0x20, 0x89, 0x0a, 0xcb,
	0x29, 0x3d, 0xe3, 0xf2, 0x1a, 0x5b, 0x9e, 0x99, 0x94, 0xd7, 0x20, 0xf3, 0x1a, 0x5c, 0x1a, 0x1f,
	0x05, 0xd1, 0xe4, 0x32, 0x29, 0x4c, 0xeb, 0x1a, 0xd7, 0xc8, 0xf1, 0xe7, 0xd9, 0x49, 0x8d, 0x1c,
	0x88, 0x66, 0x55, 0x1a, 0xe6, 0x53, 0x55, 0x1a, 0xcf, 0x9d, 0xb5, 0xd2, 0x58, 0x5f, 0x5c, 0x69,
	0x3c, 0xbf, 0xa0, 0xd2, 0xb8, 0x52, 0x41, 0x93, 0xbf, 0xb4, 0x60, 0x50, 0x73, 0x77, 0x9d, 0x25,
	0x8d, 0x22, 0x4b, 0x56, 0x00, 0xb7, 0x31, 0x07, 0x70, 0x9b, 0xf3, 0x00, 0xb7, 0x35, 0x06, 0xb8,
	0xf3, 0xf2, 0x69, 0x09, 0xc6, 0x9d, 0x99, 0x60, 0xdc, 0x1d, 0x03, 0x63, 0xd5, 0xa7, 0xc6, 0xeb,
	0x15, 0x7d, 0x6a, 0xbc, 0x3c, 0xcd, 0xf5, 0xa7, 0xa4, 0x39, 0xa8, 0xa4, 0xb9, 0x5a, 0x52, 0x5b,
	0x9e, 0x9b, 0xd4, 0x56, 0xe6, 0x27, 0xb5, 0xc1, 0x82, 0xa4, 0xb6, 0x3a, 0x91, 0xd4, 0x8a, 0x0a,
	0xe1, 0xc2, 0x7f, 0x54, 0x21, 0x0c, 0x9f, 0xaa, 0x42, 0xd0, 0x88, 0x7a, 0xb1, 0x44, 0xd4, 0x4a,
	0xaa, 0x62, 0x33, 0x53, 0xd5, 0xa5, 0x9a, 0x23, 0x5a, 0x7f, 0x34, 0x00, 0xca, 0x17, 0x2c, 0xdc,
	0xe1, 0x2c, 0x2b, 0xfc, 0x88, 0xda, 0xec, 0x55, 0x68, 0x44, 0xf9, 0xcd, 0x7f, 0x16, 0xd4, 0x7d,
	0x74, 0x40, 0x0f, 0x60, 0x8d, 0x08, 0x03, 0xac, 0xe5, 0xa8, 0x27, 0x95, 0xe6, 0xfc, 0x64, 0xa3,
	0x9e, 0xcc, 0x9c, 0x29, 0xef, 0x2d, 0xed, 0x89, 0xf7, 0x16, 0xeb, 0x2b, 0x03, 0x3a, 0x6a, 0x92,
	0xa9, 0x95, 0xeb, 0x3a, 0xf4, 0x62, 0xdf, 0x96, 0x0f, 0xa2, 0x24, 0xc8, 0x1f, 0x4a, 0x72, 0x1a,
	0x3d, 0xf3, 0x81, 0x1d, 0x78, 0xfe, 0xa9, 0xae, 0x18, 0x35, 0x85, 0x9b, 0x72, 0x22, 0x92, 0xd4,
	0x8b, 0x42, 0x5d, 0x35, 0xe6, 0x24, 0x22, 0xe6, 0x43, 0x91, 0x84, 0xc2, 0xff, 0x44, 0xf7, 0xb7,
	0xa9, 0xbf, 0xce, 0x24, 0x93, 0x14, 0xc4, 0xe3, 0xf4, 0x98, 0x08, 0x39, 0xfa, 0x82, 0xa1, 0x02,
	0x23, 0xa7, 0xd1, 0x05, 0x1f, 0x25, 0x9e, 0x14, 0xd4, 0xa9, 0x42, 0xb1, 0x64, 0xe0, 0x54, 0x28,
	0x89, 0xb1, 0x9e, 0x92, 0x84, 0x0a, 0xc8, 0x3a, 0x93, 0xbd, 0x0c, 0xab, 0xa4, 0x52, 0x8a, 0xa9,
	0xd0, 0x1c, 0xe3, 0x5a, 0xd7, 0xa0, 0x7d, 0xd7, 0x3e, 0x12, 0x7e, 0xf5, 0xf6, 0xde, 0x57, 0xce,
	0xb1, 0x06, 0xed, 0x13, 0xdb, 0xcf, 0xf2, 0x77, 0x24, 0x45, 0x58, 0xef, 0xc1, 0x60, 0xd7, 0x4b,
	0x65, 0x34, 0x4a, 0xec, 0x60, 0x4f, 0x8a, 0x00, 0x57, 0xf2, 0x45, 0x66, 0x87, 0xd2, 0xf3, 0x8b,
	0x95, 0xe4, 0x74, 0x7d, 0x88, 0x46, 0x3e, 0xc4, 0x07, 0xd0, 0x2f, 0x86, 0x60, 0x6f, 0x43, 0xdb,
	0x93, 0x22, 0x50, 0xd7, 0x9e, 0xd9, 0xcf, 0x71, 0xb5, 0x39, 0xb9, 0x52, 0xb1, 0x7e, 0x0d, 0x1d,
	0xf5, 0x6c, 0xc2, 0x6e, 0x40, 0xc7, 0xc7, 0x65, 0xe4, 0xc3, 0x5c, 0x99, 0x31, 0x0c, 0xad, 0x95,
	0x6b, 0x59, 0xbc, 0x5d, 0x1f, 0xe7, 0xe3, 0x6a, 0x77, 0xdd, 0x5c, 0x34, 0x3f, 0x2f, 0x55, 0xac,
	0xdf, 0xb6, 0x01, 0xca, 0x4f, 0x00, 0x53, 0x0a, 0xb4, 0x9f, 0x40, 0xdb, 0xb7, 0x5d, 0x37, 0x7f,
	0x84, 0x98, 0x55, 0x3c, 0xbe, 0xe7, 0xba, 0x09, 0x57, 0x92, 0xa8, 0x92, 0x90, 0x4a, 0xe7, 0x0c,
	0x2a, 0x24, 0x89, 0x49, 0x13, 0x83, 0x33, 0x25, 0x8c, 0x12, 0xc9, 0x81, 0x70, 0xa2, 0xd0, 0x25,
	0x78, 0x6c, 0xf0, 0x29, 0x3d, 0x98, 0x9c, 0x88, 0xcb, 0x85, 0x23, 0xbc, 0x13, 0xe1, 0x96, 0x3a,
	0x0a, 0x3a, 0x67, 0xf4, 0xb2, 0x77, 0x8b, 0xb0, 0x00, 0xc2, 0x9f, 0x57, 0x16, 0x7e, 0x15, 0xb9,
	0x43, 0xe2, 0x45, 0xfc, 0xbc, 0xa5, 0xef, 0x6a, 0x0b, 0x8b, 0x32, 0xad, 0x7e, 0x78, 0x1a, 0x0b,
	0x7d, 0xa5, 0x7b, 0x09, 0x06, 0xb1, 0xe7, 0xee, 0x94, 0xd5, 0xee, 0x0a, 0x45, 0x7c, 0x9d, 0x49,
	0xe0, 0x6d, 0x07, 0x22, 0x8d, 0x6d, 0x47, 0x98, 0xd7, 0xc9, 0x6d, 0x4b, 0x06, 0xdb, 0x85, 0xbe,
	0xeb, 0x25, 0x6a, 0x68, 0xf3, 0x75, 0xb2, 0x61, 0x7b, 0xa1, 0x0d, 0xef, 0xe7, 0x1a, 0xbc, 0x54,
	0xc6, 0x92, 0xa0, 0xfc, 0xdc, 0xb3, 0xe7, 0x8a, 0x50, 0x7a, 0x0f, 0x3c, 0x91, 0x98, 0x37, 0x68,
	0xca, 0xa9, 0x7d, 0x98, 0xc0, 0x5d, 0x21, 0x85, 0x23, 0x85, 0xbb, 0x9f, 0x44, 0x32, 0x72, 0x22,
	0xdf, 0x7c, 0x83, 0xe4, 0x27, 0xf8, 0xec, 0xa7, 0xd0, 0x0d, 0xf4, 0x8b, 0xe2, 0x4d, 0xf2, 0xe7,
	0x17, 0x66, 0x56, 0xee, 0x28, 0xc5, 0x73, 0x69, 0xeb, 0x57, 0xd0, 0x42, 0xcf, 0x28, 0x2e, 0x2d,
	0xc6, 0x59, 0x2f, 0x2d, 0x58, 0x0c, 0xc4, 0xc5, 0x95, 0x39, 0xa6, 0xa7, 0x83, 0x28, 0x91, 0xfa,
	0x1e, 0x4f, 0x6d, 0xeb, 0x4f, 0x06, 0x40, 0x79, 0x55, 0x40, 0x77, 0x4f, 0xf4, 0x7b, 0x71, 0x8b,
	0x63, 0x13, 0x39, 0x27, 0x81, 0x02, 0xfe, 0x16, 0xc7, 0x26, 0xdd, 0xdf, 0x1f, 0xd9, 0x31, 0x0d,
	0xd3, 0xe2, 0xd4, 0x46, 0x74, 0x4d, 0x8f, 0xed, 0x44, 0xa8, 0x17, 0x81, 0x16, 0xd7, 0x14, 0x55,
	0x2d, 0xe2, 0xb1, 0xaa, 0x13, 0x5a, 0x9c, 0xda, 0x38, 0xa2, 0xef, 0x1d, 0xe9, 0x02, 0x01, 0x9b,
	0x28, 0x85, 0x8b, 0xd1, 0x95, 0x01, 0xb5, 0x11, 0x66, 0x5c, 0x2f, 0x91, 0xa7, 0xba, 0x24, 0x50,
	0x84, 0xf5, 0x87, 0x06, 0x74, 0xf5, 0x0d, 0x05, 0x91, 0xdb, 0xb7, 0x53, 0xb9, 0x13, 0x67, 0x1a,
	0xe1, 0x72, 0xb2, 0x56, 0xbd, 0x34, 0xc6, 0xaa, 0x97, 0x4a, 0x45, 0xd4, 0x9c, 0x53, 0x11, 0xb5,
	0xc6, 0x2b, 0x22, 0xac, 0x02, 0xb2, 0xe0, 0x50, 0xdf, 0x7c, 0xd4, 0x85, 0xa8, 0xc2, 0x61, 0x6f,
	0xea, 0x84, 0xd7, 0x99, 0x0b, 0x79, 0x07, 0x5e, 0x38, 0xf2, 0x45, 0x7e, 0xc7, 0x52, 0x69, 0x2f,
	0xbf, 0x64, 0x75, 0x2b, 0x97, 0xac, 0x75, 0xe8, 0xa1, 0x59, 0x14, 0x15, 0x3d, 0x8a, 0x8a, 0x82,
	0x46, 0x4b, 0x94, 0x59, 0xd5, 0xf7, 0xc5, 0x92, 0x63, 0xbd, 0x0b, 0x83, 0xda, 0x34, 0xb3, 0x52,
	0xe5, 0xac, 0x2d, 0xb2, 0x7e, 0x30, 0x68, 0x93, 0x29, 0xcd, 0x5e, 0x86, 0x4e, 0x98, 0x05, 0x47,
	0xfa, 0x7f, 0x11, 0x6d, 0xae, 0x29, 0xe4, 0x9f, 0x88, 0xd0, 0x8d, 0x12, 0xed, 0x5f, 0x9a, 0x9a,
	0x99, 0x66, 0xd7, 0xa0, 0x1d, 0x44, 0xae, 0xf0, 0xf3, 0xa7, 0x19, 0x22, 0x70, 0x29, 0xf1, 0xf1,
	0x69, 0xea, 0x39, 0xb6, 0xaf, 0xbf, 0xa1, 0xf4, 0x79, 0x85, 0x83, 0xa3, 0x39, 0x51, 0x22, 0xf4,
	0x67, 0x94, 0x3e, 0xd7, 0x14, 0x8e, 0x86, 0xad, 0xfc, 0x06, 0xaa, 0x08, 0x74, 0xac, 0xe0, 0xf8,
	0x4b, 0xbd, 0x5f, 0xd8, 0xc4, 0x23, 0x75, 0xb0, 0xc6, 0xa4, 0xaf, 0x2d, 0x7d, 0xf5, 0xb5, 0xa5,
	0x60, 0x58, 0xdf, 0x18, 0xd0, 0xda, 0xcd, 0x03, 0x25, 0xc7, 0x78, 0xac, 0x9a, 0x8b, 0xaf, 0x9f,
	0x8d, 0xea, 0xd7, 0xcf, 0x69, 0x2f, 0x4e, 0xaf, 0xeb, 0xaa, 0xbc, 0x45, 0xa7, 0xfe, 0x7f, 0x73,
	0x62, 0xf2, 0xd0, 0x1e, 0xa5, 0xaa, 0x6c, 0x47, 0x17, 0xb4, 0x7d, 0x1f, 0x19, 0xe4, 0x2d, 0x7d,
	0x9e, 0x93, 0xd5, 0x6f, 0x51, 0xdd, 0xb9, 0xdf, 0xa2, 0x7a, 0x93, 0xb5, 0xd1, 0x2d, 0xe8, 0xe5,
	0xf3, 0x90, 0x8b, 0x44, 0x59, 0xe2, 0x88, 0xc3, 0xfc, 0x19, 0x6d, 0xc0, 0x2b, 0x9c, 0xe2, 0x32,
	0xd1, 0x28, 0x2f, 0x13, 0xdb, 0x1e, 0xac, 0xd6, 0x4b, 0x54, 0xb6, 0x0c, 0xdd, 0x2c, 0x7c, 0x18,
	0x46, 0x8f, 0xc2, 0xe1, 0x12, 0x12, 0xfa, 0xed, 0x69, 0x68, 0xb0, 0x55, 0x80, 0x44, 0x50, 0x59,
	0xe9, 0x85, 0xa3, 0x61, 0x03, 0x3b, 0x93, 0x2c, 0x0c, 0x91, 0x68, 0x32, 0x80, 0x4e, 0x6c, 0x67,
	0xa9, 0x70, 0x87, 0x2d, 0x6c, 0x8b, 0xc7, 0x1e, 0x2a, 0xb5, 0x59, 0x0f, 0x5a, 0xae, 0xb0, 0xdd,
	0x61, 0x67, 0xfb, 0x3e, 0x5c, 0x18, 0xab, 0x67, 0xd9, 0x45, 0x18, 0xe8, 0xb9, 0x14, 0x63, 0xb8,
	0xc4, 0x56, 0xa0, 0x57, 0x4c, 0x61, 0xe0, 0x14, 0xaa, 0xe4, 0x3d, 0x1d, 0x36, 0xd8, 0x00, 0xfa,
	0x59, 0x98, 0x93, 0xcd, 0xed, 0x3b, 0xb0, 0x52, 0xbd, 0xa8, 0xb3, 0x36, 0x18, 0x1f, 0x0f, 0x97,
	0xf0, 0xe7, 0xfd, 0xa1, 0x81, 0x3f, 0x7c, 0xd8, 0xc0, 0x9f, 0x83, 0x61, 0x13, 0x7f, 0x0e, 0x87,
	0x2d, 0xfc, 0xf9, 0x74, 0xd8, 0xc6, 0x9f, 0x5f, 0x0e, 0x3b, 0xf8, 0xf3, 0xd9, 0xb0, 0xbb, 0x6d,
	0xd1, 0x16, 0x54, 0x12, 0x15, 0xeb, 0x42, 0x53, 0x3a, 0xf1, 0x70, 0x09, 0x1b, 0x99, 0x1b, 0x0f,
	0x8d, 0x6d, 0x0b, 0x86, 0xe3, 0xb9, 0x90, 0x75, 0xa0, 0x71, 0x72, 0x63, 0xb8, 0x44, 0xbf, 0x37,
	0x87, 0xc6, 0xf6, 0x3b, 0x70, 0x69, 0x4a, 0xb2, 0xc1, 0x0d, 0x08, 0xa3, 0x50, 0xa8, 0xa5, 0x45,
	0x99, 0x1c, 0x45, 0x6a, 0x69, 0x2b, 0xd0, 0xf3, 0x42, 0x27, 0x0a, 0x68, 0x2f, 0x6f, 0xdf, 0xff,
	0xeb, 0xf7, 0x1b, 0xc6, 0xb7, 0xdf, 0x6f, 0x18, 0xdf, 0x7d, 0xbf, 0x61, 0x7c, 0xf5, 0x64, 0x63,
	0xe9, 0xdb, 0x27, 0x1b, 0x4b, 0xff, 0x78, 0xb2, 0xb1, 0xf4, 0xd9, 0x8d, 0x73, 0xfe, 0xfd, 0x89,
	0x62, 0xec, 0xa8, 0x43, 0xff, 0x78, 0x7a, 0xfd, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xcc, 0x66,
	0xd2, 0xc3, 0x61, 0x25, 0x00, 0x00,
}

func (m *ResCollector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResCollector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResCollector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResCollector_Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResCollector_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResCollector_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	return len(dAtA) - i, nil
}

func (m *CollectorProc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorProc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorProc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Containers) > 0 {
		for iNdEx := len(m.Containers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Containers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.Ecs != nil {
		{
			size, err := m.Ecs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Kubernetes != nil {
		{
			size, err := m.Kubernetes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.GroupSize != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.GroupSize))
		i--
		dAtA[i] = 0x38
	}
	if m.GroupId != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x30
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Host != nil {
		{
			size, err := m.Host.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Processes) > 0 {
		for iNdEx := len(m.Processes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Processes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *CollectorCommands) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorCommands) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorCommands) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupSize != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.GroupSize))
		i--
		dAtA[i] = 0x38
	}
	if m.GroupId != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x30
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Host != nil {
		{
			size, err := m.Host.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Commands) > 0 {
		for iNdEx := len(m.Commands) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commands[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *CollectorConnections) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorConnections) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorConnections) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupSize != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.GroupSize))
		i--
		dAtA[i] = 0x30
	}
	if m.GroupId != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x28
	}
	if m.Host != nil {
		{
			size, err := m.Host.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Connections) > 0 {
		for iNdEx := len(m.Connections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Connections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *CollectorRealTime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorRealTime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorRealTime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContainerStats) > 0 {
		for iNdEx := len(m.ContainerStats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ContainerStats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.TotalMemory != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.TotalMemory))
		i--
		dAtA[i] = 0x48
	}
	if m.NumCpus != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.NumCpus))
		i--
		dAtA[i] = 0x40
	}
	if m.GroupSize != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.GroupSize))
		i--
		dAtA[i] = 0x38
	}
	if m.GroupId != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x30
	}
	if m.OrgId != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.OrgId))
		i--
		dAtA[i] = 0x28
	}
	if m.HostId != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.HostId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Stats) > 0 {
		for iNdEx := len(m.Stats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Stats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *CollectorContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorContainer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorContainer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Host != nil {
		{
			size, err := m.Host.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Ecs != nil {
		{
			size, err := m.Ecs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Kubernetes != nil {
		{
			size, err := m.Kubernetes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.GroupSize != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.GroupSize))
		i--
		dAtA[i] = 0x28
	}
	if m.GroupId != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Containers) > 0 {
		for iNdEx := len(m.Containers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Containers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectorContainerRealTime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorContainerRealTime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorContainerRealTime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupSize != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.GroupSize))
		i--
		dAtA[i] = 0x38
	}
	if m.GroupId != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x30
	}
	if m.HostId != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.HostId))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalMemory != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.TotalMemory))
		i--
		dAtA[i] = 0x20
	}
	if m.NumCpus != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.NumCpus))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Stats) > 0 {
		for iNdEx := len(m.Stats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Stats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectorReqStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorReqStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorReqStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *CollectorCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Command != nil {
		{
			size := m.Command.Size()
			i -= size
			if _, err := m.Command.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CollectorCommand_UpdateProcess) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorCommand_UpdateProcess) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateProcess != nil {
		{
			size, err := m.UpdateProcess.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CollectorCommand_UpdateProcessMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorCommand_UpdateProcessMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateProcessMetrics != nil {
		{
			size, err := m.UpdateProcessMetrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CollectorCommand_DeleteProcess) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorCommand_DeleteProcess) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeleteProcess != nil {
		{
			size, err := m.DeleteProcess.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CollectorCommand_UpdateContainer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorCommand_UpdateContainer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateContainer != nil {
		{
			size, err := m.UpdateContainer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *CollectorCommand_UpdateContainerMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorCommand_UpdateContainerMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateContainerMetrics != nil {
		{
			size, err := m.UpdateContainerMetrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *CollectorCommand_DeleteContainer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorCommand_DeleteContainer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeleteContainer != nil {
		{
			size, err := m.DeleteContainer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *CollectorStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Interval != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Interval))
		i--
		dAtA[i] = 0x10
	}
	if m.ActiveClients != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.ActiveClients))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Process) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Process) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Process) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintAgent(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.ContainerByteKey) > 0 {
		i -= len(m.ContainerByteKey)
		copy(dAtA[i:], m.ContainerByteKey)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.ContainerByteKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.ByteKey) > 0 {
		i -= len(m.ByteKey)
		copy(dAtA[i:], m.ByteKey)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.ByteKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.InvoluntaryCtxSwitches != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.InvoluntaryCtxSwitches))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.VoluntaryCtxSwitches != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.VoluntaryCtxSwitches))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.ContainerKey != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.ContainerKey))
		i--
		dAtA[i] = 0x78
	}
	if len(m.ContainerId) > 0 {
		i -= len(m.ContainerId)
		copy(dAtA[i:], m.ContainerId)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.ContainerId)))
		i--
		dAtA[i] = 0x72
	}
	if m.IoStat != nil {
		{
			size, err := m.IoStat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.State != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x60
	}
	if m.OpenFdCount != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.OpenFdCount))
		i--
		dAtA[i] = 0x58
	}
	if m.Container != nil {
		{
			size, err := m.Container.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.CreateTime != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x48
	}
	if m.Cpu != nil {
		{
			size, err := m.Cpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Memory != nil {
		{
			size, err := m.Memory.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Command != nil {
		{
			size, err := m.Command.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Host != nil {
		{
			size, err := m.Host.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Pid != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x10
	}
	if m.Key != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Command) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Command) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Command) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Exe) > 0 {
		i -= len(m.Exe)
		copy(dAtA[i:], m.Exe)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Exe)))
		i--
		dAtA[i] = 0x42
	}
	if m.Pgroup != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Pgroup))
		i--
		dAtA[i] = 0x38
	}
	if m.Ppid != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Ppid))
		i--
		dAtA[i] = 0x30
	}
	if m.OnDisk {
		i--
		if m.OnDisk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Cwd) > 0 {
		i -= len(m.Cwd)
		copy(dAtA[i:], m.Cwd)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Cwd)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintAgent(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProcessUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sgid != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Sgid))
		i--
		dAtA[i] = 0x38
	}
	if m.Suid != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Suid))
		i--
		dAtA[i] = 0x30
	}
	if m.Egid != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Egid))
		i--
		dAtA[i] = 0x28
	}
	if m.Euid != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Euid))
		i--
		dAtA[i] = 0x20
	}
	if m.Gid != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Gid))
		i--
		dAtA[i] = 0x18
	}
	if m.Uid != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Container) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Container) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Container) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintAgent(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.ByteKey) > 0 {
		i -= len(m.ByteKey)
		copy(dAtA[i:], m.ByteKey)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.ByteKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.Started != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Started))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.Host != nil {
		{
			size, err := m.Host.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.MemCache != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.MemCache))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.MemRss != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.MemRss))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.TotalPct != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TotalPct))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa5
	}
	if m.SystemPct != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SystemPct))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9d
	}
	if m.UserPct != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UserPct))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x95
	}
	if m.NetSentBps != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.NetSentBps))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8d
	}
	if m.NetRcvdBps != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.NetRcvdBps))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x85
	}
	if m.NetSentPs != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.NetSentPs))))
		i--
		dAtA[i] = 0x7d
	}
	if m.NetRcvdPs != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.NetRcvdPs))))
		i--
		dAtA[i] = 0x75
	}
	if m.Key != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x68
	}
	if m.Wbps != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Wbps))))
		i--
		dAtA[i] = 0x65
	}
	if m.Rbps != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rbps))))
		i--
		dAtA[i] = 0x5d
	}
	if m.Created != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Created))
		i--
		dAtA[i] = 0x50
	}
	if m.Health != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Health))
		i--
		dAtA[i] = 0x48
	}
	if m.State != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x40
	}
	if m.MemoryLimit != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.MemoryLimit))
		i--
		dAtA[i] = 0x30
	}
	if m.CpuLimit != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CpuLimit))))
		i--
		dAtA[i] = 0x2d
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProcessStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintAgent(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.ContainerByteKey) > 0 {
		i -= len(m.ContainerByteKey)
		copy(dAtA[i:], m.ContainerByteKey)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.ContainerByteKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.ByteKey) > 0 {
		i -= len(m.ByteKey)
		copy(dAtA[i:], m.ByteKey)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.ByteKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.InvoluntaryCtxSwitches != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.InvoluntaryCtxSwitches))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.VoluntaryCtxSwitches != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.VoluntaryCtxSwitches))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.ContainerNetSentBps != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ContainerNetSentBps))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xbd
	}
	if m.ContainerNetRcvdBps != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ContainerNetRcvdBps))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb5
	}
	if m.ContainerNetSentPs != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ContainerNetSentPs))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xad
	}
	if m.ContainerNetRcvdPs != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ContainerNetRcvdPs))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa5
	}
	if m.IoStat != nil {
		{
			size, err := m.IoStat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.ContainerKey != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.ContainerKey))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ContainerWbps != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ContainerWbps))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8d
	}
	if m.ContainerRbps != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ContainerRbps))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x85
	}
	if m.ContainerHealth != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.ContainerHealth))
		i--
		dAtA[i] = 0x78
	}
	if m.ProcessState != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.ProcessState))
		i--
		dAtA[i] = 0x60
	}
	if m.ContainerState != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.ContainerState))
		i--
		dAtA[i] = 0x58
	}
	if len(m.ContainerId) > 0 {
		i -= len(m.ContainerId)
		copy(dAtA[i:], m.ContainerId)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.ContainerId)))
		i--
		dAtA[i] = 0x52
	}
	if m.Key != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x48
	}
	if m.OpenFdCount != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.OpenFdCount))
		i--
		dAtA[i] = 0x40
	}
	if m.Threads != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Threads))
		i--
		dAtA[i] = 0x38
	}
	if m.Nice != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Nice))
		i--
		dAtA[i] = 0x28
	}
	if m.Cpu != nil {
		{
			size, err := m.Cpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Memory != nil {
		{
			size, err := m.Memory.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CreateTime != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x10
	}
	if m.Pid != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContainerStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ByteKey) > 0 {
		i -= len(m.ByteKey)
		copy(dAtA[i:], m.ByteKey)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.ByteKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Started != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Started))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Key != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Health != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Health))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.State != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x78
	}
	if m.NetSentBps != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.NetSentBps))))
		i--
		dAtA[i] = 0x75
	}
	if m.NetRcvdBps != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.NetRcvdBps))))
		i--
		dAtA[i] = 0x6d
	}
	if m.NetSentPs != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.NetSentPs))))
		i--
		dAtA[i] = 0x65
	}
	if m.NetRcvdPs != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.NetRcvdPs))))
		i--
		dAtA[i] = 0x5d
	}
	if m.Wbps != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Wbps))))
		i--
		dAtA[i] = 0x55
	}
	if m.Rbps != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rbps))))
		i--
		dAtA[i] = 0x4d
	}
	if m.MemLimit != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.MemLimit))
		i--
		dAtA[i] = 0x40
	}
	if m.MemCache != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.MemCache))
		i--
		dAtA[i] = 0x38
	}
	if m.MemRss != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.MemRss))
		i--
		dAtA[i] = 0x30
	}
	if m.CpuLimit != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CpuLimit))))
		i--
		dAtA[i] = 0x2d
	}
	if m.TotalPct != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TotalPct))))
		i--
		dAtA[i] = 0x25
	}
	if m.SystemPct != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SystemPct))))
		i--
		dAtA[i] = 0x1d
	}
	if m.UserPct != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UserPct))))
		i--
		dAtA[i] = 0x15
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SystemInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalMemory != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.TotalMemory))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Cpus) > 0 {
		for iNdEx := len(m.Cpus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cpus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Os != nil {
		{
			size, err := m.Os.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OSInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OSInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KernelVersion) > 0 {
		i -= len(m.KernelVersion)
		copy(dAtA[i:], m.KernelVersion)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.KernelVersion)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Family) > 0 {
		i -= len(m.Family)
		copy(dAtA[i:], m.Family)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Family)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Platform) > 0 {
		i -= len(m.Platform)
		copy(dAtA[i:], m.Platform)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Platform)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IOStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IOStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IOStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WriteBytesRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WriteBytesRate))))
		i--
		dAtA[i] = 0x25
	}
	if m.ReadBytesRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ReadBytesRate))))
		i--
		dAtA[i] = 0x1d
	}
	if m.WriteRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WriteRate))))
		i--
		dAtA[i] = 0x15
	}
	if m.ReadRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ReadRate))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *Label) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Label) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Label) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HistogramItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistogramItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HistogramItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Value))))
		i--
		dAtA[i] = 0x15
	}
	if m.Quantile != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Quantile))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *Histogram) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Histogram) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Histogram) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Metric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Histogram != nil {
		{
			size, err := m.Histogram.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Connection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Connection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Connection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metrics) > 0 {
		for iNdEx := len(m.Metrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.DetectedProtocol) > 0 {
		i -= len(m.DetectedProtocol)
		copy(dAtA[i:], m.DetectedProtocol)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.DetectedProtocol)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	if len(m.ConnectionIdentifier) > 0 {
		i -= len(m.ConnectionIdentifier)
		copy(dAtA[i:], m.ConnectionIdentifier)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.ConnectionIdentifier)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	if m.Direction != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.PidCreateTime != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.PidCreateTime))
		i--
		dAtA[i] = 0x60
	}
	if m.Type != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x58
	}
	if m.Family != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Family))
		i--
		dAtA[i] = 0x50
	}
	if m.BytesReceivedPerSecond != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BytesReceivedPerSecond))))
		i--
		dAtA[i] = 0x4d
	}
	if m.BytesSentPerSecond != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BytesSentPerSecond))))
		i--
		dAtA[i] = 0x45
	}
	if m.Raddr != nil {
		{
			size, err := m.Raddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Laddr != nil {
		{
			size, err := m.Laddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Pid != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Addr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Addr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Addr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x12
	}
	if m.Host != nil {
		{
			size, err := m.Host.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoryStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Dirty != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Dirty))
		i--
		dAtA[i] = 0x40
	}
	if m.Data != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Data))
		i--
		dAtA[i] = 0x38
	}
	if m.Lib != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Lib))
		i--
		dAtA[i] = 0x30
	}
	if m.Text != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Text))
		i--
		dAtA[i] = 0x28
	}
	if m.Shared != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Shared))
		i--
		dAtA[i] = 0x20
	}
	if m.Swap != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Swap))
		i--
		dAtA[i] = 0x18
	}
	if m.Vms != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Vms))
		i--
		dAtA[i] = 0x10
	}
	if m.Rss != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Rss))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CPUStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPUStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CPUStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SystemTime != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.SystemTime))
		i--
		dAtA[i] = 0x48
	}
	if m.UserTime != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.UserTime))
		i--
		dAtA[i] = 0x40
	}
	if m.Nice != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Nice))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Cpus) > 0 {
		for iNdEx := len(m.Cpus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cpus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.NumThreads != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.NumThreads))
		i--
		dAtA[i] = 0x28
	}
	if m.SystemPct != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SystemPct))))
		i--
		dAtA[i] = 0x25
	}
	if m.UserPct != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UserPct))))
		i--
		dAtA[i] = 0x1d
	}
	if m.TotalPct != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TotalPct))))
		i--
		dAtA[i] = 0x15
	}
	if len(m.LastCpu) > 0 {
		i -= len(m.LastCpu)
		copy(dAtA[i:], m.LastCpu)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.LastCpu)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SingleCPUStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SingleCPUStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SingleCPUStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalPct != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TotalPct))))
		i--
		dAtA[i] = 0x15
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CPUInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPUInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CPUInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CacheSize != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.CacheSize))
		i--
		dAtA[i] = 0x48
	}
	if m.Mhz != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Mhz))
		i--
		dAtA[i] = 0x40
	}
	if m.Cores != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Cores))
		i--
		dAtA[i] = 0x38
	}
	if len(m.CoreId) > 0 {
		i -= len(m.CoreId)
		copy(dAtA[i:], m.CoreId)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.CoreId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PhysicalId) > 0 {
		i -= len(m.PhysicalId)
		copy(dAtA[i:], m.PhysicalId)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.PhysicalId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Family) > 0 {
		i -= len(m.Family)
		copy(dAtA[i:], m.Family)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Family)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Vendor) > 0 {
		i -= len(m.Vendor)
		copy(dAtA[i:], m.Vendor)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Vendor)))
		i--
		dAtA[i] = 0x12
	}
	if m.Number != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Host) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Host) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Host) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalMemory != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.TotalMemory))
		i--
		dAtA[i] = 0x40
	}
	if m.NumCpus != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.NumCpus))
		i--
		dAtA[i] = 0x38
	}
	if len(m.AllTags) > 0 {
		for iNdEx := len(m.AllTags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllTags[iNdEx])
			copy(dAtA[i:], m.AllTags[iNdEx])
			i = encodeVarintAgent(dAtA, i, uint64(len(m.AllTags[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OrgId != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.OrgId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HostTags) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostTags) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostTags) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintAgent(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.SourceType != 0 {
		i = encodeVarintAgent(dAtA, i, uint64(m.SourceType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintAgent(dAtA []byte, offset int, v uint64) int {
	offset -= sovAgent(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ResCollector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ResCollector_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAgent(uint64(m.Type))
	}
	return n
}

func (m *CollectorProc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Processes) > 0 {
		for _, e := range m.Processes {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if m.Kubernetes != nil {
		l = m.Kubernetes.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Ecs != nil {
		l = m.Ecs.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Containers) > 0 {
		for _, e := range m.Containers {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorCommands) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Commands) > 0 {
		for _, e := range m.Commands {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	return n
}

func (m *CollectorConnections) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Connections) > 0 {
		for _, e := range m.Connections {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	return n
}

func (m *CollectorRealTime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.HostId != 0 {
		n += 1 + sovAgent(uint64(m.HostId))
	}
	if m.OrgId != 0 {
		n += 1 + sovAgent(uint64(m.OrgId))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if m.NumCpus != 0 {
		n += 1 + sovAgent(uint64(m.NumCpus))
	}
	if m.TotalMemory != 0 {
		n += 1 + sovAgent(uint64(m.TotalMemory))
	}
	if len(m.ContainerStats) > 0 {
		for _, e := range m.ContainerStats {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Containers) > 0 {
		for _, e := range m.Containers {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if m.Kubernetes != nil {
		l = m.Kubernetes.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Ecs != nil {
		l = m.Ecs.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *CollectorContainerRealTime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.NumCpus != 0 {
		n += 1 + sovAgent(uint64(m.NumCpus))
	}
	if m.TotalMemory != 0 {
		n += 1 + sovAgent(uint64(m.TotalMemory))
	}
	if m.HostId != 0 {
		n += 1 + sovAgent(uint64(m.HostId))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	return n
}

func (m *CollectorReqStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *CollectorCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Command != nil {
		n += m.Command.Size()
	}
	return n
}

func (m *CollectorCommand_UpdateProcess) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateProcess != nil {
		l = m.UpdateProcess.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}
func (m *CollectorCommand_UpdateProcessMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateProcessMetrics != nil {
		l = m.UpdateProcessMetrics.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}
func (m *CollectorCommand_DeleteProcess) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteProcess != nil {
		l = m.DeleteProcess.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}
func (m *CollectorCommand_UpdateContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateContainer != nil {
		l = m.UpdateContainer.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}
func (m *CollectorCommand_UpdateContainerMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateContainerMetrics != nil {
		l = m.UpdateContainerMetrics.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}
func (m *CollectorCommand_DeleteContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteContainer != nil {
		l = m.DeleteContainer.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}
func (m *CollectorStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActiveClients != 0 {
		n += 1 + sovAgent(uint64(m.ActiveClients))
	}
	if m.Interval != 0 {
		n += 1 + sovAgent(uint64(m.Interval))
	}
	return n
}

func (m *Process) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovAgent(uint64(m.Key))
	}
	if m.Pid != 0 {
		n += 1 + sovAgent(uint64(m.Pid))
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.CreateTime != 0 {
		n += 1 + sovAgent(uint64(m.CreateTime))
	}
	if m.Container != nil {
		l = m.Container.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.OpenFdCount != 0 {
		n += 1 + sovAgent(uint64(m.OpenFdCount))
	}
	if m.State != 0 {
		n += 1 + sovAgent(uint64(m.State))
	}
	if m.IoStat != nil {
		l = m.IoStat.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.ContainerKey != 0 {
		n += 1 + sovAgent(uint64(m.ContainerKey))
	}
	if m.VoluntaryCtxSwitches != 0 {
		n += 2 + sovAgent(uint64(m.VoluntaryCtxSwitches))
	}
	if m.InvoluntaryCtxSwitches != 0 {
		n += 2 + sovAgent(uint64(m.InvoluntaryCtxSwitches))
	}
	l = len(m.ByteKey)
	if l > 0 {
		n += 2 + l + sovAgent(uint64(l))
	}
	l = len(m.ContainerByteKey)
	if l > 0 {
		n += 2 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 2 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *Command) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.Cwd)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.OnDisk {
		n += 2
	}
	if m.Ppid != 0 {
		n += 1 + sovAgent(uint64(m.Ppid))
	}
	if m.Pgroup != 0 {
		n += 1 + sovAgent(uint64(m.Pgroup))
	}
	l = len(m.Exe)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ProcessUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovAgent(uint64(m.Uid))
	}
	if m.Gid != 0 {
		n += 1 + sovAgent(uint64(m.Gid))
	}
	if m.Euid != 0 {
		n += 1 + sovAgent(uint64(m.Euid))
	}
	if m.Egid != 0 {
		n += 1 + sovAgent(uint64(m.Egid))
	}
	if m.Suid != 0 {
		n += 1 + sovAgent(uint64(m.Suid))
	}
	if m.Sgid != 0 {
		n += 1 + sovAgent(uint64(m.Sgid))
	}
	return n
}

func (m *Container) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.CpuLimit != 0 {
		n += 5
	}
	if m.MemoryLimit != 0 {
		n += 1 + sovAgent(uint64(m.MemoryLimit))
	}
	if m.State != 0 {
		n += 1 + sovAgent(uint64(m.State))
	}
	if m.Health != 0 {
		n += 1 + sovAgent(uint64(m.Health))
	}
	if m.Created != 0 {
		n += 1 + sovAgent(uint64(m.Created))
	}
	if m.Rbps != 0 {
		n += 5
	}
	if m.Wbps != 0 {
		n += 5
	}
	if m.Key != 0 {
		n += 1 + sovAgent(uint64(m.Key))
	}
	if m.NetRcvdPs != 0 {
		n += 5
	}
	if m.NetSentPs != 0 {
		n += 5
	}
	if m.NetRcvdBps != 0 {
		n += 6
	}
	if m.NetSentBps != 0 {
		n += 6
	}
	if m.UserPct != 0 {
		n += 6
	}
	if m.SystemPct != 0 {
		n += 6
	}
	if m.TotalPct != 0 {
		n += 6
	}
	if m.MemRss != 0 {
		n += 2 + sovAgent(uint64(m.MemRss))
	}
	if m.MemCache != 0 {
		n += 2 + sovAgent(uint64(m.MemCache))
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 2 + l + sovAgent(uint64(l))
	}
	if m.Started != 0 {
		n += 2 + sovAgent(uint64(m.Started))
	}
	l = len(m.ByteKey)
	if l > 0 {
		n += 2 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 2 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *ProcessStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pid != 0 {
		n += 1 + sovAgent(uint64(m.Pid))
	}
	if m.CreateTime != 0 {
		n += 1 + sovAgent(uint64(m.CreateTime))
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Nice != 0 {
		n += 1 + sovAgent(uint64(m.Nice))
	}
	if m.Threads != 0 {
		n += 1 + sovAgent(uint64(m.Threads))
	}
	if m.OpenFdCount != 0 {
		n += 1 + sovAgent(uint64(m.OpenFdCount))
	}
	if m.Key != 0 {
		n += 1 + sovAgent(uint64(m.Key))
	}
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.ContainerState != 0 {
		n += 1 + sovAgent(uint64(m.ContainerState))
	}
	if m.ProcessState != 0 {
		n += 1 + sovAgent(uint64(m.ProcessState))
	}
	if m.ContainerHealth != 0 {
		n += 1 + sovAgent(uint64(m.ContainerHealth))
	}
	if m.ContainerRbps != 0 {
		n += 6
	}
	if m.ContainerWbps != 0 {
		n += 6
	}
	if m.ContainerKey != 0 {
		n += 2 + sovAgent(uint64(m.ContainerKey))
	}
	if m.IoStat != nil {
		l = m.IoStat.Size()
		n += 2 + l + sovAgent(uint64(l))
	}
	if m.ContainerNetRcvdPs != 0 {
		n += 6
	}
	if m.ContainerNetSentPs != 0 {
		n += 6
	}
	if m.ContainerNetRcvdBps != 0 {
		n += 6
	}
	if m.ContainerNetSentBps != 0 {
		n += 6
	}
	if m.VoluntaryCtxSwitches != 0 {
		n += 2 + sovAgent(uint64(m.VoluntaryCtxSwitches))
	}
	if m.InvoluntaryCtxSwitches != 0 {
		n += 2 + sovAgent(uint64(m.InvoluntaryCtxSwitches))
	}
	l = len(m.ByteKey)
	if l > 0 {
		n += 2 + l + sovAgent(uint64(l))
	}
	l = len(m.ContainerByteKey)
	if l > 0 {
		n += 2 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 2 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *ContainerStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.UserPct != 0 {
		n += 5
	}
	if m.SystemPct != 0 {
		n += 5
	}
	if m.TotalPct != 0 {
		n += 5
	}
	if m.CpuLimit != 0 {
		n += 5
	}
	if m.MemRss != 0 {
		n += 1 + sovAgent(uint64(m.MemRss))
	}
	if m.MemCache != 0 {
		n += 1 + sovAgent(uint64(m.MemCache))
	}
	if m.MemLimit != 0 {
		n += 1 + sovAgent(uint64(m.MemLimit))
	}
	if m.Rbps != 0 {
		n += 5
	}
	if m.Wbps != 0 {
		n += 5
	}
	if m.NetRcvdPs != 0 {
		n += 5
	}
	if m.NetSentPs != 0 {
		n += 5
	}
	if m.NetRcvdBps != 0 {
		n += 5
	}
	if m.NetSentBps != 0 {
		n += 5
	}
	if m.State != 0 {
		n += 1 + sovAgent(uint64(m.State))
	}
	if m.Health != 0 {
		n += 2 + sovAgent(uint64(m.Health))
	}
	if m.Key != 0 {
		n += 2 + sovAgent(uint64(m.Key))
	}
	if m.Started != 0 {
		n += 2 + sovAgent(uint64(m.Started))
	}
	l = len(m.ByteKey)
	if l > 0 {
		n += 2 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *SystemInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Os != nil {
		l = m.Os.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Cpus) > 0 {
		for _, e := range m.Cpus {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.TotalMemory != 0 {
		n += 1 + sovAgent(uint64(m.TotalMemory))
	}
	return n
}

func (m *OSInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Family)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.KernelVersion)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *IOStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReadRate != 0 {
		n += 5
	}
	if m.WriteRate != 0 {
		n += 5
	}
	if m.ReadBytesRate != 0 {
		n += 5
	}
	if m.WriteBytesRate != 0 {
		n += 5
	}
	return n
}

func (m *Label) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *HistogramItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Quantile != 0 {
		n += 5
	}
	if m.Value != 0 {
		n += 5
	}
	return n
}

func (m *Histogram) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *Metric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Histogram != nil {
		l = m.Histogram.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *Connection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pid != 0 {
		n += 1 + sovAgent(uint64(m.Pid))
	}
	if m.Laddr != nil {
		l = m.Laddr.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Raddr != nil {
		l = m.Raddr.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.BytesSentPerSecond != 0 {
		n += 5
	}
	if m.BytesReceivedPerSecond != 0 {
		n += 5
	}
	if m.Family != 0 {
		n += 1 + sovAgent(uint64(m.Family))
	}
	if m.Type != 0 {
		n += 1 + sovAgent(uint64(m.Type))
	}
	if m.PidCreateTime != 0 {
		n += 1 + sovAgent(uint64(m.PidCreateTime))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 2 + l + sovAgent(uint64(l))
	}
	if m.Direction != 0 {
		n += 2 + sovAgent(uint64(m.Direction))
	}
	l = len(m.ConnectionIdentifier)
	if l > 0 {
		n += 2 + l + sovAgent(uint64(l))
	}
	l = len(m.DetectedProtocol)
	if l > 0 {
		n += 2 + l + sovAgent(uint64(l))
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 2 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *Addr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovAgent(uint64(m.Port))
	}
	return n
}

func (m *MemoryStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rss != 0 {
		n += 1 + sovAgent(uint64(m.Rss))
	}
	if m.Vms != 0 {
		n += 1 + sovAgent(uint64(m.Vms))
	}
	if m.Swap != 0 {
		n += 1 + sovAgent(uint64(m.Swap))
	}
	if m.Shared != 0 {
		n += 1 + sovAgent(uint64(m.Shared))
	}
	if m.Text != 0 {
		n += 1 + sovAgent(uint64(m.Text))
	}
	if m.Lib != 0 {
		n += 1 + sovAgent(uint64(m.Lib))
	}
	if m.Data != 0 {
		n += 1 + sovAgent(uint64(m.Data))
	}
	if m.Dirty != 0 {
		n += 1 + sovAgent(uint64(m.Dirty))
	}
	return n
}

func (m *CPUStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LastCpu)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.TotalPct != 0 {
		n += 5
	}
	if m.UserPct != 0 {
		n += 5
	}
	if m.SystemPct != 0 {
		n += 5
	}
	if m.NumThreads != 0 {
		n += 1 + sovAgent(uint64(m.NumThreads))
	}
	if len(m.Cpus) > 0 {
		for _, e := range m.Cpus {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Nice != 0 {
		n += 1 + sovAgent(uint64(m.Nice))
	}
	if m.UserTime != 0 {
		n += 1 + sovAgent(uint64(m.UserTime))
	}
	if m.SystemTime != 0 {
		n += 1 + sovAgent(uint64(m.SystemTime))
	}
	return n
}

func (m *SingleCPUStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.TotalPct != 0 {
		n += 5
	}
	return n
}

func (m *CPUInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovAgent(uint64(m.Number))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Family)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.PhysicalId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.CoreId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Cores != 0 {
		n += 1 + sovAgent(uint64(m.Cores))
	}
	if m.Mhz != 0 {
		n += 1 + sovAgent(uint64(m.Mhz))
	}
	if m.CacheSize != 0 {
		n += 1 + sovAgent(uint64(m.CacheSize))
	}
	return n
}

func (m *Host) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAgent(uint64(m.Id))
	}
	if m.OrgId != 0 {
		n += 1 + sovAgent(uint64(m.OrgId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.AllTags) > 0 {
		for _, s := range m.AllTags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.NumCpus != 0 {
		n += 1 + sovAgent(uint64(m.NumCpus))
	}
	if m.TotalMemory != 0 {
		n += 1 + sovAgent(uint64(m.TotalMemory))
	}
	return n
}

func (m *HostTags) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SourceType != 0 {
		n += 1 + sovAgent(uint64(m.SourceType))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func sovAgent(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAgent(x uint64) (n int) {
	return sovAgent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ResCollector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResCollector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResCollector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResCollector_Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &CollectorStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResCollector_Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorProc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorProc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorProc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Processes = append(m.Processes, &Process{})
			if err := m.Processes[len(m.Processes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &SystemInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kubernetes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kubernetes == nil {
				m.Kubernetes = &KubeMetadataPayload{}
			}
			if err := m.Kubernetes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecs == nil {
				m.Ecs = &ECSMetadataPayload{}
			}
			if err := m.Ecs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, &Container{})
			if err := m.Containers[len(m.Containers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorCommands) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorCommands: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorCommands: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commands = append(m.Commands, &CollectorCommand{})
			if err := m.Commands[len(m.Commands)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &SystemInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorConnections) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorConnections: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorConnections: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Connections = append(m.Connections, &Connection{})
			if err := m.Connections[len(m.Connections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorRealTime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorRealTime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorRealTime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, &ProcessStat{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostId", wireType)
			}
			m.HostId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			m.OrgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCpus", wireType)
			}
			m.NumCpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCpus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemory", wireType)
			}
			m.TotalMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMemory |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerStats = append(m.ContainerStats, &ContainerStat{})
			if err := m.ContainerStats[len(m.ContainerStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorContainer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &SystemInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, &Container{})
			if err := m.Containers[len(m.Containers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kubernetes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kubernetes == nil {
				m.Kubernetes = &KubeMetadataPayload{}
			}
			if err := m.Kubernetes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecs == nil {
				m.Ecs = &ECSMetadataPayload{}
			}
			if err := m.Ecs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorContainerRealTime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorContainerRealTime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorContainerRealTime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, &ContainerStat{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCpus", wireType)
			}
			m.NumCpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCpus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemory", wireType)
			}
			m.TotalMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMemory |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostId", wireType)
			}
			m.HostId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorReqStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorReqStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorReqStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateProcess", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Process{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Command = &CollectorCommand_UpdateProcess{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateProcessMetrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Process{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Command = &CollectorCommand_UpdateProcessMetrics{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteProcess", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Process{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Command = &CollectorCommand_DeleteProcess{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateContainer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Container{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Command = &CollectorCommand_UpdateContainer{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateContainerMetrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Container{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Command = &CollectorCommand_UpdateContainerMetrics{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteContainer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Container{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Command = &CollectorCommand_DeleteContainer{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveClients", wireType)
			}
			m.ActiveClients = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveClients |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Process) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Process: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Process: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &Command{}
			}
			if err := m.Command.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &ProcessUser{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &MemoryStat{}
			}
			if err := m.Memory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CPUStat{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &Container{}
			}
			if err := m.Container.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenFdCount", wireType)
			}
			m.OpenFdCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenFdCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ProcessState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IoStat == nil {
				m.IoStat = &IOStat{}
			}
			if err := m.IoStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerKey", wireType)
			}
			m.ContainerKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerKey |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoluntaryCtxSwitches", wireType)
			}
			m.VoluntaryCtxSwitches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoluntaryCtxSwitches |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoluntaryCtxSwitches", wireType)
			}
			m.InvoluntaryCtxSwitches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvoluntaryCtxSwitches |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByteKey = append(m.ByteKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ByteKey == nil {
				m.ByteKey = []byte{}
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerByteKey = append(m.ContainerByteKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ContainerByteKey == nil {
				m.ContainerByteKey = []byte{}
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Command) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cwd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cwd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDisk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnDisk = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ppid", wireType)
			}
			m.Ppid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ppid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pgroup", wireType)
			}
			m.Pgroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pgroup |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exe", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exe = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Euid", wireType)
			}
			m.Euid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Euid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egid", wireType)
			}
			m.Egid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Egid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suid", wireType)
			}
			m.Suid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Suid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sgid", wireType)
			}
			m.Sgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sgid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Container) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Container: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Container: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuLimit", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CpuLimit = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryLimit", wireType)
			}
			m.MemoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ContainerState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			m.Health = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Health |= ContainerHealth(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rbps = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Wbps = float32(math.Float32frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRcvdPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.NetRcvdPs = float32(math.Float32frombits(v))
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetSentPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.NetSentPs = float32(math.Float32frombits(v))
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRcvdBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.NetRcvdBps = float32(math.Float32frombits(v))
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetSentBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.NetSentBps = float32(math.Float32frombits(v))
		case 18:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UserPct = float32(math.Float32frombits(v))
		case 19:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SystemPct = float32(math.Float32frombits(v))
		case 20:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.TotalPct = float32(math.Float32frombits(v))
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemRss", wireType)
			}
			m.MemRss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemRss |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemCache", wireType)
			}
			m.MemCache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemCache |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			m.Started = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Started |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByteKey = append(m.ByteKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ByteKey == nil {
				m.ByteKey = []byte{}
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &MemoryStat{}
			}
			if err := m.Memory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CPUStat{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nice", wireType)
			}
			m.Nice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nice |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threads", wireType)
			}
			m.Threads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threads |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenFdCount", wireType)
			}
			m.OpenFdCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenFdCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerState", wireType)
			}
			m.ContainerState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerState |= ContainerState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessState", wireType)
			}
			m.ProcessState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessState |= ProcessState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHealth", wireType)
			}
			m.ContainerHealth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerHealth |= ContainerHealth(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerRbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ContainerRbps = float32(math.Float32frombits(v))
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerWbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ContainerWbps = float32(math.Float32frombits(v))
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerKey", wireType)
			}
			m.ContainerKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerKey |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IoStat == nil {
				m.IoStat = &IOStat{}
			}
			if err := m.IoStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerNetRcvdPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ContainerNetRcvdPs = float32(math.Float32frombits(v))
		case 21:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerNetSentPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ContainerNetSentPs = float32(math.Float32frombits(v))
		case 22:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerNetRcvdBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ContainerNetRcvdBps = float32(math.Float32frombits(v))
		case 23:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerNetSentBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ContainerNetSentBps = float32(math.Float32frombits(v))
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoluntaryCtxSwitches", wireType)
			}
			m.VoluntaryCtxSwitches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoluntaryCtxSwitches |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoluntaryCtxSwitches", wireType)
			}
			m.InvoluntaryCtxSwitches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvoluntaryCtxSwitches |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByteKey = append(m.ByteKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ByteKey == nil {
				m.ByteKey = []byte{}
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerByteKey = append(m.ContainerByteKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ContainerByteKey == nil {
				m.ContainerByteKey = []byte{}
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UserPct = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SystemPct = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.TotalPct = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuLimit", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CpuLimit = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemRss", wireType)
			}
			m.MemRss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemRss |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemCache", wireType)
			}
			m.MemCache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemCache |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemLimit", wireType)
			}
			m.MemLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rbps = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Wbps = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRcvdPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.NetRcvdPs = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetSentPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.NetSentPs = float32(math.Float32frombits(v))
		case 13:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRcvdBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.NetRcvdBps = float32(math.Float32frombits(v))
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetSentBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.NetSentBps = float32(math.Float32frombits(v))
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ContainerState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			m.Health = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Health |= ContainerHealth(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			m.Started = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Started |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByteKey = append(m.ByteKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ByteKey == nil {
				m.ByteKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Os == nil {
				m.Os = &OSInfo{}
			}
			if err := m.Os.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpus = append(m.Cpus, &CPUInfo{})
			if err := m.Cpus[len(m.Cpus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemory", wireType)
			}
			m.TotalMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMemory |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Family = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IOStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IOStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IOStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ReadRate = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WriteRate = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBytesRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ReadBytesRate = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteBytesRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WriteBytesRate = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Label) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Label: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Label: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HistogramItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistogramItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistogramItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Quantile = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Value = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Histogram) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Histogram: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Histogram: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &HistogramItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, &Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Histogram", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Histogram == nil {
				m.Histogram = &Histogram{}
			}
			if err := m.Histogram.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Connection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Connection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Laddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Laddr == nil {
				m.Laddr = &Addr{}
			}
			if err := m.Laddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Raddr == nil {
				m.Raddr = &Addr{}
			}
			if err := m.Raddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesSentPerSecond", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BytesSentPerSecond = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesReceivedPerSecond", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BytesReceivedPerSecond = float32(math.Float32frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Family |= ConnectionFamily(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ConnectionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PidCreateTime", wireType)
			}
			m.PidCreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PidCreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= ConnectionDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectedProtocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DetectedProtocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, &Metric{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Addr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Addr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Addr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rss", wireType)
			}
			m.Rss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rss |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vms", wireType)
			}
			m.Vms = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vms |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			m.Swap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Swap |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shared", wireType)
			}
			m.Shared = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shared |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			m.Text = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Text |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lib", wireType)
			}
			m.Lib = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lib |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			m.Data = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Data |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dirty", wireType)
			}
			m.Dirty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dirty |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCpu", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastCpu = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.TotalPct = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UserPct = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SystemPct = float32(math.Float32frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumThreads", wireType)
			}
			m.NumThreads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumThreads |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpus = append(m.Cpus, &SingleCPUStat{})
			if err := m.Cpus[len(m.Cpus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nice", wireType)
			}
			m.Nice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nice |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserTime", wireType)
			}
			m.UserTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemTime", wireType)
			}
			m.SystemTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SystemTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleCPUStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleCPUStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleCPUStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.TotalPct = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Family = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cores", wireType)
			}
			m.Cores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cores |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mhz", wireType)
			}
			m.Mhz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mhz |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheSize", wireType)
			}
			m.CacheSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Host) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Host: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Host: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			m.OrgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &HostTags{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllTags = append(m.AllTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCpus", wireType)
			}
			m.NumCpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCpus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemory", wireType)
			}
			m.TotalMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMemory |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostTags) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostTags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostTags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			m.SourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAgent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAgent
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAgent
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAgent
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAgent        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAgent          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAgent = fmt.Errorf("proto: unexpected end of group")
)
