// Code generated by protoc-gen-gogo.
// source: agent.proto
// DO NOT EDIT!

/*
	Package model is a generated protocol buffer package.

	It is generated from these files:
		agent.proto

	It has these top-level messages:
		ResCollector
		CollectorProc
		CollectorConnections
		CollectorRealTime
		CollectorReqStatus
		CollectorStatus
		Process
		Command
		ProcessUser
		Container
		ProcessStat
		SystemInfo
		OSInfo
		Connection
		Addr
		MemoryStat
		IOStat
		CPUStat
		SingleCPUStat
		CPUInfo
		Host
		HostTags
*/
package model

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import datadog_agentpayload "github.com/DataDog/agent-payload/gogen"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// status section in https://docs.docker.com/engine/api/v1.29/#tag/Container
type ContainerState int32

const (
	ContainerState_unknown    ContainerState = 0
	ContainerState_created    ContainerState = 1
	ContainerState_restarting ContainerState = 2
	ContainerState_running    ContainerState = 3
	ContainerState_paused     ContainerState = 4
	ContainerState_exited     ContainerState = 5
	ContainerState_dead       ContainerState = 6
)

var ContainerState_name = map[int32]string{
	0: "unknown",
	1: "created",
	2: "restarting",
	3: "running",
	4: "paused",
	5: "exited",
	6: "dead",
}
var ContainerState_value = map[string]int32{
	"unknown":    0,
	"created":    1,
	"restarting": 2,
	"running":    3,
	"paused":     4,
	"exited":     5,
	"dead":       6,
}

func (x ContainerState) String() string {
	return proto.EnumName(ContainerState_name, int32(x))
}
func (ContainerState) EnumDescriptor() ([]byte, []int) { return fileDescriptorAgent, []int{0} }

// https://blog.couchbase.com/docker-health-check-keeping-containers-healthy/
// health can be: starting, healthy, unhealthy
type ContainerHealth int32

const (
	ContainerHealth_unknownHealth ContainerHealth = 0
	ContainerHealth_starting      ContainerHealth = 1
	ContainerHealth_healthy       ContainerHealth = 2
	ContainerHealth_unhealthy     ContainerHealth = 3
)

var ContainerHealth_name = map[int32]string{
	0: "unknownHealth",
	1: "starting",
	2: "healthy",
	3: "unhealthy",
}
var ContainerHealth_value = map[string]int32{
	"unknownHealth": 0,
	"starting":      1,
	"healthy":       2,
	"unhealthy":     3,
}

func (x ContainerHealth) String() string {
	return proto.EnumName(ContainerHealth_name, int32(x))
}
func (ContainerHealth) EnumDescriptor() ([]byte, []int) { return fileDescriptorAgent, []int{1} }

// Process state codes in http://wiki.preshweb.co.uk/doku.php?id=linux:psflags
type ProcessState int32

const (
	ProcessState_U ProcessState = 0
	ProcessState_D ProcessState = 1
	ProcessState_R ProcessState = 2
	ProcessState_S ProcessState = 3
	ProcessState_T ProcessState = 4
	ProcessState_W ProcessState = 5
	ProcessState_X ProcessState = 6
	ProcessState_Z ProcessState = 7
)

var ProcessState_name = map[int32]string{
	0: "U",
	1: "D",
	2: "R",
	3: "S",
	4: "T",
	5: "W",
	6: "X",
	7: "Z",
}
var ProcessState_value = map[string]int32{
	"U": 0,
	"D": 1,
	"R": 2,
	"S": 3,
	"T": 4,
	"W": 5,
	"X": 6,
	"Z": 7,
}

func (x ProcessState) String() string {
	return proto.EnumName(ProcessState_name, int32(x))
}
func (ProcessState) EnumDescriptor() ([]byte, []int) { return fileDescriptorAgent, []int{2} }

type ResCollector struct {
	Header  *ResCollector_Header `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Message string               `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Status  *CollectorStatus     `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *ResCollector) Reset()                    { *m = ResCollector{} }
func (m *ResCollector) String() string            { return proto.CompactTextString(m) }
func (*ResCollector) ProtoMessage()               {}
func (*ResCollector) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{0} }

func (m *ResCollector) GetHeader() *ResCollector_Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ResCollector) GetStatus() *CollectorStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Header must exist at position 1 for compatibility
// with older version of the Agent. We should be able
// to drop this at some point.
type ResCollector_Header struct {
	Type int32 `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *ResCollector_Header) Reset()                    { *m = ResCollector_Header{} }
func (m *ResCollector_Header) String() string            { return proto.CompactTextString(m) }
func (*ResCollector_Header) ProtoMessage()               {}
func (*ResCollector_Header) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{0, 0} }

type CollectorProc struct {
	HostName  string      `protobuf:"bytes,2,opt,name=hostName,proto3" json:"hostName,omitempty"`
	Processes []*Process  `protobuf:"bytes,3,rep,name=processes" json:"processes,omitempty"`
	Host      *Host       `protobuf:"bytes,4,opt,name=host" json:"host,omitempty"`
	Info      *SystemInfo `protobuf:"bytes,5,opt,name=info" json:"info,omitempty"`
	GroupId   int32       `protobuf:"varint,6,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize int32       `protobuf:"varint,7,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	// Optional metadata fields
	Kubernetes *datadog_agentpayload.KubeMetadataPayload `protobuf:"bytes,8,opt,name=kubernetes" json:"kubernetes,omitempty"`
}

func (m *CollectorProc) Reset()                    { *m = CollectorProc{} }
func (m *CollectorProc) String() string            { return proto.CompactTextString(m) }
func (*CollectorProc) ProtoMessage()               {}
func (*CollectorProc) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{1} }

func (m *CollectorProc) GetProcesses() []*Process {
	if m != nil {
		return m.Processes
	}
	return nil
}

func (m *CollectorProc) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *CollectorProc) GetInfo() *SystemInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *CollectorProc) GetKubernetes() *datadog_agentpayload.KubeMetadataPayload {
	if m != nil {
		return m.Kubernetes
	}
	return nil
}

type CollectorConnections struct {
	HostName    string        `protobuf:"bytes,2,opt,name=hostName,proto3" json:"hostName,omitempty"`
	Connections []*Connection `protobuf:"bytes,3,rep,name=connections" json:"connections,omitempty"`
	Host        *Host         `protobuf:"bytes,4,opt,name=host" json:"host,omitempty"`
}

func (m *CollectorConnections) Reset()                    { *m = CollectorConnections{} }
func (m *CollectorConnections) String() string            { return proto.CompactTextString(m) }
func (*CollectorConnections) ProtoMessage()               {}
func (*CollectorConnections) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{2} }

func (m *CollectorConnections) GetConnections() []*Connection {
	if m != nil {
		return m.Connections
	}
	return nil
}

func (m *CollectorConnections) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

type CollectorRealTime struct {
	HostName string         `protobuf:"bytes,2,opt,name=hostName,proto3" json:"hostName,omitempty"`
	Stats    []*ProcessStat `protobuf:"bytes,3,rep,name=stats" json:"stats,omitempty"`
	// Post-resolved fields
	HostId      int32 `protobuf:"varint,4,opt,name=hostId,proto3" json:"hostId,omitempty"`
	OrgId       int32 `protobuf:"varint,5,opt,name=orgId,proto3" json:"orgId,omitempty"`
	GroupId     int32 `protobuf:"varint,6,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize   int32 `protobuf:"varint,7,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	NumCpus     int32 `protobuf:"varint,8,opt,name=numCpus,proto3" json:"numCpus,omitempty"`
	TotalMemory int64 `protobuf:"varint,9,opt,name=totalMemory,proto3" json:"totalMemory,omitempty"`
}

func (m *CollectorRealTime) Reset()                    { *m = CollectorRealTime{} }
func (m *CollectorRealTime) String() string            { return proto.CompactTextString(m) }
func (*CollectorRealTime) ProtoMessage()               {}
func (*CollectorRealTime) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{3} }

func (m *CollectorRealTime) GetStats() []*ProcessStat {
	if m != nil {
		return m.Stats
	}
	return nil
}

type CollectorReqStatus struct {
	HostName string `protobuf:"bytes,2,opt,name=hostName,proto3" json:"hostName,omitempty"`
}

func (m *CollectorReqStatus) Reset()                    { *m = CollectorReqStatus{} }
func (m *CollectorReqStatus) String() string            { return proto.CompactTextString(m) }
func (*CollectorReqStatus) ProtoMessage()               {}
func (*CollectorReqStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{4} }

type CollectorStatus struct {
	ActiveClients int32 `protobuf:"varint,1,opt,name=activeClients,proto3" json:"activeClients,omitempty"`
	Interval      int32 `protobuf:"varint,2,opt,name=interval,proto3" json:"interval,omitempty"`
}

func (m *CollectorStatus) Reset()                    { *m = CollectorStatus{} }
func (m *CollectorStatus) String() string            { return proto.CompactTextString(m) }
func (*CollectorStatus) ProtoMessage()               {}
func (*CollectorStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{5} }

type Process struct {
	Key     uint32       `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Pid     int32        `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
	Host    *Host        `protobuf:"bytes,3,opt,name=host" json:"host,omitempty"`
	Command *Command     `protobuf:"bytes,4,opt,name=command" json:"command,omitempty"`
	User    *ProcessUser `protobuf:"bytes,5,opt,name=user" json:"user,omitempty"`
	// 6 is deprecated
	Memory      *MemoryStat  `protobuf:"bytes,7,opt,name=memory" json:"memory,omitempty"`
	Cpu         *CPUStat     `protobuf:"bytes,8,opt,name=cpu" json:"cpu,omitempty"`
	CreateTime  int64        `protobuf:"varint,9,opt,name=createTime,proto3" json:"createTime,omitempty"`
	Container   *Container   `protobuf:"bytes,10,opt,name=container" json:"container,omitempty"`
	OpenFdCount int32        `protobuf:"varint,11,opt,name=openFdCount,proto3" json:"openFdCount,omitempty"`
	State       ProcessState `protobuf:"varint,12,opt,name=state,proto3,enum=datadog.process_agent.ProcessState" json:"state,omitempty"`
	// IO
	IoStat *IOStat `protobuf:"bytes,13,opt,name=ioStat" json:"ioStat,omitempty"`
}

func (m *Process) Reset()                    { *m = Process{} }
func (m *Process) String() string            { return proto.CompactTextString(m) }
func (*Process) ProtoMessage()               {}
func (*Process) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{6} }

func (m *Process) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *Process) GetCommand() *Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *Process) GetUser() *ProcessUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Process) GetMemory() *MemoryStat {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *Process) GetCpu() *CPUStat {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *Process) GetContainer() *Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *Process) GetIoStat() *IOStat {
	if m != nil {
		return m.IoStat
	}
	return nil
}

type Command struct {
	Args   []string `protobuf:"bytes,1,rep,name=args" json:"args,omitempty"`
	Cwd    string   `protobuf:"bytes,3,opt,name=cwd,proto3" json:"cwd,omitempty"`
	Root   string   `protobuf:"bytes,4,opt,name=root,proto3" json:"root,omitempty"`
	OnDisk bool     `protobuf:"varint,5,opt,name=onDisk,proto3" json:"onDisk,omitempty"`
	Ppid   int32    `protobuf:"varint,6,opt,name=ppid,proto3" json:"ppid,omitempty"`
	Pgroup int32    `protobuf:"varint,7,opt,name=pgroup,proto3" json:"pgroup,omitempty"`
	Exe    string   `protobuf:"bytes,8,opt,name=exe,proto3" json:"exe,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{7} }

type ProcessUser struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Uid  int32  `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	Gid  int32  `protobuf:"varint,3,opt,name=gid,proto3" json:"gid,omitempty"`
	Euid int32  `protobuf:"varint,4,opt,name=euid,proto3" json:"euid,omitempty"`
	Egid int32  `protobuf:"varint,5,opt,name=egid,proto3" json:"egid,omitempty"`
	Suid int32  `protobuf:"varint,6,opt,name=suid,proto3" json:"suid,omitempty"`
	Sgid int32  `protobuf:"varint,7,opt,name=sgid,proto3" json:"sgid,omitempty"`
}

func (m *ProcessUser) Reset()                    { *m = ProcessUser{} }
func (m *ProcessUser) String() string            { return proto.CompactTextString(m) }
func (*ProcessUser) ProtoMessage()               {}
func (*ProcessUser) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{8} }

type Container struct {
	Type        string  `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id          string  `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Name        string  `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Image       string  `protobuf:"bytes,4,opt,name=image,proto3" json:"image,omitempty"`
	CpuLimit    float32 `protobuf:"fixed32,5,opt,name=cpuLimit,proto3" json:"cpuLimit,omitempty"`
	MemoryLimit uint64  `protobuf:"varint,6,opt,name=memoryLimit,proto3" json:"memoryLimit,omitempty"`
	// 7 is removed, do not use.
	State         ContainerState  `protobuf:"varint,8,opt,name=state,proto3,enum=datadog.process_agent.ContainerState" json:"state,omitempty"`
	Health        ContainerHealth `protobuf:"varint,9,opt,name=health,proto3,enum=datadog.process_agent.ContainerHealth" json:"health,omitempty"`
	Created       int64           `protobuf:"varint,10,opt,name=created,proto3" json:"created,omitempty"`
	ContainerRbps float32         `protobuf:"fixed32,11,opt,name=containerRbps,proto3" json:"containerRbps,omitempty"`
	ContainerWbps float32         `protobuf:"fixed32,12,opt,name=containerWbps,proto3" json:"containerWbps,omitempty"`
}

func (m *Container) Reset()                    { *m = Container{} }
func (m *Container) String() string            { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()               {}
func (*Container) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{9} }

// ProcessStat is used for real-time process messages. It should only contain
// data that can change for a running process (and relevant information to
// generate a key). We will send a lot of these in the real-time messages so
// it's critical to keep this small.
type ProcessStat struct {
	Pid int32 `protobuf:"varint,1,opt,name=pid,proto3" json:"pid,omitempty"`
	// In milliseconds
	CreateTime  int64       `protobuf:"varint,2,opt,name=createTime,proto3" json:"createTime,omitempty"`
	Memory      *MemoryStat `protobuf:"bytes,3,opt,name=memory" json:"memory,omitempty"`
	Cpu         *CPUStat    `protobuf:"bytes,4,opt,name=cpu" json:"cpu,omitempty"`
	Nice        int32       `protobuf:"varint,5,opt,name=nice,proto3" json:"nice,omitempty"`
	Threads     int32       `protobuf:"varint,7,opt,name=threads,proto3" json:"threads,omitempty"`
	OpenFdCount int32       `protobuf:"varint,8,opt,name=openFdCount,proto3" json:"openFdCount,omitempty"`
	Key         uint32      `protobuf:"varint,9,opt,name=key,proto3" json:"key,omitempty"`
	// we need container id because we need to do the scoring by container
	ContainerId    string         `protobuf:"bytes,10,opt,name=containerId,proto3" json:"containerId,omitempty"`
	ContainerState ContainerState `protobuf:"varint,11,opt,name=containerState,proto3,enum=datadog.process_agent.ContainerState" json:"containerState,omitempty"`
	ProcessState   ProcessState   `protobuf:"varint,12,opt,name=processState,proto3,enum=datadog.process_agent.ProcessState" json:"processState,omitempty"`
	// These stats are from the container level but are stored per-process
	// because we don't send a container primitive yet.
	ContainerHealth ContainerHealth `protobuf:"varint,15,opt,name=containerHealth,proto3,enum=datadog.process_agent.ContainerHealth" json:"containerHealth,omitempty"`
	ContainerRbps   float32         `protobuf:"fixed32,16,opt,name=containerRbps,proto3" json:"containerRbps,omitempty"`
	ContainerWbps   float32         `protobuf:"fixed32,17,opt,name=containerWbps,proto3" json:"containerWbps,omitempty"`
	// IO
	IoStat *IOStat `protobuf:"bytes,18,opt,name=ioStat" json:"ioStat,omitempty"`
}

func (m *ProcessStat) Reset()                    { *m = ProcessStat{} }
func (m *ProcessStat) String() string            { return proto.CompactTextString(m) }
func (*ProcessStat) ProtoMessage()               {}
func (*ProcessStat) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{10} }

func (m *ProcessStat) GetMemory() *MemoryStat {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *ProcessStat) GetCpu() *CPUStat {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *ProcessStat) GetIoStat() *IOStat {
	if m != nil {
		return m.IoStat
	}
	return nil
}

type SystemInfo struct {
	Uuid string     `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Os   *OSInfo    `protobuf:"bytes,2,opt,name=os" json:"os,omitempty"`
	Cpus []*CPUInfo `protobuf:"bytes,3,rep,name=cpus" json:"cpus,omitempty"`
	// 4 is deprecated
	TotalMemory int64 `protobuf:"varint,5,opt,name=totalMemory,proto3" json:"totalMemory,omitempty"`
}

func (m *SystemInfo) Reset()                    { *m = SystemInfo{} }
func (m *SystemInfo) String() string            { return proto.CompactTextString(m) }
func (*SystemInfo) ProtoMessage()               {}
func (*SystemInfo) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{11} }

func (m *SystemInfo) GetOs() *OSInfo {
	if m != nil {
		return m.Os
	}
	return nil
}

func (m *SystemInfo) GetCpus() []*CPUInfo {
	if m != nil {
		return m.Cpus
	}
	return nil
}

type OSInfo struct {
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Platform      string `protobuf:"bytes,2,opt,name=platform,proto3" json:"platform,omitempty"`
	Family        string `protobuf:"bytes,3,opt,name=family,proto3" json:"family,omitempty"`
	Version       string `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	KernelVersion string `protobuf:"bytes,5,opt,name=kernelVersion,proto3" json:"kernelVersion,omitempty"`
}

func (m *OSInfo) Reset()                    { *m = OSInfo{} }
func (m *OSInfo) String() string            { return proto.CompactTextString(m) }
func (*OSInfo) ProtoMessage()               {}
func (*OSInfo) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{12} }

type Connection struct {
	Pid    int32  `protobuf:"varint,1,opt,name=pid,proto3" json:"pid,omitempty"`
	Fd     int32  `protobuf:"varint,2,opt,name=fd,proto3" json:"fd,omitempty"`
	Family int32  `protobuf:"varint,3,opt,name=family,proto3" json:"family,omitempty"`
	Type   int32  `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
	Laddr  *Addr  `protobuf:"bytes,5,opt,name=laddr" json:"laddr,omitempty"`
	Raddr  *Addr  `protobuf:"bytes,6,opt,name=raddr" json:"raddr,omitempty"`
	Status string `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *Connection) Reset()                    { *m = Connection{} }
func (m *Connection) String() string            { return proto.CompactTextString(m) }
func (*Connection) ProtoMessage()               {}
func (*Connection) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{13} }

func (m *Connection) GetLaddr() *Addr {
	if m != nil {
		return m.Laddr
	}
	return nil
}

func (m *Connection) GetRaddr() *Addr {
	if m != nil {
		return m.Raddr
	}
	return nil
}

type Addr struct {
	Host *Host  `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	Ip   string `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
	Port int32  `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *Addr) Reset()                    { *m = Addr{} }
func (m *Addr) String() string            { return proto.CompactTextString(m) }
func (*Addr) ProtoMessage()               {}
func (*Addr) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{14} }

func (m *Addr) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

type MemoryStat struct {
	Rss    uint64 `protobuf:"varint,1,opt,name=rss,proto3" json:"rss,omitempty"`
	Vms    uint64 `protobuf:"varint,2,opt,name=vms,proto3" json:"vms,omitempty"`
	Swap   uint64 `protobuf:"varint,3,opt,name=swap,proto3" json:"swap,omitempty"`
	Shared uint64 `protobuf:"varint,4,opt,name=shared,proto3" json:"shared,omitempty"`
	Text   uint64 `protobuf:"varint,5,opt,name=text,proto3" json:"text,omitempty"`
	Lib    uint64 `protobuf:"varint,6,opt,name=lib,proto3" json:"lib,omitempty"`
	Data   uint64 `protobuf:"varint,7,opt,name=data,proto3" json:"data,omitempty"`
	Dirty  uint64 `protobuf:"varint,8,opt,name=dirty,proto3" json:"dirty,omitempty"`
}

func (m *MemoryStat) Reset()                    { *m = MemoryStat{} }
func (m *MemoryStat) String() string            { return proto.CompactTextString(m) }
func (*MemoryStat) ProtoMessage()               {}
func (*MemoryStat) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{15} }

type IOStat struct {
	ReadCount  uint64 `protobuf:"varint,1,opt,name=readCount,proto3" json:"readCount,omitempty"`
	WriteCount uint64 `protobuf:"varint,2,opt,name=writeCount,proto3" json:"writeCount,omitempty"`
	ReadBytes  uint64 `protobuf:"varint,3,opt,name=readBytes,proto3" json:"readBytes,omitempty"`
	WriteBytes uint64 `protobuf:"varint,4,opt,name=writeBytes,proto3" json:"writeBytes,omitempty"`
}

func (m *IOStat) Reset()                    { *m = IOStat{} }
func (m *IOStat) String() string            { return proto.CompactTextString(m) }
func (*IOStat) ProtoMessage()               {}
func (*IOStat) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{16} }

type CPUStat struct {
	LastCpu    string           `protobuf:"bytes,1,opt,name=lastCpu,proto3" json:"lastCpu,omitempty"`
	TotalPct   float32          `protobuf:"fixed32,2,opt,name=totalPct,proto3" json:"totalPct,omitempty"`
	UserPct    float32          `protobuf:"fixed32,3,opt,name=userPct,proto3" json:"userPct,omitempty"`
	SystemPct  float32          `protobuf:"fixed32,4,opt,name=systemPct,proto3" json:"systemPct,omitempty"`
	NumThreads int32            `protobuf:"varint,5,opt,name=numThreads,proto3" json:"numThreads,omitempty"`
	Cpus       []*SingleCPUStat `protobuf:"bytes,6,rep,name=cpus" json:"cpus,omitempty"`
	Nice       int32            `protobuf:"varint,7,opt,name=nice,proto3" json:"nice,omitempty"`
	UserTime   int64            `protobuf:"varint,8,opt,name=userTime,proto3" json:"userTime,omitempty"`
	SystemTime int64            `protobuf:"varint,9,opt,name=systemTime,proto3" json:"systemTime,omitempty"`
}

func (m *CPUStat) Reset()                    { *m = CPUStat{} }
func (m *CPUStat) String() string            { return proto.CompactTextString(m) }
func (*CPUStat) ProtoMessage()               {}
func (*CPUStat) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{17} }

func (m *CPUStat) GetCpus() []*SingleCPUStat {
	if m != nil {
		return m.Cpus
	}
	return nil
}

type SingleCPUStat struct {
	Name     string  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	TotalPct float32 `protobuf:"fixed32,2,opt,name=totalPct,proto3" json:"totalPct,omitempty"`
}

func (m *SingleCPUStat) Reset()                    { *m = SingleCPUStat{} }
func (m *SingleCPUStat) String() string            { return proto.CompactTextString(m) }
func (*SingleCPUStat) ProtoMessage()               {}
func (*SingleCPUStat) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{18} }

type CPUInfo struct {
	Number     int32  `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	Vendor     string `protobuf:"bytes,2,opt,name=vendor,proto3" json:"vendor,omitempty"`
	Family     string `protobuf:"bytes,3,opt,name=family,proto3" json:"family,omitempty"`
	Model      string `protobuf:"bytes,4,opt,name=model,proto3" json:"model,omitempty"`
	PhysicalId string `protobuf:"bytes,5,opt,name=physicalId,proto3" json:"physicalId,omitempty"`
	CoreId     string `protobuf:"bytes,6,opt,name=coreId,proto3" json:"coreId,omitempty"`
	Cores      int32  `protobuf:"varint,7,opt,name=cores,proto3" json:"cores,omitempty"`
	Mhz        int64  `protobuf:"varint,8,opt,name=mhz,proto3" json:"mhz,omitempty"`
	CacheSize  int32  `protobuf:"varint,9,opt,name=cacheSize,proto3" json:"cacheSize,omitempty"`
}

func (m *CPUInfo) Reset()                    { *m = CPUInfo{} }
func (m *CPUInfo) String() string            { return proto.CompactTextString(m) }
func (*CPUInfo) ProtoMessage()               {}
func (*CPUInfo) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{19} }

// Host and HostTags are used in backend post-resolution
type Host struct {
	Id          int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	OrgId       int32       `protobuf:"varint,2,opt,name=orgId,proto3" json:"orgId,omitempty"`
	Name        string      `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Tags        []*HostTags `protobuf:"bytes,4,rep,name=tags" json:"tags,omitempty"`
	AllTags     []string    `protobuf:"bytes,6,rep,name=allTags" json:"allTags,omitempty"`
	NumCpus     int32       `protobuf:"varint,7,opt,name=numCpus,proto3" json:"numCpus,omitempty"`
	TotalMemory int64       `protobuf:"varint,8,opt,name=totalMemory,proto3" json:"totalMemory,omitempty"`
}

func (m *Host) Reset()                    { *m = Host{} }
func (m *Host) String() string            { return proto.CompactTextString(m) }
func (*Host) ProtoMessage()               {}
func (*Host) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{20} }

func (m *Host) GetTags() []*HostTags {
	if m != nil {
		return m.Tags
	}
	return nil
}

type HostTags struct {
	SourceType uint32   `protobuf:"varint,1,opt,name=sourceType,proto3" json:"sourceType,omitempty"`
	Tags       []string `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty"`
}

func (m *HostTags) Reset()                    { *m = HostTags{} }
func (m *HostTags) String() string            { return proto.CompactTextString(m) }
func (*HostTags) ProtoMessage()               {}
func (*HostTags) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{21} }

func init() {
	proto.RegisterType((*ResCollector)(nil), "datadog.process_agent.ResCollector")
	proto.RegisterType((*ResCollector_Header)(nil), "datadog.process_agent.ResCollector.Header")
	proto.RegisterType((*CollectorProc)(nil), "datadog.process_agent.CollectorProc")
	proto.RegisterType((*CollectorConnections)(nil), "datadog.process_agent.CollectorConnections")
	proto.RegisterType((*CollectorRealTime)(nil), "datadog.process_agent.CollectorRealTime")
	proto.RegisterType((*CollectorReqStatus)(nil), "datadog.process_agent.CollectorReqStatus")
	proto.RegisterType((*CollectorStatus)(nil), "datadog.process_agent.CollectorStatus")
	proto.RegisterType((*Process)(nil), "datadog.process_agent.Process")
	proto.RegisterType((*Command)(nil), "datadog.process_agent.Command")
	proto.RegisterType((*ProcessUser)(nil), "datadog.process_agent.ProcessUser")
	proto.RegisterType((*Container)(nil), "datadog.process_agent.Container")
	proto.RegisterType((*ProcessStat)(nil), "datadog.process_agent.ProcessStat")
	proto.RegisterType((*SystemInfo)(nil), "datadog.process_agent.SystemInfo")
	proto.RegisterType((*OSInfo)(nil), "datadog.process_agent.OSInfo")
	proto.RegisterType((*Connection)(nil), "datadog.process_agent.Connection")
	proto.RegisterType((*Addr)(nil), "datadog.process_agent.Addr")
	proto.RegisterType((*MemoryStat)(nil), "datadog.process_agent.MemoryStat")
	proto.RegisterType((*IOStat)(nil), "datadog.process_agent.IOStat")
	proto.RegisterType((*CPUStat)(nil), "datadog.process_agent.CPUStat")
	proto.RegisterType((*SingleCPUStat)(nil), "datadog.process_agent.SingleCPUStat")
	proto.RegisterType((*CPUInfo)(nil), "datadog.process_agent.CPUInfo")
	proto.RegisterType((*Host)(nil), "datadog.process_agent.Host")
	proto.RegisterType((*HostTags)(nil), "datadog.process_agent.HostTags")
	proto.RegisterEnum("datadog.process_agent.ContainerState", ContainerState_name, ContainerState_value)
	proto.RegisterEnum("datadog.process_agent.ContainerHealth", ContainerHealth_name, ContainerHealth_value)
	proto.RegisterEnum("datadog.process_agent.ProcessState", ProcessState_name, ProcessState_value)
}
func (m *ResCollector) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ResCollector) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Header.Size()))
		n1, err := m.Header.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Message) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	if m.Status != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Status.Size()))
		n2, err := m.Status.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *ResCollector_Header) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ResCollector_Header) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.Type))
	}
	return i, nil
}

func (m *CollectorProc) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorProc) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.HostName)))
		i += copy(data[i:], m.HostName)
	}
	if len(m.Processes) > 0 {
		for _, msg := range m.Processes {
			data[i] = 0x1a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Host != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(m.Host.Size()))
		n3, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Info != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Info.Size()))
		n4, err := m.Info.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.GroupId != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if m.Kubernetes != nil {
		data[i] = 0x42
		i++
		i = encodeVarintAgent(data, i, uint64(m.Kubernetes.Size()))
		n5, err := m.Kubernetes.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *CollectorConnections) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorConnections) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.HostName)))
		i += copy(data[i:], m.HostName)
	}
	if len(m.Connections) > 0 {
		for _, msg := range m.Connections {
			data[i] = 0x1a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Host != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(m.Host.Size()))
		n6, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *CollectorRealTime) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorRealTime) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.HostName)))
		i += copy(data[i:], m.HostName)
	}
	if len(m.Stats) > 0 {
		for _, msg := range m.Stats {
			data[i] = 0x1a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HostId != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.HostId))
	}
	if m.OrgId != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.OrgId))
	}
	if m.GroupId != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if m.NumCpus != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.NumCpus))
	}
	if m.TotalMemory != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintAgent(data, i, uint64(m.TotalMemory))
	}
	return i, nil
}

func (m *CollectorReqStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorReqStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.HostName)))
		i += copy(data[i:], m.HostName)
	}
	return i, nil
}

func (m *CollectorStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ActiveClients != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.ActiveClients))
	}
	if m.Interval != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Interval))
	}
	return i, nil
}

func (m *Process) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Process) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.Key))
	}
	if m.Pid != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Pid))
	}
	if m.Host != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Host.Size()))
		n7, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Command != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(m.Command.Size()))
		n8, err := m.Command.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.User != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(m.User.Size()))
		n9, err := m.User.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Memory != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Memory.Size()))
		n10, err := m.Memory.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Cpu != nil {
		data[i] = 0x42
		i++
		i = encodeVarintAgent(data, i, uint64(m.Cpu.Size()))
		n11, err := m.Cpu.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.CreateTime != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintAgent(data, i, uint64(m.CreateTime))
	}
	if m.Container != nil {
		data[i] = 0x52
		i++
		i = encodeVarintAgent(data, i, uint64(m.Container.Size()))
		n12, err := m.Container.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.OpenFdCount != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintAgent(data, i, uint64(m.OpenFdCount))
	}
	if m.State != 0 {
		data[i] = 0x60
		i++
		i = encodeVarintAgent(data, i, uint64(m.State))
	}
	if m.IoStat != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintAgent(data, i, uint64(m.IoStat.Size()))
		n13, err := m.IoStat.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *Command) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Command) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Cwd) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Cwd)))
		i += copy(data[i:], m.Cwd)
	}
	if len(m.Root) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Root)))
		i += copy(data[i:], m.Root)
	}
	if m.OnDisk {
		data[i] = 0x28
		i++
		if m.OnDisk {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Ppid != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.Ppid))
	}
	if m.Pgroup != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.Pgroup))
	}
	if len(m.Exe) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Exe)))
		i += copy(data[i:], m.Exe)
	}
	return i, nil
}

func (m *ProcessUser) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProcessUser) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.Uid != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Uid))
	}
	if m.Gid != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.Gid))
	}
	if m.Euid != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.Euid))
	}
	if m.Egid != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.Egid))
	}
	if m.Suid != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.Suid))
	}
	if m.Sgid != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.Sgid))
	}
	return i, nil
}

func (m *Container) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Container) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Id) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Image) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Image)))
		i += copy(data[i:], m.Image)
	}
	if m.CpuLimit != 0 {
		data[i] = 0x2d
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.CpuLimit))))
	}
	if m.MemoryLimit != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.MemoryLimit))
	}
	if m.State != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.State))
	}
	if m.Health != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintAgent(data, i, uint64(m.Health))
	}
	if m.Created != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintAgent(data, i, uint64(m.Created))
	}
	if m.ContainerRbps != 0 {
		data[i] = 0x5d
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.ContainerRbps))))
	}
	if m.ContainerWbps != 0 {
		data[i] = 0x65
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.ContainerWbps))))
	}
	return i, nil
}

func (m *ProcessStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProcessStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.Pid))
	}
	if m.CreateTime != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.CreateTime))
	}
	if m.Memory != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Memory.Size()))
		n14, err := m.Memory.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Cpu != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(m.Cpu.Size()))
		n15, err := m.Cpu.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Nice != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.Nice))
	}
	if m.Threads != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.Threads))
	}
	if m.OpenFdCount != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.OpenFdCount))
	}
	if m.Key != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintAgent(data, i, uint64(m.Key))
	}
	if len(m.ContainerId) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ContainerId)))
		i += copy(data[i:], m.ContainerId)
	}
	if m.ContainerState != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintAgent(data, i, uint64(m.ContainerState))
	}
	if m.ProcessState != 0 {
		data[i] = 0x60
		i++
		i = encodeVarintAgent(data, i, uint64(m.ProcessState))
	}
	if m.ContainerHealth != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintAgent(data, i, uint64(m.ContainerHealth))
	}
	if m.ContainerRbps != 0 {
		data[i] = 0x85
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.ContainerRbps))))
	}
	if m.ContainerWbps != 0 {
		data[i] = 0x8d
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.ContainerWbps))))
	}
	if m.IoStat != nil {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.IoStat.Size()))
		n16, err := m.IoStat.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *SystemInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SystemInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Uuid)))
		i += copy(data[i:], m.Uuid)
	}
	if m.Os != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Os.Size()))
		n17, err := m.Os.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.Cpus) > 0 {
		for _, msg := range m.Cpus {
			data[i] = 0x1a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalMemory != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.TotalMemory))
	}
	return i, nil
}

func (m *OSInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OSInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Platform) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Platform)))
		i += copy(data[i:], m.Platform)
	}
	if len(m.Family) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Family)))
		i += copy(data[i:], m.Family)
	}
	if len(m.Version) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.KernelVersion) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.KernelVersion)))
		i += copy(data[i:], m.KernelVersion)
	}
	return i, nil
}

func (m *Connection) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Connection) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.Pid))
	}
	if m.Fd != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Fd))
	}
	if m.Family != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.Family))
	}
	if m.Type != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.Type))
	}
	if m.Laddr != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Laddr.Size()))
		n18, err := m.Laddr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Raddr != nil {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(m.Raddr.Size()))
		n19, err := m.Raddr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.Status) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Status)))
		i += copy(data[i:], m.Status)
	}
	return i, nil
}

func (m *Addr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Addr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Host != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Host.Size()))
		n20, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.Ip) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Ip)))
		i += copy(data[i:], m.Ip)
	}
	if m.Port != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.Port))
	}
	return i, nil
}

func (m *MemoryStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MemoryStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rss != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.Rss))
	}
	if m.Vms != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Vms))
	}
	if m.Swap != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.Swap))
	}
	if m.Shared != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.Shared))
	}
	if m.Text != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.Text))
	}
	if m.Lib != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.Lib))
	}
	if m.Data != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.Data))
	}
	if m.Dirty != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.Dirty))
	}
	return i, nil
}

func (m *IOStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IOStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReadCount != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.ReadCount))
	}
	if m.WriteCount != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.WriteCount))
	}
	if m.ReadBytes != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.ReadBytes))
	}
	if m.WriteBytes != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.WriteBytes))
	}
	return i, nil
}

func (m *CPUStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CPUStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LastCpu) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.LastCpu)))
		i += copy(data[i:], m.LastCpu)
	}
	if m.TotalPct != 0 {
		data[i] = 0x15
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.TotalPct))))
	}
	if m.UserPct != 0 {
		data[i] = 0x1d
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.UserPct))))
	}
	if m.SystemPct != 0 {
		data[i] = 0x25
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.SystemPct))))
	}
	if m.NumThreads != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.NumThreads))
	}
	if len(m.Cpus) > 0 {
		for _, msg := range m.Cpus {
			data[i] = 0x32
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Nice != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.Nice))
	}
	if m.UserTime != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.UserTime))
	}
	if m.SystemTime != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintAgent(data, i, uint64(m.SystemTime))
	}
	return i, nil
}

func (m *SingleCPUStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SingleCPUStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.TotalPct != 0 {
		data[i] = 0x15
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.TotalPct))))
	}
	return i, nil
}

func (m *CPUInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CPUInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Number != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.Number))
	}
	if len(m.Vendor) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Vendor)))
		i += copy(data[i:], m.Vendor)
	}
	if len(m.Family) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Family)))
		i += copy(data[i:], m.Family)
	}
	if len(m.Model) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Model)))
		i += copy(data[i:], m.Model)
	}
	if len(m.PhysicalId) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.PhysicalId)))
		i += copy(data[i:], m.PhysicalId)
	}
	if len(m.CoreId) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.CoreId)))
		i += copy(data[i:], m.CoreId)
	}
	if m.Cores != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.Cores))
	}
	if m.Mhz != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.Mhz))
	}
	if m.CacheSize != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintAgent(data, i, uint64(m.CacheSize))
	}
	return i, nil
}

func (m *Host) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Host) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.Id))
	}
	if m.OrgId != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.OrgId))
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			data[i] = 0x22
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AllTags) > 0 {
		for _, s := range m.AllTags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.NumCpus != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.NumCpus))
	}
	if m.TotalMemory != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.TotalMemory))
	}
	return i, nil
}

func (m *HostTags) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HostTags) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SourceType != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.SourceType))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func encodeFixed64Agent(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Agent(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAgent(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *ResCollector) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ResCollector_Header) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAgent(uint64(m.Type))
	}
	return n
}

func (m *CollectorProc) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Processes) > 0 {
		for _, e := range m.Processes {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if m.Kubernetes != nil {
		l = m.Kubernetes.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *CollectorConnections) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Connections) > 0 {
		for _, e := range m.Connections {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *CollectorRealTime) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.HostId != 0 {
		n += 1 + sovAgent(uint64(m.HostId))
	}
	if m.OrgId != 0 {
		n += 1 + sovAgent(uint64(m.OrgId))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if m.NumCpus != 0 {
		n += 1 + sovAgent(uint64(m.NumCpus))
	}
	if m.TotalMemory != 0 {
		n += 1 + sovAgent(uint64(m.TotalMemory))
	}
	return n
}

func (m *CollectorReqStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *CollectorStatus) Size() (n int) {
	var l int
	_ = l
	if m.ActiveClients != 0 {
		n += 1 + sovAgent(uint64(m.ActiveClients))
	}
	if m.Interval != 0 {
		n += 1 + sovAgent(uint64(m.Interval))
	}
	return n
}

func (m *Process) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovAgent(uint64(m.Key))
	}
	if m.Pid != 0 {
		n += 1 + sovAgent(uint64(m.Pid))
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.CreateTime != 0 {
		n += 1 + sovAgent(uint64(m.CreateTime))
	}
	if m.Container != nil {
		l = m.Container.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.OpenFdCount != 0 {
		n += 1 + sovAgent(uint64(m.OpenFdCount))
	}
	if m.State != 0 {
		n += 1 + sovAgent(uint64(m.State))
	}
	if m.IoStat != nil {
		l = m.IoStat.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *Command) Size() (n int) {
	var l int
	_ = l
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.Cwd)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.OnDisk {
		n += 2
	}
	if m.Ppid != 0 {
		n += 1 + sovAgent(uint64(m.Ppid))
	}
	if m.Pgroup != 0 {
		n += 1 + sovAgent(uint64(m.Pgroup))
	}
	l = len(m.Exe)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ProcessUser) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovAgent(uint64(m.Uid))
	}
	if m.Gid != 0 {
		n += 1 + sovAgent(uint64(m.Gid))
	}
	if m.Euid != 0 {
		n += 1 + sovAgent(uint64(m.Euid))
	}
	if m.Egid != 0 {
		n += 1 + sovAgent(uint64(m.Egid))
	}
	if m.Suid != 0 {
		n += 1 + sovAgent(uint64(m.Suid))
	}
	if m.Sgid != 0 {
		n += 1 + sovAgent(uint64(m.Sgid))
	}
	return n
}

func (m *Container) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.CpuLimit != 0 {
		n += 5
	}
	if m.MemoryLimit != 0 {
		n += 1 + sovAgent(uint64(m.MemoryLimit))
	}
	if m.State != 0 {
		n += 1 + sovAgent(uint64(m.State))
	}
	if m.Health != 0 {
		n += 1 + sovAgent(uint64(m.Health))
	}
	if m.Created != 0 {
		n += 1 + sovAgent(uint64(m.Created))
	}
	if m.ContainerRbps != 0 {
		n += 5
	}
	if m.ContainerWbps != 0 {
		n += 5
	}
	return n
}

func (m *ProcessStat) Size() (n int) {
	var l int
	_ = l
	if m.Pid != 0 {
		n += 1 + sovAgent(uint64(m.Pid))
	}
	if m.CreateTime != 0 {
		n += 1 + sovAgent(uint64(m.CreateTime))
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Nice != 0 {
		n += 1 + sovAgent(uint64(m.Nice))
	}
	if m.Threads != 0 {
		n += 1 + sovAgent(uint64(m.Threads))
	}
	if m.OpenFdCount != 0 {
		n += 1 + sovAgent(uint64(m.OpenFdCount))
	}
	if m.Key != 0 {
		n += 1 + sovAgent(uint64(m.Key))
	}
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.ContainerState != 0 {
		n += 1 + sovAgent(uint64(m.ContainerState))
	}
	if m.ProcessState != 0 {
		n += 1 + sovAgent(uint64(m.ProcessState))
	}
	if m.ContainerHealth != 0 {
		n += 1 + sovAgent(uint64(m.ContainerHealth))
	}
	if m.ContainerRbps != 0 {
		n += 6
	}
	if m.ContainerWbps != 0 {
		n += 6
	}
	if m.IoStat != nil {
		l = m.IoStat.Size()
		n += 2 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *SystemInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Os != nil {
		l = m.Os.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Cpus) > 0 {
		for _, e := range m.Cpus {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.TotalMemory != 0 {
		n += 1 + sovAgent(uint64(m.TotalMemory))
	}
	return n
}

func (m *OSInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Family)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.KernelVersion)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *Connection) Size() (n int) {
	var l int
	_ = l
	if m.Pid != 0 {
		n += 1 + sovAgent(uint64(m.Pid))
	}
	if m.Fd != 0 {
		n += 1 + sovAgent(uint64(m.Fd))
	}
	if m.Family != 0 {
		n += 1 + sovAgent(uint64(m.Family))
	}
	if m.Type != 0 {
		n += 1 + sovAgent(uint64(m.Type))
	}
	if m.Laddr != nil {
		l = m.Laddr.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Raddr != nil {
		l = m.Raddr.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *Addr) Size() (n int) {
	var l int
	_ = l
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovAgent(uint64(m.Port))
	}
	return n
}

func (m *MemoryStat) Size() (n int) {
	var l int
	_ = l
	if m.Rss != 0 {
		n += 1 + sovAgent(uint64(m.Rss))
	}
	if m.Vms != 0 {
		n += 1 + sovAgent(uint64(m.Vms))
	}
	if m.Swap != 0 {
		n += 1 + sovAgent(uint64(m.Swap))
	}
	if m.Shared != 0 {
		n += 1 + sovAgent(uint64(m.Shared))
	}
	if m.Text != 0 {
		n += 1 + sovAgent(uint64(m.Text))
	}
	if m.Lib != 0 {
		n += 1 + sovAgent(uint64(m.Lib))
	}
	if m.Data != 0 {
		n += 1 + sovAgent(uint64(m.Data))
	}
	if m.Dirty != 0 {
		n += 1 + sovAgent(uint64(m.Dirty))
	}
	return n
}

func (m *IOStat) Size() (n int) {
	var l int
	_ = l
	if m.ReadCount != 0 {
		n += 1 + sovAgent(uint64(m.ReadCount))
	}
	if m.WriteCount != 0 {
		n += 1 + sovAgent(uint64(m.WriteCount))
	}
	if m.ReadBytes != 0 {
		n += 1 + sovAgent(uint64(m.ReadBytes))
	}
	if m.WriteBytes != 0 {
		n += 1 + sovAgent(uint64(m.WriteBytes))
	}
	return n
}

func (m *CPUStat) Size() (n int) {
	var l int
	_ = l
	l = len(m.LastCpu)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.TotalPct != 0 {
		n += 5
	}
	if m.UserPct != 0 {
		n += 5
	}
	if m.SystemPct != 0 {
		n += 5
	}
	if m.NumThreads != 0 {
		n += 1 + sovAgent(uint64(m.NumThreads))
	}
	if len(m.Cpus) > 0 {
		for _, e := range m.Cpus {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Nice != 0 {
		n += 1 + sovAgent(uint64(m.Nice))
	}
	if m.UserTime != 0 {
		n += 1 + sovAgent(uint64(m.UserTime))
	}
	if m.SystemTime != 0 {
		n += 1 + sovAgent(uint64(m.SystemTime))
	}
	return n
}

func (m *SingleCPUStat) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.TotalPct != 0 {
		n += 5
	}
	return n
}

func (m *CPUInfo) Size() (n int) {
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovAgent(uint64(m.Number))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Family)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.PhysicalId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.CoreId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Cores != 0 {
		n += 1 + sovAgent(uint64(m.Cores))
	}
	if m.Mhz != 0 {
		n += 1 + sovAgent(uint64(m.Mhz))
	}
	if m.CacheSize != 0 {
		n += 1 + sovAgent(uint64(m.CacheSize))
	}
	return n
}

func (m *Host) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAgent(uint64(m.Id))
	}
	if m.OrgId != 0 {
		n += 1 + sovAgent(uint64(m.OrgId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.AllTags) > 0 {
		for _, s := range m.AllTags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.NumCpus != 0 {
		n += 1 + sovAgent(uint64(m.NumCpus))
	}
	if m.TotalMemory != 0 {
		n += 1 + sovAgent(uint64(m.TotalMemory))
	}
	return n
}

func (m *HostTags) Size() (n int) {
	var l int
	_ = l
	if m.SourceType != 0 {
		n += 1 + sovAgent(uint64(m.SourceType))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func sovAgent(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAgent(x uint64) (n int) {
	return sovAgent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ResCollector) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResCollector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResCollector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResCollector_Header{}
			}
			if err := m.Header.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &CollectorStatus{}
			}
			if err := m.Status.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResCollector_Header) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorProc) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorProc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorProc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Processes = append(m.Processes, &Process{})
			if err := m.Processes[len(m.Processes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &SystemInfo{}
			}
			if err := m.Info.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kubernetes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kubernetes == nil {
				m.Kubernetes = &datadog_agentpayload.KubeMetadataPayload{}
			}
			if err := m.Kubernetes.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorConnections) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorConnections: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorConnections: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Connections = append(m.Connections, &Connection{})
			if err := m.Connections[len(m.Connections)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorRealTime) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorRealTime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorRealTime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, &ProcessStat{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostId", wireType)
			}
			m.HostId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.HostId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			m.OrgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OrgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCpus", wireType)
			}
			m.NumCpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NumCpus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemory", wireType)
			}
			m.TotalMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalMemory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorReqStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorReqStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorReqStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveClients", wireType)
			}
			m.ActiveClients = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ActiveClients |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Interval |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Process) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Process: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Process: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Key |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Pid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &Command{}
			}
			if err := m.Command.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &ProcessUser{}
			}
			if err := m.User.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &MemoryStat{}
			}
			if err := m.Memory.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CPUStat{}
			}
			if err := m.Cpu.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &Container{}
			}
			if err := m.Container.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenFdCount", wireType)
			}
			m.OpenFdCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OpenFdCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (ProcessState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IoStat == nil {
				m.IoStat = &IOStat{}
			}
			if err := m.IoStat.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Command) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cwd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cwd = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDisk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnDisk = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ppid", wireType)
			}
			m.Ppid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ppid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pgroup", wireType)
			}
			m.Pgroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Pgroup |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exe", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exe = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessUser) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Gid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Euid", wireType)
			}
			m.Euid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Euid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egid", wireType)
			}
			m.Egid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Egid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suid", wireType)
			}
			m.Suid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Suid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sgid", wireType)
			}
			m.Sgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Sgid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Container) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Container: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Container: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuLimit", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.CpuLimit = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryLimit", wireType)
			}
			m.MemoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemoryLimit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (ContainerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			m.Health = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Health |= (ContainerHealth(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Created |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerRbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ContainerRbps = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerWbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ContainerWbps = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Pid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &MemoryStat{}
			}
			if err := m.Memory.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CPUStat{}
			}
			if err := m.Cpu.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nice", wireType)
			}
			m.Nice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Nice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threads", wireType)
			}
			m.Threads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Threads |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenFdCount", wireType)
			}
			m.OpenFdCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OpenFdCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Key |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerState", wireType)
			}
			m.ContainerState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ContainerState |= (ContainerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessState", wireType)
			}
			m.ProcessState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ProcessState |= (ProcessState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHealth", wireType)
			}
			m.ContainerHealth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ContainerHealth |= (ContainerHealth(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerRbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ContainerRbps = float32(math.Float32frombits(v))
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerWbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ContainerWbps = float32(math.Float32frombits(v))
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IoStat == nil {
				m.IoStat = &IOStat{}
			}
			if err := m.IoStat.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Os == nil {
				m.Os = &OSInfo{}
			}
			if err := m.Os.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpus = append(m.Cpus, &CPUInfo{})
			if err := m.Cpus[len(m.Cpus)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemory", wireType)
			}
			m.TotalMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalMemory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Family = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connection) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Connection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Connection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Pid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fd", wireType)
			}
			m.Fd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Fd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Family |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Laddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Laddr == nil {
				m.Laddr = &Addr{}
			}
			if err := m.Laddr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Raddr == nil {
				m.Raddr = &Addr{}
			}
			if err := m.Raddr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Addr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Addr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Addr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Port |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rss", wireType)
			}
			m.Rss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rss |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vms", wireType)
			}
			m.Vms = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Vms |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			m.Swap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Swap |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shared", wireType)
			}
			m.Shared = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Shared |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			m.Text = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Text |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lib", wireType)
			}
			m.Lib = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Lib |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			m.Data = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Data |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dirty", wireType)
			}
			m.Dirty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Dirty |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IOStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IOStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IOStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadCount", wireType)
			}
			m.ReadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReadCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteCount", wireType)
			}
			m.WriteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.WriteCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBytes", wireType)
			}
			m.ReadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReadBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteBytes", wireType)
			}
			m.WriteBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.WriteBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCpu", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastCpu = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.TotalPct = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.UserPct = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.SystemPct = float32(math.Float32frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumThreads", wireType)
			}
			m.NumThreads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NumThreads |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpus = append(m.Cpus, &SingleCPUStat{})
			if err := m.Cpus[len(m.Cpus)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nice", wireType)
			}
			m.Nice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Nice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserTime", wireType)
			}
			m.UserTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UserTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemTime", wireType)
			}
			m.SystemTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SystemTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleCPUStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleCPUStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleCPUStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.TotalPct = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Number |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Family = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoreId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cores", wireType)
			}
			m.Cores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Cores |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mhz", wireType)
			}
			m.Mhz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Mhz |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheSize", wireType)
			}
			m.CacheSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CacheSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Host) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Host: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Host: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			m.OrgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OrgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &HostTags{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllTags = append(m.AllTags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCpus", wireType)
			}
			m.NumCpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NumCpus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemory", wireType)
			}
			m.TotalMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalMemory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostTags) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostTags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostTags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			m.SourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SourceType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAgent(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAgent
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAgent(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAgent = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAgent   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("agent.proto", fileDescriptorAgent) }

var fileDescriptorAgent = []byte{
	// 1916 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0x41, 0x6f, 0xe4, 0x58,
	0x11, 0x1e, 0xbb, 0xed, 0xee, 0x76, 0x75, 0x92, 0xed, 0x79, 0x1a, 0x56, 0xad, 0xb0, 0x84, 0xac,
	0x59, 0x50, 0x18, 0x69, 0x32, 0x4b, 0x96, 0x45, 0xb3, 0x02, 0x0d, 0x30, 0x19, 0x2d, 0x13, 0xc1,
	0xec, 0x46, 0x2f, 0x19, 0x16, 0x2d, 0x87, 0xd5, 0x8b, 0xfd, 0xd2, 0x6d, 0xc5, 0xf6, 0x33, 0xf6,
	0x73, 0x66, 0x7a, 0xcf, 0xdc, 0xb8, 0xec, 0x85, 0x03, 0x07, 0x0e, 0x1c, 0x90, 0x38, 0x70, 0xe1,
	0x5f, 0x20, 0xb8, 0x70, 0xe0, 0xc0, 0x11, 0x0d, 0xe2, 0x4f, 0x70, 0x42, 0x55, 0xef, 0xd9, 0xed,
	0x4e, 0xd2, 0x99, 0xcc, 0x9e, 0x5c, 0x55, 0xaf, 0xea, 0xbd, 0xea, 0xaa, 0xaf, 0xea, 0xd5, 0x6b,
	0x18, 0x89, 0xa9, 0xcc, 0xf5, 0x6e, 0x51, 0x2a, 0xad, 0xd8, 0x57, 0x62, 0xa1, 0x45, 0xac, 0xa6,
	0xc8, 0x46, 0xb2, 0xaa, 0x3e, 0xa3, 0xc5, 0xcd, 0xef, 0x4e, 0x13, 0x3d, 0xab, 0x4f, 0x76, 0x23,
	0x95, 0xdd, 0x7f, 0x2c, 0xb4, 0x78, 0xac, 0xa6, 0xf7, 0x69, 0xe5, 0x5e, 0x21, 0xe6, 0xa9, 0x12,
	0xb1, 0xe1, 0x3e, 0xb3, 0x9c, 0xd9, 0x2c, 0xfc, 0x9b, 0x03, 0x6b, 0x5c, 0x56, 0xfb, 0x2a, 0x4d,
	0x65, 0xa4, 0x55, 0xc9, 0x1e, 0x41, 0x7f, 0x26, 0x45, 0x2c, 0xcb, 0x89, 0xb3, 0xed, 0xec, 0x8c,
	0xf6, 0xee, 0xee, 0x5e, 0x79, 0xdc, 0x6e, 0xd7, 0x68, 0xf7, 0x09, 0x59, 0x70, 0x6b, 0xc9, 0x26,
	0x30, 0xc8, 0x64, 0x55, 0x89, 0xa9, 0x9c, 0xb8, 0xdb, 0xce, 0x4e, 0xc0, 0x1b, 0x96, 0x3d, 0x84,
	0x7e, 0xa5, 0x85, 0xae, 0xab, 0x49, 0x8f, 0x76, 0xff, 0xd6, 0x8a, 0xdd, 0xdb, 0xad, 0x8f, 0x48,
	0x9b, 0x5b, 0xab, 0xcd, 0xb7, 0xa0, 0x6f, 0xce, 0x62, 0x0c, 0x3c, 0x3d, 0x2f, 0xe4, 0xc4, 0xdb,
	0x76, 0x76, 0x7c, 0x4e, 0x74, 0xf8, 0x4f, 0x17, 0xd6, 0x5b, 0xcb, 0xc3, 0x52, 0x45, 0x6c, 0x13,
	0x86, 0x33, 0x55, 0xe9, 0x8f, 0x44, 0xd6, 0xb8, 0xd2, 0xf2, 0xec, 0x07, 0x10, 0xd8, 0x43, 0x25,
	0xba, 0xd3, 0xdb, 0x19, 0xed, 0x6d, 0xad, 0x70, 0xe7, 0xd0, 0x70, 0x7c, 0x61, 0xc0, 0xee, 0x83,
	0x87, 0x3b, 0xd1, 0xf9, 0xa3, 0xbd, 0xaf, 0xae, 0x30, 0x7c, 0xa2, 0x2a, 0xcd, 0x49, 0x91, 0xbd,
	0x0f, 0x5e, 0x92, 0x9f, 0xaa, 0x89, 0x4f, 0x06, 0x6f, 0xaf, 0x30, 0x38, 0x9a, 0x57, 0x5a, 0x66,
	0x07, 0xf9, 0xa9, 0xe2, 0xa4, 0x8e, 0xb1, 0x9c, 0x96, 0xaa, 0x2e, 0x0e, 0xe2, 0x49, 0x9f, 0x7e,
	0x6a, 0xc3, 0xb2, 0xb7, 0x20, 0x20, 0xf2, 0x28, 0xf9, 0x5c, 0x4e, 0x06, 0xb4, 0xb6, 0x10, 0xb0,
	0x03, 0x80, 0xb3, 0xfa, 0x44, 0x96, 0xb9, 0xd4, 0xb2, 0x9a, 0x0c, 0xe9, 0xd0, 0x6f, 0xb7, 0x87,
	0xd2, 0x61, 0x0d, 0x12, 0x7e, 0x5a, 0x9f, 0xc8, 0xa7, 0x52, 0x0b, 0x5c, 0x3c, 0x34, 0x32, 0xde,
	0x31, 0x0e, 0xff, 0xe4, 0xc0, 0x9d, 0x36, 0xac, 0xfb, 0x2a, 0xcf, 0x65, 0xa4, 0x13, 0x95, 0x57,
	0xd7, 0x46, 0x77, 0x1f, 0x46, 0xd1, 0x42, 0xd5, 0xc6, 0xf7, 0xed, 0x95, 0xe9, 0x6e, 0x34, 0x79,
	0xd7, 0xea, 0xb5, 0x83, 0x1c, 0xfe, 0xc6, 0x85, 0xdb, 0xad, 0xab, 0x5c, 0x8a, 0xf4, 0x38, 0xc9,
	0xe4, 0xb5, 0x7e, 0x3e, 0x00, 0x1f, 0xb1, 0xd5, 0x78, 0x18, 0x5e, 0x8f, 0x00, 0x84, 0x23, 0x37,
	0x06, 0xec, 0x4d, 0xe8, 0xe3, 0x2e, 0x07, 0xb1, 0xc5, 0xa0, 0xe5, 0xd8, 0x1d, 0xf0, 0x55, 0x39,
	0x3d, 0x88, 0x29, 0xd3, 0x3e, 0x37, 0xcc, 0x97, 0xce, 0xe3, 0x04, 0x06, 0x79, 0x9d, 0xed, 0x17,
	0xb5, 0x49, 0xa2, 0xcf, 0x1b, 0x96, 0x6d, 0xc3, 0x48, 0x2b, 0x2d, 0xd2, 0xa7, 0x32, 0x53, 0xe5,
	0x7c, 0x12, 0x6c, 0x3b, 0x3b, 0x3d, 0xde, 0x15, 0x85, 0xef, 0x02, 0xeb, 0x04, 0xe3, 0x57, 0xa6,
	0x96, 0xae, 0x8b, 0x46, 0x78, 0x04, 0x6f, 0x5c, 0x28, 0x3d, 0xf6, 0x0e, 0xac, 0x8b, 0x48, 0x27,
	0xe7, 0x72, 0x3f, 0x4d, 0x64, 0xae, 0x2b, 0xea, 0x0b, 0x3e, 0x5f, 0x16, 0xe2, 0xa6, 0x49, 0xae,
	0x65, 0x79, 0x2e, 0x52, 0xda, 0xd4, 0xe7, 0x2d, 0x1f, 0xfe, 0xc5, 0x83, 0x81, 0x8d, 0x1f, 0x1b,
	0x43, 0xef, 0x4c, 0xce, 0x69, 0x8f, 0x75, 0x8e, 0x24, 0x4a, 0x8a, 0x24, 0xb6, 0x46, 0x48, 0xb6,
	0x59, 0xef, 0xdd, 0xb4, 0xb4, 0x1e, 0xc0, 0x20, 0x52, 0x59, 0x26, 0xf2, 0xd8, 0x22, 0x65, 0x6b,
	0x25, 0xce, 0x48, 0x8b, 0x37, 0xea, 0xec, 0x7b, 0xe0, 0xd5, 0x95, 0x2c, 0x6d, 0x51, 0xbe, 0x22,
	0xf9, 0xcf, 0x2a, 0x59, 0x72, 0xd2, 0x67, 0x1f, 0x40, 0x3f, 0x33, 0x61, 0x1f, 0x5c, 0x5b, 0xce,
	0x26, 0x11, 0x84, 0x1a, 0x6b, 0xc0, 0xde, 0x85, 0x5e, 0x54, 0xd4, 0xb6, 0x22, 0x57, 0x3a, 0x7a,
	0xf8, 0x8c, 0x8c, 0x50, 0x95, 0x6d, 0x01, 0x44, 0xa5, 0x14, 0x5a, 0x22, 0x98, 0x6d, 0x9e, 0x3b,
	0x12, 0xf6, 0x10, 0x82, 0x48, 0xe5, 0x5a, 0x24, 0xb9, 0x2c, 0x27, 0x40, 0xfb, 0x6e, 0xaf, 0x2e,
	0x34, 0xa3, 0xc7, 0x17, 0x26, 0x08, 0x24, 0x55, 0xc8, 0xfc, 0xc3, 0x78, 0x5f, 0xd5, 0xb9, 0x9e,
	0x8c, 0x28, 0x13, 0x5d, 0x11, 0xfb, 0xc0, 0x14, 0x89, 0x9c, 0xac, 0x6d, 0x3b, 0x3b, 0x1b, 0x7b,
	0xdf, 0x78, 0x75, 0x91, 0x48, 0x53, 0x25, 0x92, 0xbd, 0x0f, 0xfd, 0x44, 0xa1, 0x64, 0xb2, 0x4e,
	0x9e, 0x7d, 0x6d, 0x85, 0xed, 0xc1, 0xc7, 0x26, 0x4a, 0x46, 0x39, 0xfc, 0x9d, 0x03, 0x03, 0x9b,
	0x2d, 0x6c, 0xf5, 0xa2, 0x9c, 0x22, 0xf0, 0x7a, 0x3b, 0x01, 0x27, 0x1a, 0x51, 0x13, 0x3d, 0x8f,
	0x09, 0x22, 0x01, 0x47, 0x12, 0xb5, 0x4a, 0xa5, 0x4c, 0xaf, 0x08, 0x38, 0xd1, 0x58, 0xa2, 0x2a,
	0x7f, 0x9c, 0x54, 0x67, 0x94, 0xe0, 0x21, 0xb7, 0x1c, 0xea, 0x16, 0x08, 0x3a, 0x53, 0x89, 0x44,
	0xa3, 0x6e, 0x41, 0x65, 0x67, 0x6b, 0xd0, 0x72, 0x78, 0x92, 0x7c, 0x21, 0x29, 0x5f, 0x01, 0x47,
	0x32, 0xfc, 0xad, 0x03, 0xa3, 0x0e, 0x24, 0x70, 0xb7, 0x1c, 0x8b, 0xc9, 0x31, 0x27, 0x23, 0x8d,
	0x56, 0xf5, 0x02, 0xd5, 0x75, 0x12, 0xa3, 0x64, 0x9a, 0x18, 0x8f, 0x7d, 0x8e, 0x24, 0xda, 0x49,
	0x54, 0xb2, 0x57, 0x18, 0xd2, 0x24, 0x43, 0x35, 0xdf, 0xca, 0xac, 0x5e, 0x55, 0x2f, 0xbc, 0xad,
	0xac, 0x5e, 0x85, 0x7a, 0x03, 0x2b, 0x9b, 0x26, 0x71, 0xf8, 0x3f, 0x17, 0x82, 0x36, 0xc1, 0xed,
	0x05, 0x69, 0xbd, 0x42, 0x9a, 0x6d, 0x80, 0x6b, 0x9d, 0x0a, 0xb8, 0x6b, 0x76, 0x21, 0xcf, 0x7b,
	0x1d, 0xcf, 0xef, 0x80, 0x9f, 0x64, 0x78, 0x75, 0x9b, 0x40, 0x1a, 0x06, 0xeb, 0x3b, 0x2a, 0xea,
	0x9f, 0x25, 0x59, 0xa2, 0xc9, 0x37, 0x97, 0xb7, 0x3c, 0xe2, 0xc7, 0x60, 0xdb, 0x2c, 0xa3, 0x9b,
	0x1e, 0xef, 0x8a, 0xd8, 0xf7, 0x1b, 0xfc, 0x0c, 0x09, 0x3f, 0xdf, 0x7c, 0x15, 0x3a, 0x97, 0x10,
	0xf4, 0x90, 0x26, 0x92, 0x54, 0xcf, 0x08, 0xfa, 0x1b, 0xd7, 0xcc, 0x0c, 0xd6, 0xfa, 0x09, 0x69,
	0x73, 0x6b, 0x85, 0x1d, 0xd4, 0x14, 0x4b, 0x4c, 0xc5, 0xd1, 0xe3, 0x0d, 0x8b, 0xad, 0xad, 0xad,
	0x02, 0x7e, 0x52, 0x54, 0x04, 0x7d, 0x97, 0x2f, 0x0b, 0x97, 0xb4, 0x3e, 0x41, 0xad, 0xb5, 0x0b,
	0x5a, 0x28, 0x0c, 0x7f, 0xef, 0xb7, 0xa0, 0x40, 0xef, 0x9b, 0xb6, 0xe6, 0x2c, 0xda, 0xda, 0x72,
	0x19, 0xbb, 0x97, 0xca, 0x78, 0xd1, 0x53, 0x7a, 0x5f, 0xb2, 0xa7, 0x78, 0x37, 0xef, 0x29, 0x98,
	0xf9, 0x24, 0x92, 0x0d, 0xce, 0x90, 0xc6, 0x40, 0xe9, 0x59, 0x29, 0x45, 0x5c, 0x59, 0x58, 0x35,
	0xec, 0xc5, 0x0e, 0x31, 0xbc, 0xdc, 0x21, 0x6c, 0x5f, 0x0f, 0x16, 0x7d, 0x7d, 0x9b, 0x06, 0x00,
	0x13, 0xa1, 0x03, 0x13, 0xfa, 0x80, 0x77, 0x45, 0xec, 0x29, 0x6c, 0x44, 0x4b, 0x19, 0xa7, 0xf8,
	0xdf, 0x18, 0x1e, 0x17, 0x8c, 0xd9, 0x4f, 0x60, 0xad, 0xe8, 0x34, 0xa0, 0xd7, 0xe9, 0x55, 0x4b,
	0x86, 0xec, 0x10, 0xde, 0x88, 0x96, 0xb1, 0x34, 0x79, 0xe3, 0xb5, 0x90, 0x77, 0xd1, 0xfc, 0x32,
	0xd0, 0xc6, 0x37, 0x02, 0xda, 0xed, 0x2b, 0x80, 0xd6, 0x69, 0xa8, 0xec, 0x75, 0x1a, 0xea, 0x1f,
	0x1d, 0x80, 0xc5, 0x70, 0x89, 0xf9, 0xaf, 0x6b, 0x8b, 0xcf, 0x80, 0x13, 0xcd, 0xee, 0x81, 0xab,
	0x2a, 0x02, 0xe6, 0xea, 0x5d, 0x3f, 0x3e, 0xa2, 0xd9, 0xd4, 0x55, 0x15, 0xdb, 0x03, 0x2f, 0x2a,
	0xea, 0x57, 0x8d, 0xce, 0xfb, 0x87, 0xcf, 0xcc, 0x34, 0x1b, 0x5d, 0x31, 0xb3, 0xf8, 0x97, 0x67,
	0x96, 0x2f, 0x1c, 0xe8, 0x9b, 0x43, 0xae, 0xec, 0xab, 0x9b, 0x30, 0x2c, 0x52, 0xa1, 0x4f, 0x55,
	0x99, 0x35, 0xc3, 0x4b, 0xc3, 0x63, 0x07, 0x3f, 0x15, 0x59, 0x92, 0xce, 0x6d, 0x3f, 0xb3, 0x1c,
	0xe2, 0xfa, 0x5c, 0x96, 0x55, 0xa2, 0x72, 0xdb, 0xd3, 0x1a, 0x16, 0x23, 0x7e, 0x86, 0x53, 0x6e,
	0xfa, 0x73, 0xbb, 0xee, 0xd3, 0xfa, 0xb2, 0x30, 0xfc, 0x97, 0x03, 0xb0, 0x98, 0x50, 0xaf, 0xa8,
	0xec, 0x0d, 0x70, 0x4f, 0x9b, 0x5e, 0xef, 0x9e, 0xc6, 0x17, 0x1c, 0xf1, 0x5b, 0x47, 0xae, 0x78,
	0xb3, 0xb0, 0xef, 0x80, 0x9f, 0x8a, 0x38, 0x6e, 0x46, 0x90, 0x55, 0xd3, 0xce, 0x8f, 0xe3, 0xb8,
	0xe4, 0x46, 0x13, 0x4d, 0x4a, 0x32, 0xe9, 0xdf, 0xc0, 0x84, 0x34, 0xd1, 0x23, 0xfb, 0xee, 0x1a,
	0x98, 0xd0, 0x18, 0x2e, 0xfc, 0x25, 0x78, 0xa8, 0xd6, 0x8e, 0x5c, 0xce, 0x4d, 0x47, 0x2e, 0xbc,
	0x49, 0x8a, 0xf6, 0x26, 0x29, 0xe8, 0x46, 0x55, 0xa5, 0xb6, 0x3f, 0x98, 0xe8, 0xf0, 0xcf, 0x0e,
	0xc0, 0xa2, 0x59, 0x61, 0xdc, 0xca, 0xca, 0x8c, 0x8f, 0x1e, 0x47, 0x12, 0x25, 0xe7, 0x99, 0x41,
	0x9c, 0xc7, 0x91, 0xa4, 0x6b, 0xed, 0xb9, 0x28, 0x68, 0x1b, 0x8f, 0x13, 0x4d, 0xbe, 0xcf, 0x44,
	0x29, 0xcd, 0x45, 0xe9, 0x71, 0xcb, 0x51, 0x34, 0xe5, 0x0b, 0x73, 0x1d, 0x79, 0x9c, 0x68, 0xdc,
	0x31, 0x4d, 0x4e, 0xec, 0x15, 0x84, 0x24, 0x6a, 0xe1, 0x8f, 0xa1, 0xdf, 0xed, 0x71, 0xa2, 0xf1,
	0x8a, 0x8b, 0x93, 0x52, 0xcf, 0xa9, 0x91, 0x79, 0xdc, 0x30, 0xe1, 0xaf, 0x1d, 0xe8, 0x9b, 0xa2,
	0xc1, 0x91, 0x1c, 0x1b, 0x9f, 0xe9, 0x76, 0xc6, 0xe1, 0x85, 0x00, 0x1b, 0xf9, 0xf3, 0x32, 0xd1,
	0xd2, 0x2c, 0x1b, 0xef, 0x3b, 0x92, 0xc6, 0xfa, 0xd1, 0x5c, 0xcb, 0xca, 0xfe, 0x92, 0x85, 0xa0,
	0xb5, 0x36, 0xcb, 0x5e, 0xc7, 0x9a, 0x24, 0xe1, 0x1f, 0x5c, 0x18, 0xd8, 0x56, 0x8d, 0xc8, 0x4d,
	0x45, 0xa5, 0xf7, 0x8b, 0xda, 0x16, 0x41, 0xc3, 0x62, 0x1d, 0x50, 0xd5, 0x1c, 0x46, 0xc6, 0x03,
	0x97, 0xb7, 0x3c, 0x5a, 0xe1, 0x90, 0x8a, 0x4b, 0x3d, 0x5a, 0x6a, 0x58, 0xf4, 0xac, 0xa2, 0x1e,
	0x80, 0x6b, 0x1e, 0xad, 0x2d, 0x04, 0xe8, 0x59, 0x5e, 0x67, 0xc7, 0xf6, 0x0a, 0x30, 0x37, 0x43,
	0x47, 0xc2, 0x1e, 0xd8, 0x82, 0xef, 0x53, 0xc1, 0xbf, 0xb3, 0xea, 0x05, 0x9b, 0xe4, 0xd3, 0x54,
	0x36, 0x97, 0x8d, 0x29, 0xfb, 0xe6, 0xb6, 0x19, 0x74, 0x6e, 0x9b, 0x4d, 0x18, 0xa2, 0x5b, 0x74,
	0x19, 0x0e, 0xa9, 0x0f, 0xb4, 0x3c, 0x7a, 0x62, 0xdc, 0xea, 0x4e, 0xbc, 0x0b, 0x49, 0xf8, 0x43,
	0x58, 0x5f, 0x3a, 0x66, 0x55, 0xab, 0x58, 0x15, 0xa2, 0xf0, 0xbf, 0x0e, 0x05, 0x99, 0xda, 0xcc,
	0x9b, 0xd0, 0xcf, 0xeb, 0xec, 0xc4, 0xfe, 0xe3, 0xe1, 0x73, 0xcb, 0xa1, 0xfc, 0x5c, 0xe6, 0xb1,
	0x2a, 0x2d, 0xcc, 0x2d, 0xb7, 0xb2, 0xcd, 0xdc, 0x01, 0x3f, 0x53, 0xb1, 0x4c, 0x9b, 0xc1, 0x89,
	0x18, 0xfc, 0x29, 0xc5, 0x6c, 0x5e, 0x25, 0x91, 0x48, 0xed, 0x93, 0x30, 0xe0, 0x1d, 0x09, 0xee,
	0x16, 0xa9, 0x52, 0xda, 0x67, 0x61, 0xc0, 0x2d, 0x87, 0xbb, 0x21, 0xd5, 0x5c, 0xc5, 0x86, 0x41,
	0x7c, 0x67, 0xb3, 0xcf, 0x6d, 0xbc, 0x90, 0xc4, 0x94, 0x46, 0x22, 0x9a, 0x49, 0x7a, 0x3d, 0x06,
	0xe6, 0xf5, 0xd8, 0x0a, 0xc2, 0xbf, 0x3b, 0xe0, 0x3d, 0x69, 0xea, 0xb5, 0xe9, 0x59, 0x38, 0xf9,
	0xb5, 0x8f, 0x54, 0xb7, 0xfb, 0x48, 0xbd, 0x6a, 0x1e, 0x7c, 0x0f, 0x3c, 0x2d, 0xa6, 0x88, 0x54,
	0xcc, 0xfa, 0xd7, 0xaf, 0x69, 0x0d, 0xc7, 0x62, 0x5a, 0x71, 0x52, 0x46, 0x08, 0x8a, 0x34, 0x45,
	0x01, 0xa1, 0x25, 0xe0, 0x0d, 0xdb, 0x7d, 0xcf, 0x0e, 0xae, 0x7d, 0xcf, 0x0e, 0x2f, 0xdf, 0x0d,
	0x0f, 0x61, 0xd8, 0x9c, 0x43, 0x10, 0x51, 0x75, 0x19, 0xc9, 0xe3, 0x66, 0xc8, 0x5d, 0xe7, 0x1d,
	0x09, 0x75, 0x07, 0x3c, 0xde, 0x35, 0x8f, 0x06, 0xa4, 0xef, 0x26, 0xb0, 0xb1, 0x3c, 0x43, 0xb0,
	0x11, 0x0c, 0xea, 0xfc, 0x2c, 0x57, 0xcf, 0xf3, 0xf1, 0x2d, 0x64, 0xec, 0x64, 0x38, 0x76, 0xd8,
	0x06, 0x40, 0x29, 0x2b, 0x2d, 0x4a, 0x9d, 0xe4, 0xd3, 0xb1, 0x8b, 0x8b, 0x65, 0x9d, 0xe7, 0xc8,
	0xf4, 0x18, 0x40, 0xbf, 0x10, 0x75, 0x25, 0xe3, 0xb1, 0x87, 0xb4, 0x7c, 0x91, 0xa0, 0x91, 0xcf,
	0x86, 0xe0, 0xc5, 0x52, 0xc4, 0xe3, 0xfe, 0xdd, 0x8f, 0xf0, 0x21, 0xbd, 0x3c, 0x04, 0xdc, 0x86,
	0x75, 0x7b, 0x96, 0x11, 0x8c, 0x6f, 0xb1, 0x35, 0x18, 0xb6, 0x47, 0x38, 0x78, 0x84, 0x19, 0x59,
	0xe7, 0x63, 0x97, 0xad, 0x43, 0x50, 0xe7, 0x0d, 0xdb, 0xbb, 0xfb, 0x21, 0xac, 0x75, 0x27, 0x16,
	0xe6, 0x83, 0xf3, 0x6c, 0x7c, 0x0b, 0x3f, 0x8f, 0xc7, 0x0e, 0x7e, 0xf8, 0xd8, 0xc5, 0xcf, 0xd1,
	0xb8, 0x87, 0x9f, 0xe3, 0xb1, 0x87, 0x9f, 0x4f, 0xc6, 0x3e, 0x7e, 0x7e, 0x31, 0xee, 0xe3, 0xe7,
	0xd3, 0xf1, 0xe0, 0xd1, 0x8f, 0xfe, 0xfa, 0x72, 0xcb, 0xf9, 0xc7, 0xcb, 0x2d, 0xe7, 0xdf, 0x2f,
	0xb7, 0x9c, 0x2f, 0xfe, 0xb3, 0x75, 0xeb, 0xd3, 0xdd, 0x2b, 0xfe, 0x37, 0xb4, 0x39, 0xbe, 0x67,
	0x73, 0x7c, 0x8f, 0x72, 0x7c, 0x9f, 0x00, 0x7d, 0xd2, 0xa7, 0x3f, 0x0e, 0xdf, 0xfb, 0x7f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x46, 0x6a, 0x1c, 0x7b, 0x94, 0x14, 0x00, 0x00,
}
