// Code generated by protoc-gen-gogo.
// source: primitives/primitives.proto
// DO NOT EDIT!

/*
	Package primitives is a generated protocol buffer package.

	It is generated from these files:
		primitives/primitives.proto

	It has these top-level messages:
		CollectorStatus
		Process
		Command
		ProcessUser
		Container
		ProcessStat
		ContainerStat
		SystemInfo
		OSInfo
		IOStat
		Connection
		Addr
		MemoryStat
		CPUStat
		SingleCPUStat
		CPUInfo
		Host
		HostTags
*/
package primitives

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// status section in https://docs.docker.com/engine/api/v1.29/#tag/Container
type ContainerState int32

const (
	ContainerState_unknown    ContainerState = 0
	ContainerState_created    ContainerState = 1
	ContainerState_restarting ContainerState = 2
	ContainerState_running    ContainerState = 3
	ContainerState_paused     ContainerState = 4
	ContainerState_exited     ContainerState = 5
	ContainerState_dead       ContainerState = 6
)

var ContainerState_name = map[int32]string{
	0: "unknown",
	1: "created",
	2: "restarting",
	3: "running",
	4: "paused",
	5: "exited",
	6: "dead",
}
var ContainerState_value = map[string]int32{
	"unknown":    0,
	"created":    1,
	"restarting": 2,
	"running":    3,
	"paused":     4,
	"exited":     5,
	"dead":       6,
}

func (x ContainerState) String() string {
	return proto.EnumName(ContainerState_name, int32(x))
}
func (ContainerState) EnumDescriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{0} }

// https://blog.couchbase.com/docker-health-check-keeping-containers-healthy/
// health can be: starting, healthy, unhealthy
type ContainerHealth int32

const (
	ContainerHealth_unknownHealth ContainerHealth = 0
	ContainerHealth_starting      ContainerHealth = 1
	ContainerHealth_healthy       ContainerHealth = 2
	ContainerHealth_unhealthy     ContainerHealth = 3
)

var ContainerHealth_name = map[int32]string{
	0: "unknownHealth",
	1: "starting",
	2: "healthy",
	3: "unhealthy",
}
var ContainerHealth_value = map[string]int32{
	"unknownHealth": 0,
	"starting":      1,
	"healthy":       2,
	"unhealthy":     3,
}

func (x ContainerHealth) String() string {
	return proto.EnumName(ContainerHealth_name, int32(x))
}
func (ContainerHealth) EnumDescriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{1} }

// Process state codes in http://wiki.preshweb.co.uk/doku.php?id=linux:psflags
type ProcessState int32

const (
	ProcessState_U ProcessState = 0
	ProcessState_D ProcessState = 1
	ProcessState_R ProcessState = 2
	ProcessState_S ProcessState = 3
	ProcessState_T ProcessState = 4
	ProcessState_W ProcessState = 5
	ProcessState_X ProcessState = 6
	ProcessState_Z ProcessState = 7
)

var ProcessState_name = map[int32]string{
	0: "U",
	1: "D",
	2: "R",
	3: "S",
	4: "T",
	5: "W",
	6: "X",
	7: "Z",
}
var ProcessState_value = map[string]int32{
	"U": 0,
	"D": 1,
	"R": 2,
	"S": 3,
	"T": 4,
	"W": 5,
	"X": 6,
	"Z": 7,
}

func (x ProcessState) String() string {
	return proto.EnumName(ProcessState_name, int32(x))
}
func (ProcessState) EnumDescriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{2} }

type ConnectionType int32

const (
	ConnectionType_tcp ConnectionType = 0
	ConnectionType_udp ConnectionType = 1
)

var ConnectionType_name = map[int32]string{
	0: "tcp",
	1: "udp",
}
var ConnectionType_value = map[string]int32{
	"tcp": 0,
	"udp": 1,
}

func (x ConnectionType) String() string {
	return proto.EnumName(ConnectionType_name, int32(x))
}
func (ConnectionType) EnumDescriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{3} }

type ConnectionFamily int32

const (
	ConnectionFamily_v4 ConnectionFamily = 0
	ConnectionFamily_v6 ConnectionFamily = 1
)

var ConnectionFamily_name = map[int32]string{
	0: "v4",
	1: "v6",
}
var ConnectionFamily_value = map[string]int32{
	"v4": 0,
	"v6": 1,
}

func (x ConnectionFamily) String() string {
	return proto.EnumName(ConnectionFamily_name, int32(x))
}
func (ConnectionFamily) EnumDescriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{4} }

type CollectorStatus struct {
	ActiveClients int32 `protobuf:"varint,1,opt,name=activeClients,proto3" json:"activeClients,omitempty"`
	Interval      int32 `protobuf:"varint,2,opt,name=interval,proto3" json:"interval,omitempty"`
}

func (m *CollectorStatus) Reset()                    { *m = CollectorStatus{} }
func (m *CollectorStatus) String() string            { return proto.CompactTextString(m) }
func (*CollectorStatus) ProtoMessage()               {}
func (*CollectorStatus) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{0} }

type Process struct {
	Key     uint32       `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Pid     int32        `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
	Host    *Host        `protobuf:"bytes,3,opt,name=host" json:"host,omitempty"`
	Command *Command     `protobuf:"bytes,4,opt,name=command" json:"command,omitempty"`
	User    *ProcessUser `protobuf:"bytes,5,opt,name=user" json:"user,omitempty"`
	// 6 is deprecated
	Memory                 *MemoryStat  `protobuf:"bytes,7,opt,name=memory" json:"memory,omitempty"`
	Cpu                    *CPUStat     `protobuf:"bytes,8,opt,name=cpu" json:"cpu,omitempty"`
	CreateTime             int64        `protobuf:"varint,9,opt,name=createTime,proto3" json:"createTime,omitempty"`
	Container              *Container   `protobuf:"bytes,10,opt,name=container" json:"container,omitempty"`
	OpenFdCount            int32        `protobuf:"varint,11,opt,name=openFdCount,proto3" json:"openFdCount,omitempty"`
	State                  ProcessState `protobuf:"varint,12,opt,name=state,proto3,enum=datadog.process_agent.primitives.ProcessState" json:"state,omitempty"`
	IoStat                 *IOStat      `protobuf:"bytes,13,opt,name=ioStat" json:"ioStat,omitempty"`
	ContainerId            string       `protobuf:"bytes,14,opt,name=containerId,proto3" json:"containerId,omitempty"`
	ContainerKey           uint32       `protobuf:"varint,15,opt,name=containerKey,proto3" json:"containerKey,omitempty"`
	VoluntaryCtxSwitches   uint64       `protobuf:"varint,16,opt,name=voluntaryCtxSwitches,proto3" json:"voluntaryCtxSwitches,omitempty"`
	InvoluntaryCtxSwitches uint64       `protobuf:"varint,17,opt,name=involuntaryCtxSwitches,proto3" json:"involuntaryCtxSwitches,omitempty"`
	ByteKey                []byte       `protobuf:"bytes,18,opt,name=byteKey,proto3" json:"byteKey,omitempty"`
	ContainerByteKey       []byte       `protobuf:"bytes,19,opt,name=containerByteKey,proto3" json:"containerByteKey,omitempty"`
}

func (m *Process) Reset()                    { *m = Process{} }
func (m *Process) String() string            { return proto.CompactTextString(m) }
func (*Process) ProtoMessage()               {}
func (*Process) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{1} }

func (m *Process) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *Process) GetCommand() *Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *Process) GetUser() *ProcessUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Process) GetMemory() *MemoryStat {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *Process) GetCpu() *CPUStat {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *Process) GetContainer() *Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *Process) GetIoStat() *IOStat {
	if m != nil {
		return m.IoStat
	}
	return nil
}

type Command struct {
	Args   []string `protobuf:"bytes,1,rep,name=args" json:"args,omitempty"`
	Cwd    string   `protobuf:"bytes,3,opt,name=cwd,proto3" json:"cwd,omitempty"`
	Root   string   `protobuf:"bytes,4,opt,name=root,proto3" json:"root,omitempty"`
	OnDisk bool     `protobuf:"varint,5,opt,name=onDisk,proto3" json:"onDisk,omitempty"`
	Ppid   int32    `protobuf:"varint,6,opt,name=ppid,proto3" json:"ppid,omitempty"`
	Pgroup int32    `protobuf:"varint,7,opt,name=pgroup,proto3" json:"pgroup,omitempty"`
	Exe    string   `protobuf:"bytes,8,opt,name=exe,proto3" json:"exe,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{2} }

type ProcessUser struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Uid  int32  `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	Gid  int32  `protobuf:"varint,3,opt,name=gid,proto3" json:"gid,omitempty"`
	Euid int32  `protobuf:"varint,4,opt,name=euid,proto3" json:"euid,omitempty"`
	Egid int32  `protobuf:"varint,5,opt,name=egid,proto3" json:"egid,omitempty"`
	Suid int32  `protobuf:"varint,6,opt,name=suid,proto3" json:"suid,omitempty"`
	Sgid int32  `protobuf:"varint,7,opt,name=sgid,proto3" json:"sgid,omitempty"`
}

func (m *ProcessUser) Reset()                    { *m = ProcessUser{} }
func (m *ProcessUser) String() string            { return proto.CompactTextString(m) }
func (*ProcessUser) ProtoMessage()               {}
func (*ProcessUser) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{3} }

type Container struct {
	Type        string  `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id          string  `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Name        string  `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Image       string  `protobuf:"bytes,4,opt,name=image,proto3" json:"image,omitempty"`
	CpuLimit    float32 `protobuf:"fixed32,5,opt,name=cpuLimit,proto3" json:"cpuLimit,omitempty"`
	MemoryLimit uint64  `protobuf:"varint,6,opt,name=memoryLimit,proto3" json:"memoryLimit,omitempty"`
	// 7 is removed, do not use.
	State      ContainerState  `protobuf:"varint,8,opt,name=state,proto3,enum=datadog.process_agent.primitives.ContainerState" json:"state,omitempty"`
	Health     ContainerHealth `protobuf:"varint,9,opt,name=health,proto3,enum=datadog.process_agent.primitives.ContainerHealth" json:"health,omitempty"`
	Created    int64           `protobuf:"varint,10,opt,name=created,proto3" json:"created,omitempty"`
	Rbps       float32         `protobuf:"fixed32,11,opt,name=rbps,proto3" json:"rbps,omitempty"`
	Wbps       float32         `protobuf:"fixed32,12,opt,name=wbps,proto3" json:"wbps,omitempty"`
	Key        uint32          `protobuf:"varint,13,opt,name=key,proto3" json:"key,omitempty"`
	NetRcvdPs  float32         `protobuf:"fixed32,14,opt,name=netRcvdPs,proto3" json:"netRcvdPs,omitempty"`
	NetSentPs  float32         `protobuf:"fixed32,15,opt,name=netSentPs,proto3" json:"netSentPs,omitempty"`
	NetRcvdBps float32         `protobuf:"fixed32,16,opt,name=netRcvdBps,proto3" json:"netRcvdBps,omitempty"`
	NetSentBps float32         `protobuf:"fixed32,17,opt,name=netSentBps,proto3" json:"netSentBps,omitempty"`
	UserPct    float32         `protobuf:"fixed32,18,opt,name=userPct,proto3" json:"userPct,omitempty"`
	SystemPct  float32         `protobuf:"fixed32,19,opt,name=systemPct,proto3" json:"systemPct,omitempty"`
	TotalPct   float32         `protobuf:"fixed32,20,opt,name=totalPct,proto3" json:"totalPct,omitempty"`
	MemRss     uint64          `protobuf:"varint,21,opt,name=memRss,proto3" json:"memRss,omitempty"`
	MemCache   uint64          `protobuf:"varint,22,opt,name=memCache,proto3" json:"memCache,omitempty"`
	Host       *Host           `protobuf:"bytes,23,opt,name=host" json:"host,omitempty"`
	Started    int64           `protobuf:"varint,24,opt,name=started,proto3" json:"started,omitempty"`
	ByteKey    []byte          `protobuf:"bytes,25,opt,name=byteKey,proto3" json:"byteKey,omitempty"`
	Tags       []string        `protobuf:"bytes,26,rep,name=tags" json:"tags,omitempty"`
}

func (m *Container) Reset()                    { *m = Container{} }
func (m *Container) String() string            { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()               {}
func (*Container) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{4} }

func (m *Container) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

// ProcessStat is used for real-time process messages. It should only contain
// data that can change for a running process (and relevant information to
// generate a key). We will send a lot of these in the real-time messages so
// it's critical to keep this small.
type ProcessStat struct {
	Pid int32 `protobuf:"varint,1,opt,name=pid,proto3" json:"pid,omitempty"`
	// In milliseconds
	CreateTime  int64       `protobuf:"varint,2,opt,name=createTime,proto3" json:"createTime,omitempty"`
	Memory      *MemoryStat `protobuf:"bytes,3,opt,name=memory" json:"memory,omitempty"`
	Cpu         *CPUStat    `protobuf:"bytes,4,opt,name=cpu" json:"cpu,omitempty"`
	Nice        int32       `protobuf:"varint,5,opt,name=nice,proto3" json:"nice,omitempty"`
	Threads     int32       `protobuf:"varint,7,opt,name=threads,proto3" json:"threads,omitempty"`
	OpenFdCount int32       `protobuf:"varint,8,opt,name=openFdCount,proto3" json:"openFdCount,omitempty"`
	Key         uint32      `protobuf:"varint,9,opt,name=key,proto3" json:"key,omitempty"`
	// we need container id because we need to do the scoring by container
	ContainerId    string         `protobuf:"bytes,10,opt,name=containerId,proto3" json:"containerId,omitempty"`
	ContainerState ContainerState `protobuf:"varint,11,opt,name=containerState,proto3,enum=datadog.process_agent.primitives.ContainerState" json:"containerState,omitempty"`
	ProcessState   ProcessState   `protobuf:"varint,12,opt,name=processState,proto3,enum=datadog.process_agent.primitives.ProcessState" json:"processState,omitempty"`
	IoStat         *IOStat        `protobuf:"bytes,19,opt,name=ioStat" json:"ioStat,omitempty"`
	// DEPRECATED: All container-level stats (except ID) have moved into ContainerStat.
	// These will be removed in the future.
	// These stats are from the container level but are stored per-process
	// because we don't send a container primitive yet.
	ContainerHealth        ContainerHealth `protobuf:"varint,15,opt,name=containerHealth,proto3,enum=datadog.process_agent.primitives.ContainerHealth" json:"containerHealth,omitempty"`
	ContainerRbps          float32         `protobuf:"fixed32,16,opt,name=containerRbps,proto3" json:"containerRbps,omitempty"`
	ContainerWbps          float32         `protobuf:"fixed32,17,opt,name=containerWbps,proto3" json:"containerWbps,omitempty"`
	ContainerKey           uint32          `protobuf:"varint,18,opt,name=containerKey,proto3" json:"containerKey,omitempty"`
	ContainerNetRcvdPs     float32         `protobuf:"fixed32,20,opt,name=containerNetRcvdPs,proto3" json:"containerNetRcvdPs,omitempty"`
	ContainerNetSentPs     float32         `protobuf:"fixed32,21,opt,name=containerNetSentPs,proto3" json:"containerNetSentPs,omitempty"`
	ContainerNetRcvdBps    float32         `protobuf:"fixed32,22,opt,name=containerNetRcvdBps,proto3" json:"containerNetRcvdBps,omitempty"`
	ContainerNetSentBps    float32         `protobuf:"fixed32,23,opt,name=containerNetSentBps,proto3" json:"containerNetSentBps,omitempty"`
	VoluntaryCtxSwitches   uint64          `protobuf:"varint,24,opt,name=voluntaryCtxSwitches,proto3" json:"voluntaryCtxSwitches,omitempty"`
	InvoluntaryCtxSwitches uint64          `protobuf:"varint,25,opt,name=involuntaryCtxSwitches,proto3" json:"involuntaryCtxSwitches,omitempty"`
	ByteKey                []byte          `protobuf:"bytes,26,opt,name=byteKey,proto3" json:"byteKey,omitempty"`
	ContainerByteKey       []byte          `protobuf:"bytes,27,opt,name=containerByteKey,proto3" json:"containerByteKey,omitempty"`
}

func (m *ProcessStat) Reset()                    { *m = ProcessStat{} }
func (m *ProcessStat) String() string            { return proto.CompactTextString(m) }
func (*ProcessStat) ProtoMessage()               {}
func (*ProcessStat) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{5} }

func (m *ProcessStat) GetMemory() *MemoryStat {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *ProcessStat) GetCpu() *CPUStat {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *ProcessStat) GetIoStat() *IOStat {
	if m != nil {
		return m.IoStat
	}
	return nil
}

// ContainerStat is used for real-time container messages. It should only contain
// data that can change for a running container (and relevant information to
// generate a key). We will send a lot of these in the real-time messages so
// it's critical to keep this small (basically no strings except ID)
type ContainerStat struct {
	Id         string          `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	UserPct    float32         `protobuf:"fixed32,2,opt,name=userPct,proto3" json:"userPct,omitempty"`
	SystemPct  float32         `protobuf:"fixed32,3,opt,name=systemPct,proto3" json:"systemPct,omitempty"`
	TotalPct   float32         `protobuf:"fixed32,4,opt,name=totalPct,proto3" json:"totalPct,omitempty"`
	CpuLimit   float32         `protobuf:"fixed32,5,opt,name=cpuLimit,proto3" json:"cpuLimit,omitempty"`
	MemRss     uint64          `protobuf:"varint,6,opt,name=memRss,proto3" json:"memRss,omitempty"`
	MemCache   uint64          `protobuf:"varint,7,opt,name=memCache,proto3" json:"memCache,omitempty"`
	MemLimit   uint64          `protobuf:"varint,8,opt,name=memLimit,proto3" json:"memLimit,omitempty"`
	Rbps       float32         `protobuf:"fixed32,9,opt,name=rbps,proto3" json:"rbps,omitempty"`
	Wbps       float32         `protobuf:"fixed32,10,opt,name=wbps,proto3" json:"wbps,omitempty"`
	NetRcvdPs  float32         `protobuf:"fixed32,11,opt,name=netRcvdPs,proto3" json:"netRcvdPs,omitempty"`
	NetSentPs  float32         `protobuf:"fixed32,12,opt,name=netSentPs,proto3" json:"netSentPs,omitempty"`
	NetRcvdBps float32         `protobuf:"fixed32,13,opt,name=netRcvdBps,proto3" json:"netRcvdBps,omitempty"`
	NetSentBps float32         `protobuf:"fixed32,14,opt,name=netSentBps,proto3" json:"netSentBps,omitempty"`
	State      ContainerState  `protobuf:"varint,15,opt,name=state,proto3,enum=datadog.process_agent.primitives.ContainerState" json:"state,omitempty"`
	Health     ContainerHealth `protobuf:"varint,16,opt,name=health,proto3,enum=datadog.process_agent.primitives.ContainerHealth" json:"health,omitempty"`
	// Post-resolved fields
	Key     uint32 `protobuf:"varint,17,opt,name=key,proto3" json:"key,omitempty"`
	Started int64  `protobuf:"varint,18,opt,name=started,proto3" json:"started,omitempty"`
	ByteKey []byte `protobuf:"bytes,19,opt,name=byteKey,proto3" json:"byteKey,omitempty"`
}

func (m *ContainerStat) Reset()                    { *m = ContainerStat{} }
func (m *ContainerStat) String() string            { return proto.CompactTextString(m) }
func (*ContainerStat) ProtoMessage()               {}
func (*ContainerStat) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{6} }

type SystemInfo struct {
	Uuid string     `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Os   *OSInfo    `protobuf:"bytes,2,opt,name=os" json:"os,omitempty"`
	Cpus []*CPUInfo `protobuf:"bytes,3,rep,name=cpus" json:"cpus,omitempty"`
	// 4 is deprecated
	TotalMemory int64 `protobuf:"varint,5,opt,name=totalMemory,proto3" json:"totalMemory,omitempty"`
}

func (m *SystemInfo) Reset()                    { *m = SystemInfo{} }
func (m *SystemInfo) String() string            { return proto.CompactTextString(m) }
func (*SystemInfo) ProtoMessage()               {}
func (*SystemInfo) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{7} }

func (m *SystemInfo) GetOs() *OSInfo {
	if m != nil {
		return m.Os
	}
	return nil
}

func (m *SystemInfo) GetCpus() []*CPUInfo {
	if m != nil {
		return m.Cpus
	}
	return nil
}

type OSInfo struct {
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Platform      string `protobuf:"bytes,2,opt,name=platform,proto3" json:"platform,omitempty"`
	Family        string `protobuf:"bytes,3,opt,name=family,proto3" json:"family,omitempty"`
	Version       string `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	KernelVersion string `protobuf:"bytes,5,opt,name=kernelVersion,proto3" json:"kernelVersion,omitempty"`
}

func (m *OSInfo) Reset()                    { *m = OSInfo{} }
func (m *OSInfo) String() string            { return proto.CompactTextString(m) }
func (*OSInfo) ProtoMessage()               {}
func (*OSInfo) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{8} }

type IOStat struct {
	ReadRate       float32 `protobuf:"fixed32,1,opt,name=readRate,proto3" json:"readRate,omitempty"`
	WriteRate      float32 `protobuf:"fixed32,2,opt,name=writeRate,proto3" json:"writeRate,omitempty"`
	ReadBytesRate  float32 `protobuf:"fixed32,3,opt,name=readBytesRate,proto3" json:"readBytesRate,omitempty"`
	WriteBytesRate float32 `protobuf:"fixed32,4,opt,name=writeBytesRate,proto3" json:"writeBytesRate,omitempty"`
}

func (m *IOStat) Reset()                    { *m = IOStat{} }
func (m *IOStat) String() string            { return proto.CompactTextString(m) }
func (*IOStat) ProtoMessage()               {}
func (*IOStat) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{9} }

type Connection struct {
	Pid int32 `protobuf:"varint,1,opt,name=pid,proto3" json:"pid,omitempty"`
	// 2 is deprecated
	// 3 is deprecated
	// 4 is deprecated
	Laddr *Addr `protobuf:"bytes,5,opt,name=laddr" json:"laddr,omitempty"`
	Raddr *Addr `protobuf:"bytes,6,opt,name=raddr" json:"raddr,omitempty"`
	// 7 is deprecated
	BytesSent     float32          `protobuf:"fixed32,8,opt,name=bytesSent,proto3" json:"bytesSent,omitempty"`
	BytesRecieved float32          `protobuf:"fixed32,9,opt,name=bytesRecieved,proto3" json:"bytesRecieved,omitempty"`
	Family        ConnectionFamily `protobuf:"varint,10,opt,name=family,proto3,enum=datadog.process_agent.primitives.ConnectionFamily" json:"family,omitempty"`
	Type          ConnectionType   `protobuf:"varint,11,opt,name=type,proto3,enum=datadog.process_agent.primitives.ConnectionType" json:"type,omitempty"`
	PidCreateTime int64            `protobuf:"varint,12,opt,name=pidCreateTime,proto3" json:"pidCreateTime,omitempty"`
}

func (m *Connection) Reset()                    { *m = Connection{} }
func (m *Connection) String() string            { return proto.CompactTextString(m) }
func (*Connection) ProtoMessage()               {}
func (*Connection) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{10} }

func (m *Connection) GetLaddr() *Addr {
	if m != nil {
		return m.Laddr
	}
	return nil
}

func (m *Connection) GetRaddr() *Addr {
	if m != nil {
		return m.Raddr
	}
	return nil
}

type Addr struct {
	Host *Host  `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	Ip   string `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
	Port int32  `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *Addr) Reset()                    { *m = Addr{} }
func (m *Addr) String() string            { return proto.CompactTextString(m) }
func (*Addr) ProtoMessage()               {}
func (*Addr) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{11} }

func (m *Addr) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

type MemoryStat struct {
	Rss    uint64 `protobuf:"varint,1,opt,name=rss,proto3" json:"rss,omitempty"`
	Vms    uint64 `protobuf:"varint,2,opt,name=vms,proto3" json:"vms,omitempty"`
	Swap   uint64 `protobuf:"varint,3,opt,name=swap,proto3" json:"swap,omitempty"`
	Shared uint64 `protobuf:"varint,4,opt,name=shared,proto3" json:"shared,omitempty"`
	Text   uint64 `protobuf:"varint,5,opt,name=text,proto3" json:"text,omitempty"`
	Lib    uint64 `protobuf:"varint,6,opt,name=lib,proto3" json:"lib,omitempty"`
	Data   uint64 `protobuf:"varint,7,opt,name=data,proto3" json:"data,omitempty"`
	Dirty  uint64 `protobuf:"varint,8,opt,name=dirty,proto3" json:"dirty,omitempty"`
}

func (m *MemoryStat) Reset()                    { *m = MemoryStat{} }
func (m *MemoryStat) String() string            { return proto.CompactTextString(m) }
func (*MemoryStat) ProtoMessage()               {}
func (*MemoryStat) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{12} }

type CPUStat struct {
	LastCpu    string           `protobuf:"bytes,1,opt,name=lastCpu,proto3" json:"lastCpu,omitempty"`
	TotalPct   float32          `protobuf:"fixed32,2,opt,name=totalPct,proto3" json:"totalPct,omitempty"`
	UserPct    float32          `protobuf:"fixed32,3,opt,name=userPct,proto3" json:"userPct,omitempty"`
	SystemPct  float32          `protobuf:"fixed32,4,opt,name=systemPct,proto3" json:"systemPct,omitempty"`
	NumThreads int32            `protobuf:"varint,5,opt,name=numThreads,proto3" json:"numThreads,omitempty"`
	Cpus       []*SingleCPUStat `protobuf:"bytes,6,rep,name=cpus" json:"cpus,omitempty"`
	Nice       int32            `protobuf:"varint,7,opt,name=nice,proto3" json:"nice,omitempty"`
	UserTime   int64            `protobuf:"varint,8,opt,name=userTime,proto3" json:"userTime,omitempty"`
	SystemTime int64            `protobuf:"varint,9,opt,name=systemTime,proto3" json:"systemTime,omitempty"`
}

func (m *CPUStat) Reset()                    { *m = CPUStat{} }
func (m *CPUStat) String() string            { return proto.CompactTextString(m) }
func (*CPUStat) ProtoMessage()               {}
func (*CPUStat) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{13} }

func (m *CPUStat) GetCpus() []*SingleCPUStat {
	if m != nil {
		return m.Cpus
	}
	return nil
}

type SingleCPUStat struct {
	Name     string  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	TotalPct float32 `protobuf:"fixed32,2,opt,name=totalPct,proto3" json:"totalPct,omitempty"`
}

func (m *SingleCPUStat) Reset()                    { *m = SingleCPUStat{} }
func (m *SingleCPUStat) String() string            { return proto.CompactTextString(m) }
func (*SingleCPUStat) ProtoMessage()               {}
func (*SingleCPUStat) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{14} }

type CPUInfo struct {
	Number     int32  `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	Vendor     string `protobuf:"bytes,2,opt,name=vendor,proto3" json:"vendor,omitempty"`
	Family     string `protobuf:"bytes,3,opt,name=family,proto3" json:"family,omitempty"`
	Model      string `protobuf:"bytes,4,opt,name=model,proto3" json:"model,omitempty"`
	PhysicalId string `protobuf:"bytes,5,opt,name=physicalId,proto3" json:"physicalId,omitempty"`
	CoreId     string `protobuf:"bytes,6,opt,name=coreId,proto3" json:"coreId,omitempty"`
	Cores      int32  `protobuf:"varint,7,opt,name=cores,proto3" json:"cores,omitempty"`
	Mhz        int64  `protobuf:"varint,8,opt,name=mhz,proto3" json:"mhz,omitempty"`
	CacheSize  int32  `protobuf:"varint,9,opt,name=cacheSize,proto3" json:"cacheSize,omitempty"`
}

func (m *CPUInfo) Reset()                    { *m = CPUInfo{} }
func (m *CPUInfo) String() string            { return proto.CompactTextString(m) }
func (*CPUInfo) ProtoMessage()               {}
func (*CPUInfo) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{15} }

type Host struct {
	Id          int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	OrgId       int32       `protobuf:"varint,2,opt,name=orgId,proto3" json:"orgId,omitempty"`
	Name        string      `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Tags        []*HostTags `protobuf:"bytes,4,rep,name=tags" json:"tags,omitempty"`
	AllTags     []string    `protobuf:"bytes,6,rep,name=allTags" json:"allTags,omitempty"`
	NumCpus     int32       `protobuf:"varint,7,opt,name=numCpus,proto3" json:"numCpus,omitempty"`
	TotalMemory int64       `protobuf:"varint,8,opt,name=totalMemory,proto3" json:"totalMemory,omitempty"`
}

func (m *Host) Reset()                    { *m = Host{} }
func (m *Host) String() string            { return proto.CompactTextString(m) }
func (*Host) ProtoMessage()               {}
func (*Host) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{16} }

func (m *Host) GetTags() []*HostTags {
	if m != nil {
		return m.Tags
	}
	return nil
}

type HostTags struct {
	SourceType uint32   `protobuf:"varint,1,opt,name=sourceType,proto3" json:"sourceType,omitempty"`
	Tags       []string `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty"`
}

func (m *HostTags) Reset()                    { *m = HostTags{} }
func (m *HostTags) String() string            { return proto.CompactTextString(m) }
func (*HostTags) ProtoMessage()               {}
func (*HostTags) Descriptor() ([]byte, []int) { return fileDescriptorPrimitives, []int{17} }

func init() {
	proto.RegisterType((*CollectorStatus)(nil), "datadog.process_agent.primitives.CollectorStatus")
	proto.RegisterType((*Process)(nil), "datadog.process_agent.primitives.Process")
	proto.RegisterType((*Command)(nil), "datadog.process_agent.primitives.Command")
	proto.RegisterType((*ProcessUser)(nil), "datadog.process_agent.primitives.ProcessUser")
	proto.RegisterType((*Container)(nil), "datadog.process_agent.primitives.Container")
	proto.RegisterType((*ProcessStat)(nil), "datadog.process_agent.primitives.ProcessStat")
	proto.RegisterType((*ContainerStat)(nil), "datadog.process_agent.primitives.ContainerStat")
	proto.RegisterType((*SystemInfo)(nil), "datadog.process_agent.primitives.SystemInfo")
	proto.RegisterType((*OSInfo)(nil), "datadog.process_agent.primitives.OSInfo")
	proto.RegisterType((*IOStat)(nil), "datadog.process_agent.primitives.IOStat")
	proto.RegisterType((*Connection)(nil), "datadog.process_agent.primitives.Connection")
	proto.RegisterType((*Addr)(nil), "datadog.process_agent.primitives.Addr")
	proto.RegisterType((*MemoryStat)(nil), "datadog.process_agent.primitives.MemoryStat")
	proto.RegisterType((*CPUStat)(nil), "datadog.process_agent.primitives.CPUStat")
	proto.RegisterType((*SingleCPUStat)(nil), "datadog.process_agent.primitives.SingleCPUStat")
	proto.RegisterType((*CPUInfo)(nil), "datadog.process_agent.primitives.CPUInfo")
	proto.RegisterType((*Host)(nil), "datadog.process_agent.primitives.Host")
	proto.RegisterType((*HostTags)(nil), "datadog.process_agent.primitives.HostTags")
	proto.RegisterEnum("datadog.process_agent.primitives.ContainerState", ContainerState_name, ContainerState_value)
	proto.RegisterEnum("datadog.process_agent.primitives.ContainerHealth", ContainerHealth_name, ContainerHealth_value)
	proto.RegisterEnum("datadog.process_agent.primitives.ProcessState", ProcessState_name, ProcessState_value)
	proto.RegisterEnum("datadog.process_agent.primitives.ConnectionType", ConnectionType_name, ConnectionType_value)
	proto.RegisterEnum("datadog.process_agent.primitives.ConnectionFamily", ConnectionFamily_name, ConnectionFamily_value)
}
func (m *CollectorStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ActiveClients != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.ActiveClients))
	}
	if m.Interval != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Interval))
	}
	return i, nil
}

func (m *Process) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Process) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Key))
	}
	if m.Pid != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Pid))
	}
	if m.Host != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Host.Size()))
		n1, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Command != nil {
		data[i] = 0x22
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Command.Size()))
		n2, err := m.Command.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.User != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.User.Size()))
		n3, err := m.User.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Memory != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Memory.Size()))
		n4, err := m.Memory.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Cpu != nil {
		data[i] = 0x42
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Cpu.Size()))
		n5, err := m.Cpu.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.CreateTime != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.CreateTime))
	}
	if m.Container != nil {
		data[i] = 0x52
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Container.Size()))
		n6, err := m.Container.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.OpenFdCount != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.OpenFdCount))
	}
	if m.State != 0 {
		data[i] = 0x60
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.State))
	}
	if m.IoStat != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.IoStat.Size()))
		n7, err := m.IoStat.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.ContainerId) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.ContainerId)))
		i += copy(data[i:], m.ContainerId)
	}
	if m.ContainerKey != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.ContainerKey))
	}
	if m.VoluntaryCtxSwitches != 0 {
		data[i] = 0x80
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.VoluntaryCtxSwitches))
	}
	if m.InvoluntaryCtxSwitches != 0 {
		data[i] = 0x88
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.InvoluntaryCtxSwitches))
	}
	if len(m.ByteKey) > 0 {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.ByteKey)))
		i += copy(data[i:], m.ByteKey)
	}
	if len(m.ContainerByteKey) > 0 {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.ContainerByteKey)))
		i += copy(data[i:], m.ContainerByteKey)
	}
	return i, nil
}

func (m *Command) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Command) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Cwd) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Cwd)))
		i += copy(data[i:], m.Cwd)
	}
	if len(m.Root) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Root)))
		i += copy(data[i:], m.Root)
	}
	if m.OnDisk {
		data[i] = 0x28
		i++
		if m.OnDisk {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Ppid != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Ppid))
	}
	if m.Pgroup != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Pgroup))
	}
	if len(m.Exe) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Exe)))
		i += copy(data[i:], m.Exe)
	}
	return i, nil
}

func (m *ProcessUser) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProcessUser) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.Uid != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Uid))
	}
	if m.Gid != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Gid))
	}
	if m.Euid != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Euid))
	}
	if m.Egid != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Egid))
	}
	if m.Suid != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Suid))
	}
	if m.Sgid != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Sgid))
	}
	return i, nil
}

func (m *Container) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Container) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Id) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Image) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Image)))
		i += copy(data[i:], m.Image)
	}
	if m.CpuLimit != 0 {
		data[i] = 0x2d
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.CpuLimit))))
	}
	if m.MemoryLimit != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.MemoryLimit))
	}
	if m.State != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.State))
	}
	if m.Health != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Health))
	}
	if m.Created != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Created))
	}
	if m.Rbps != 0 {
		data[i] = 0x5d
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.Rbps))))
	}
	if m.Wbps != 0 {
		data[i] = 0x65
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.Wbps))))
	}
	if m.Key != 0 {
		data[i] = 0x68
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Key))
	}
	if m.NetRcvdPs != 0 {
		data[i] = 0x75
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.NetRcvdPs))))
	}
	if m.NetSentPs != 0 {
		data[i] = 0x7d
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.NetSentPs))))
	}
	if m.NetRcvdBps != 0 {
		data[i] = 0x85
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.NetRcvdBps))))
	}
	if m.NetSentBps != 0 {
		data[i] = 0x8d
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.NetSentBps))))
	}
	if m.UserPct != 0 {
		data[i] = 0x95
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.UserPct))))
	}
	if m.SystemPct != 0 {
		data[i] = 0x9d
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.SystemPct))))
	}
	if m.TotalPct != 0 {
		data[i] = 0xa5
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.TotalPct))))
	}
	if m.MemRss != 0 {
		data[i] = 0xa8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.MemRss))
	}
	if m.MemCache != 0 {
		data[i] = 0xb0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.MemCache))
	}
	if m.Host != nil {
		data[i] = 0xba
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Host.Size()))
		n8, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Started != 0 {
		data[i] = 0xc0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Started))
	}
	if len(m.ByteKey) > 0 {
		data[i] = 0xca
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.ByteKey)))
		i += copy(data[i:], m.ByteKey)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0xd2
			i++
			data[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *ProcessStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProcessStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Pid))
	}
	if m.CreateTime != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.CreateTime))
	}
	if m.Memory != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Memory.Size()))
		n9, err := m.Memory.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Cpu != nil {
		data[i] = 0x22
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Cpu.Size()))
		n10, err := m.Cpu.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Nice != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Nice))
	}
	if m.Threads != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Threads))
	}
	if m.OpenFdCount != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.OpenFdCount))
	}
	if m.Key != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Key))
	}
	if len(m.ContainerId) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.ContainerId)))
		i += copy(data[i:], m.ContainerId)
	}
	if m.ContainerState != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.ContainerState))
	}
	if m.ProcessState != 0 {
		data[i] = 0x60
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.ProcessState))
	}
	if m.ContainerHealth != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.ContainerHealth))
	}
	if m.ContainerRbps != 0 {
		data[i] = 0x85
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.ContainerRbps))))
	}
	if m.ContainerWbps != 0 {
		data[i] = 0x8d
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.ContainerWbps))))
	}
	if m.ContainerKey != 0 {
		data[i] = 0x90
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.ContainerKey))
	}
	if m.IoStat != nil {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.IoStat.Size()))
		n11, err := m.IoStat.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.ContainerNetRcvdPs != 0 {
		data[i] = 0xa5
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.ContainerNetRcvdPs))))
	}
	if m.ContainerNetSentPs != 0 {
		data[i] = 0xad
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.ContainerNetSentPs))))
	}
	if m.ContainerNetRcvdBps != 0 {
		data[i] = 0xb5
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.ContainerNetRcvdBps))))
	}
	if m.ContainerNetSentBps != 0 {
		data[i] = 0xbd
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.ContainerNetSentBps))))
	}
	if m.VoluntaryCtxSwitches != 0 {
		data[i] = 0xc0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.VoluntaryCtxSwitches))
	}
	if m.InvoluntaryCtxSwitches != 0 {
		data[i] = 0xc8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.InvoluntaryCtxSwitches))
	}
	if len(m.ByteKey) > 0 {
		data[i] = 0xd2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.ByteKey)))
		i += copy(data[i:], m.ByteKey)
	}
	if len(m.ContainerByteKey) > 0 {
		data[i] = 0xda
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.ContainerByteKey)))
		i += copy(data[i:], m.ContainerByteKey)
	}
	return i, nil
}

func (m *ContainerStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ContainerStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if m.UserPct != 0 {
		data[i] = 0x15
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.UserPct))))
	}
	if m.SystemPct != 0 {
		data[i] = 0x1d
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.SystemPct))))
	}
	if m.TotalPct != 0 {
		data[i] = 0x25
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.TotalPct))))
	}
	if m.CpuLimit != 0 {
		data[i] = 0x2d
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.CpuLimit))))
	}
	if m.MemRss != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.MemRss))
	}
	if m.MemCache != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.MemCache))
	}
	if m.MemLimit != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.MemLimit))
	}
	if m.Rbps != 0 {
		data[i] = 0x4d
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.Rbps))))
	}
	if m.Wbps != 0 {
		data[i] = 0x55
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.Wbps))))
	}
	if m.NetRcvdPs != 0 {
		data[i] = 0x5d
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.NetRcvdPs))))
	}
	if m.NetSentPs != 0 {
		data[i] = 0x65
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.NetSentPs))))
	}
	if m.NetRcvdBps != 0 {
		data[i] = 0x6d
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.NetRcvdBps))))
	}
	if m.NetSentBps != 0 {
		data[i] = 0x75
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.NetSentBps))))
	}
	if m.State != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.State))
	}
	if m.Health != 0 {
		data[i] = 0x80
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Health))
	}
	if m.Key != 0 {
		data[i] = 0x88
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Key))
	}
	if m.Started != 0 {
		data[i] = 0x90
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Started))
	}
	if len(m.ByteKey) > 0 {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.ByteKey)))
		i += copy(data[i:], m.ByteKey)
	}
	return i, nil
}

func (m *SystemInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SystemInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Uuid)))
		i += copy(data[i:], m.Uuid)
	}
	if m.Os != nil {
		data[i] = 0x12
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Os.Size()))
		n12, err := m.Os.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Cpus) > 0 {
		for _, msg := range m.Cpus {
			data[i] = 0x1a
			i++
			i = encodeVarintPrimitives(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalMemory != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.TotalMemory))
	}
	return i, nil
}

func (m *OSInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OSInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Platform) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Platform)))
		i += copy(data[i:], m.Platform)
	}
	if len(m.Family) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Family)))
		i += copy(data[i:], m.Family)
	}
	if len(m.Version) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.KernelVersion) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.KernelVersion)))
		i += copy(data[i:], m.KernelVersion)
	}
	return i, nil
}

func (m *IOStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IOStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReadRate != 0 {
		data[i] = 0xd
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.ReadRate))))
	}
	if m.WriteRate != 0 {
		data[i] = 0x15
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.WriteRate))))
	}
	if m.ReadBytesRate != 0 {
		data[i] = 0x1d
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.ReadBytesRate))))
	}
	if m.WriteBytesRate != 0 {
		data[i] = 0x25
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.WriteBytesRate))))
	}
	return i, nil
}

func (m *Connection) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Connection) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Pid))
	}
	if m.Laddr != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Laddr.Size()))
		n13, err := m.Laddr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Raddr != nil {
		data[i] = 0x32
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Raddr.Size()))
		n14, err := m.Raddr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.BytesSent != 0 {
		data[i] = 0x45
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.BytesSent))))
	}
	if m.BytesRecieved != 0 {
		data[i] = 0x4d
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.BytesRecieved))))
	}
	if m.Family != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Family))
	}
	if m.Type != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Type))
	}
	if m.PidCreateTime != 0 {
		data[i] = 0x60
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.PidCreateTime))
	}
	return i, nil
}

func (m *Addr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Addr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Host != nil {
		data[i] = 0xa
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Host.Size()))
		n15, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Ip) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Ip)))
		i += copy(data[i:], m.Ip)
	}
	if m.Port != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Port))
	}
	return i, nil
}

func (m *MemoryStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MemoryStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rss != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Rss))
	}
	if m.Vms != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Vms))
	}
	if m.Swap != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Swap))
	}
	if m.Shared != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Shared))
	}
	if m.Text != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Text))
	}
	if m.Lib != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Lib))
	}
	if m.Data != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Data))
	}
	if m.Dirty != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Dirty))
	}
	return i, nil
}

func (m *CPUStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CPUStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LastCpu) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.LastCpu)))
		i += copy(data[i:], m.LastCpu)
	}
	if m.TotalPct != 0 {
		data[i] = 0x15
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.TotalPct))))
	}
	if m.UserPct != 0 {
		data[i] = 0x1d
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.UserPct))))
	}
	if m.SystemPct != 0 {
		data[i] = 0x25
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.SystemPct))))
	}
	if m.NumThreads != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.NumThreads))
	}
	if len(m.Cpus) > 0 {
		for _, msg := range m.Cpus {
			data[i] = 0x32
			i++
			i = encodeVarintPrimitives(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Nice != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Nice))
	}
	if m.UserTime != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.UserTime))
	}
	if m.SystemTime != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.SystemTime))
	}
	return i, nil
}

func (m *SingleCPUStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SingleCPUStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.TotalPct != 0 {
		data[i] = 0x15
		i++
		i = encodeFixed32Primitives(data, i, uint32(math.Float32bits(float32(m.TotalPct))))
	}
	return i, nil
}

func (m *CPUInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CPUInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Number != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Number))
	}
	if len(m.Vendor) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Vendor)))
		i += copy(data[i:], m.Vendor)
	}
	if len(m.Family) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Family)))
		i += copy(data[i:], m.Family)
	}
	if len(m.Model) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Model)))
		i += copy(data[i:], m.Model)
	}
	if len(m.PhysicalId) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.PhysicalId)))
		i += copy(data[i:], m.PhysicalId)
	}
	if len(m.CoreId) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.CoreId)))
		i += copy(data[i:], m.CoreId)
	}
	if m.Cores != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Cores))
	}
	if m.Mhz != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Mhz))
	}
	if m.CacheSize != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.CacheSize))
	}
	return i, nil
}

func (m *Host) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Host) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.Id))
	}
	if m.OrgId != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.OrgId))
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintPrimitives(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			data[i] = 0x22
			i++
			i = encodeVarintPrimitives(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AllTags) > 0 {
		for _, s := range m.AllTags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.NumCpus != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.NumCpus))
	}
	if m.TotalMemory != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.TotalMemory))
	}
	return i, nil
}

func (m *HostTags) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HostTags) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SourceType != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintPrimitives(data, i, uint64(m.SourceType))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func encodeFixed64Primitives(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Primitives(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintPrimitives(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *CollectorStatus) Size() (n int) {
	var l int
	_ = l
	if m.ActiveClients != 0 {
		n += 1 + sovPrimitives(uint64(m.ActiveClients))
	}
	if m.Interval != 0 {
		n += 1 + sovPrimitives(uint64(m.Interval))
	}
	return n
}

func (m *Process) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovPrimitives(uint64(m.Key))
	}
	if m.Pid != 0 {
		n += 1 + sovPrimitives(uint64(m.Pid))
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.CreateTime != 0 {
		n += 1 + sovPrimitives(uint64(m.CreateTime))
	}
	if m.Container != nil {
		l = m.Container.Size()
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.OpenFdCount != 0 {
		n += 1 + sovPrimitives(uint64(m.OpenFdCount))
	}
	if m.State != 0 {
		n += 1 + sovPrimitives(uint64(m.State))
	}
	if m.IoStat != nil {
		l = m.IoStat.Size()
		n += 1 + l + sovPrimitives(uint64(l))
	}
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.ContainerKey != 0 {
		n += 1 + sovPrimitives(uint64(m.ContainerKey))
	}
	if m.VoluntaryCtxSwitches != 0 {
		n += 2 + sovPrimitives(uint64(m.VoluntaryCtxSwitches))
	}
	if m.InvoluntaryCtxSwitches != 0 {
		n += 2 + sovPrimitives(uint64(m.InvoluntaryCtxSwitches))
	}
	l = len(m.ByteKey)
	if l > 0 {
		n += 2 + l + sovPrimitives(uint64(l))
	}
	l = len(m.ContainerByteKey)
	if l > 0 {
		n += 2 + l + sovPrimitives(uint64(l))
	}
	return n
}

func (m *Command) Size() (n int) {
	var l int
	_ = l
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovPrimitives(uint64(l))
		}
	}
	l = len(m.Cwd)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.OnDisk {
		n += 2
	}
	if m.Ppid != 0 {
		n += 1 + sovPrimitives(uint64(m.Ppid))
	}
	if m.Pgroup != 0 {
		n += 1 + sovPrimitives(uint64(m.Pgroup))
	}
	l = len(m.Exe)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	return n
}

func (m *ProcessUser) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovPrimitives(uint64(m.Uid))
	}
	if m.Gid != 0 {
		n += 1 + sovPrimitives(uint64(m.Gid))
	}
	if m.Euid != 0 {
		n += 1 + sovPrimitives(uint64(m.Euid))
	}
	if m.Egid != 0 {
		n += 1 + sovPrimitives(uint64(m.Egid))
	}
	if m.Suid != 0 {
		n += 1 + sovPrimitives(uint64(m.Suid))
	}
	if m.Sgid != 0 {
		n += 1 + sovPrimitives(uint64(m.Sgid))
	}
	return n
}

func (m *Container) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.CpuLimit != 0 {
		n += 5
	}
	if m.MemoryLimit != 0 {
		n += 1 + sovPrimitives(uint64(m.MemoryLimit))
	}
	if m.State != 0 {
		n += 1 + sovPrimitives(uint64(m.State))
	}
	if m.Health != 0 {
		n += 1 + sovPrimitives(uint64(m.Health))
	}
	if m.Created != 0 {
		n += 1 + sovPrimitives(uint64(m.Created))
	}
	if m.Rbps != 0 {
		n += 5
	}
	if m.Wbps != 0 {
		n += 5
	}
	if m.Key != 0 {
		n += 1 + sovPrimitives(uint64(m.Key))
	}
	if m.NetRcvdPs != 0 {
		n += 5
	}
	if m.NetSentPs != 0 {
		n += 5
	}
	if m.NetRcvdBps != 0 {
		n += 6
	}
	if m.NetSentBps != 0 {
		n += 6
	}
	if m.UserPct != 0 {
		n += 6
	}
	if m.SystemPct != 0 {
		n += 6
	}
	if m.TotalPct != 0 {
		n += 6
	}
	if m.MemRss != 0 {
		n += 2 + sovPrimitives(uint64(m.MemRss))
	}
	if m.MemCache != 0 {
		n += 2 + sovPrimitives(uint64(m.MemCache))
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 2 + l + sovPrimitives(uint64(l))
	}
	if m.Started != 0 {
		n += 2 + sovPrimitives(uint64(m.Started))
	}
	l = len(m.ByteKey)
	if l > 0 {
		n += 2 + l + sovPrimitives(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 2 + l + sovPrimitives(uint64(l))
		}
	}
	return n
}

func (m *ProcessStat) Size() (n int) {
	var l int
	_ = l
	if m.Pid != 0 {
		n += 1 + sovPrimitives(uint64(m.Pid))
	}
	if m.CreateTime != 0 {
		n += 1 + sovPrimitives(uint64(m.CreateTime))
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.Nice != 0 {
		n += 1 + sovPrimitives(uint64(m.Nice))
	}
	if m.Threads != 0 {
		n += 1 + sovPrimitives(uint64(m.Threads))
	}
	if m.OpenFdCount != 0 {
		n += 1 + sovPrimitives(uint64(m.OpenFdCount))
	}
	if m.Key != 0 {
		n += 1 + sovPrimitives(uint64(m.Key))
	}
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.ContainerState != 0 {
		n += 1 + sovPrimitives(uint64(m.ContainerState))
	}
	if m.ProcessState != 0 {
		n += 1 + sovPrimitives(uint64(m.ProcessState))
	}
	if m.ContainerHealth != 0 {
		n += 1 + sovPrimitives(uint64(m.ContainerHealth))
	}
	if m.ContainerRbps != 0 {
		n += 6
	}
	if m.ContainerWbps != 0 {
		n += 6
	}
	if m.ContainerKey != 0 {
		n += 2 + sovPrimitives(uint64(m.ContainerKey))
	}
	if m.IoStat != nil {
		l = m.IoStat.Size()
		n += 2 + l + sovPrimitives(uint64(l))
	}
	if m.ContainerNetRcvdPs != 0 {
		n += 6
	}
	if m.ContainerNetSentPs != 0 {
		n += 6
	}
	if m.ContainerNetRcvdBps != 0 {
		n += 6
	}
	if m.ContainerNetSentBps != 0 {
		n += 6
	}
	if m.VoluntaryCtxSwitches != 0 {
		n += 2 + sovPrimitives(uint64(m.VoluntaryCtxSwitches))
	}
	if m.InvoluntaryCtxSwitches != 0 {
		n += 2 + sovPrimitives(uint64(m.InvoluntaryCtxSwitches))
	}
	l = len(m.ByteKey)
	if l > 0 {
		n += 2 + l + sovPrimitives(uint64(l))
	}
	l = len(m.ContainerByteKey)
	if l > 0 {
		n += 2 + l + sovPrimitives(uint64(l))
	}
	return n
}

func (m *ContainerStat) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.UserPct != 0 {
		n += 5
	}
	if m.SystemPct != 0 {
		n += 5
	}
	if m.TotalPct != 0 {
		n += 5
	}
	if m.CpuLimit != 0 {
		n += 5
	}
	if m.MemRss != 0 {
		n += 1 + sovPrimitives(uint64(m.MemRss))
	}
	if m.MemCache != 0 {
		n += 1 + sovPrimitives(uint64(m.MemCache))
	}
	if m.MemLimit != 0 {
		n += 1 + sovPrimitives(uint64(m.MemLimit))
	}
	if m.Rbps != 0 {
		n += 5
	}
	if m.Wbps != 0 {
		n += 5
	}
	if m.NetRcvdPs != 0 {
		n += 5
	}
	if m.NetSentPs != 0 {
		n += 5
	}
	if m.NetRcvdBps != 0 {
		n += 5
	}
	if m.NetSentBps != 0 {
		n += 5
	}
	if m.State != 0 {
		n += 1 + sovPrimitives(uint64(m.State))
	}
	if m.Health != 0 {
		n += 2 + sovPrimitives(uint64(m.Health))
	}
	if m.Key != 0 {
		n += 2 + sovPrimitives(uint64(m.Key))
	}
	if m.Started != 0 {
		n += 2 + sovPrimitives(uint64(m.Started))
	}
	l = len(m.ByteKey)
	if l > 0 {
		n += 2 + l + sovPrimitives(uint64(l))
	}
	return n
}

func (m *SystemInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.Os != nil {
		l = m.Os.Size()
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if len(m.Cpus) > 0 {
		for _, e := range m.Cpus {
			l = e.Size()
			n += 1 + l + sovPrimitives(uint64(l))
		}
	}
	if m.TotalMemory != 0 {
		n += 1 + sovPrimitives(uint64(m.TotalMemory))
	}
	return n
}

func (m *OSInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	l = len(m.Family)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	l = len(m.KernelVersion)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	return n
}

func (m *IOStat) Size() (n int) {
	var l int
	_ = l
	if m.ReadRate != 0 {
		n += 5
	}
	if m.WriteRate != 0 {
		n += 5
	}
	if m.ReadBytesRate != 0 {
		n += 5
	}
	if m.WriteBytesRate != 0 {
		n += 5
	}
	return n
}

func (m *Connection) Size() (n int) {
	var l int
	_ = l
	if m.Pid != 0 {
		n += 1 + sovPrimitives(uint64(m.Pid))
	}
	if m.Laddr != nil {
		l = m.Laddr.Size()
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.Raddr != nil {
		l = m.Raddr.Size()
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.BytesSent != 0 {
		n += 5
	}
	if m.BytesRecieved != 0 {
		n += 5
	}
	if m.Family != 0 {
		n += 1 + sovPrimitives(uint64(m.Family))
	}
	if m.Type != 0 {
		n += 1 + sovPrimitives(uint64(m.Type))
	}
	if m.PidCreateTime != 0 {
		n += 1 + sovPrimitives(uint64(m.PidCreateTime))
	}
	return n
}

func (m *Addr) Size() (n int) {
	var l int
	_ = l
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovPrimitives(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovPrimitives(uint64(m.Port))
	}
	return n
}

func (m *MemoryStat) Size() (n int) {
	var l int
	_ = l
	if m.Rss != 0 {
		n += 1 + sovPrimitives(uint64(m.Rss))
	}
	if m.Vms != 0 {
		n += 1 + sovPrimitives(uint64(m.Vms))
	}
	if m.Swap != 0 {
		n += 1 + sovPrimitives(uint64(m.Swap))
	}
	if m.Shared != 0 {
		n += 1 + sovPrimitives(uint64(m.Shared))
	}
	if m.Text != 0 {
		n += 1 + sovPrimitives(uint64(m.Text))
	}
	if m.Lib != 0 {
		n += 1 + sovPrimitives(uint64(m.Lib))
	}
	if m.Data != 0 {
		n += 1 + sovPrimitives(uint64(m.Data))
	}
	if m.Dirty != 0 {
		n += 1 + sovPrimitives(uint64(m.Dirty))
	}
	return n
}

func (m *CPUStat) Size() (n int) {
	var l int
	_ = l
	l = len(m.LastCpu)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.TotalPct != 0 {
		n += 5
	}
	if m.UserPct != 0 {
		n += 5
	}
	if m.SystemPct != 0 {
		n += 5
	}
	if m.NumThreads != 0 {
		n += 1 + sovPrimitives(uint64(m.NumThreads))
	}
	if len(m.Cpus) > 0 {
		for _, e := range m.Cpus {
			l = e.Size()
			n += 1 + l + sovPrimitives(uint64(l))
		}
	}
	if m.Nice != 0 {
		n += 1 + sovPrimitives(uint64(m.Nice))
	}
	if m.UserTime != 0 {
		n += 1 + sovPrimitives(uint64(m.UserTime))
	}
	if m.SystemTime != 0 {
		n += 1 + sovPrimitives(uint64(m.SystemTime))
	}
	return n
}

func (m *SingleCPUStat) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.TotalPct != 0 {
		n += 5
	}
	return n
}

func (m *CPUInfo) Size() (n int) {
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovPrimitives(uint64(m.Number))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	l = len(m.Family)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	l = len(m.PhysicalId)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	l = len(m.CoreId)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if m.Cores != 0 {
		n += 1 + sovPrimitives(uint64(m.Cores))
	}
	if m.Mhz != 0 {
		n += 1 + sovPrimitives(uint64(m.Mhz))
	}
	if m.CacheSize != 0 {
		n += 1 + sovPrimitives(uint64(m.CacheSize))
	}
	return n
}

func (m *Host) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPrimitives(uint64(m.Id))
	}
	if m.OrgId != 0 {
		n += 1 + sovPrimitives(uint64(m.OrgId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPrimitives(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovPrimitives(uint64(l))
		}
	}
	if len(m.AllTags) > 0 {
		for _, s := range m.AllTags {
			l = len(s)
			n += 1 + l + sovPrimitives(uint64(l))
		}
	}
	if m.NumCpus != 0 {
		n += 1 + sovPrimitives(uint64(m.NumCpus))
	}
	if m.TotalMemory != 0 {
		n += 1 + sovPrimitives(uint64(m.TotalMemory))
	}
	return n
}

func (m *HostTags) Size() (n int) {
	var l int
	_ = l
	if m.SourceType != 0 {
		n += 1 + sovPrimitives(uint64(m.SourceType))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovPrimitives(uint64(l))
		}
	}
	return n
}

func sovPrimitives(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPrimitives(x uint64) (n int) {
	return sovPrimitives(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CollectorStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveClients", wireType)
			}
			m.ActiveClients = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ActiveClients |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Interval |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Process) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Process: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Process: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Key |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Pid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &Command{}
			}
			if err := m.Command.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &ProcessUser{}
			}
			if err := m.User.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &MemoryStat{}
			}
			if err := m.Memory.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CPUStat{}
			}
			if err := m.Cpu.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &Container{}
			}
			if err := m.Container.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenFdCount", wireType)
			}
			m.OpenFdCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OpenFdCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (ProcessState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IoStat == nil {
				m.IoStat = &IOStat{}
			}
			if err := m.IoStat.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerKey", wireType)
			}
			m.ContainerKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ContainerKey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoluntaryCtxSwitches", wireType)
			}
			m.VoluntaryCtxSwitches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.VoluntaryCtxSwitches |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoluntaryCtxSwitches", wireType)
			}
			m.InvoluntaryCtxSwitches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.InvoluntaryCtxSwitches |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByteKey = append(m.ByteKey[:0], data[iNdEx:postIndex]...)
			if m.ByteKey == nil {
				m.ByteKey = []byte{}
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerByteKey = append(m.ContainerByteKey[:0], data[iNdEx:postIndex]...)
			if m.ContainerByteKey == nil {
				m.ContainerByteKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Command) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cwd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cwd = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDisk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnDisk = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ppid", wireType)
			}
			m.Ppid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ppid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pgroup", wireType)
			}
			m.Pgroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Pgroup |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exe", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exe = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessUser) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Gid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Euid", wireType)
			}
			m.Euid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Euid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egid", wireType)
			}
			m.Egid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Egid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suid", wireType)
			}
			m.Suid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Suid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sgid", wireType)
			}
			m.Sgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Sgid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Container) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Container: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Container: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuLimit", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.CpuLimit = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryLimit", wireType)
			}
			m.MemoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemoryLimit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (ContainerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			m.Health = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Health |= (ContainerHealth(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Created |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Rbps = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Wbps = float32(math.Float32frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Key |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRcvdPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.NetRcvdPs = float32(math.Float32frombits(v))
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetSentPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.NetSentPs = float32(math.Float32frombits(v))
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRcvdBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.NetRcvdBps = float32(math.Float32frombits(v))
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetSentBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.NetSentBps = float32(math.Float32frombits(v))
		case 18:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.UserPct = float32(math.Float32frombits(v))
		case 19:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.SystemPct = float32(math.Float32frombits(v))
		case 20:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.TotalPct = float32(math.Float32frombits(v))
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemRss", wireType)
			}
			m.MemRss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemRss |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemCache", wireType)
			}
			m.MemCache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemCache |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			m.Started = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Started |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByteKey = append(m.ByteKey[:0], data[iNdEx:postIndex]...)
			if m.ByteKey == nil {
				m.ByteKey = []byte{}
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Pid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &MemoryStat{}
			}
			if err := m.Memory.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CPUStat{}
			}
			if err := m.Cpu.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nice", wireType)
			}
			m.Nice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Nice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threads", wireType)
			}
			m.Threads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Threads |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenFdCount", wireType)
			}
			m.OpenFdCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OpenFdCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Key |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerState", wireType)
			}
			m.ContainerState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ContainerState |= (ContainerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessState", wireType)
			}
			m.ProcessState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ProcessState |= (ProcessState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHealth", wireType)
			}
			m.ContainerHealth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ContainerHealth |= (ContainerHealth(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerRbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ContainerRbps = float32(math.Float32frombits(v))
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerWbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ContainerWbps = float32(math.Float32frombits(v))
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerKey", wireType)
			}
			m.ContainerKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ContainerKey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IoStat == nil {
				m.IoStat = &IOStat{}
			}
			if err := m.IoStat.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerNetRcvdPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ContainerNetRcvdPs = float32(math.Float32frombits(v))
		case 21:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerNetSentPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ContainerNetSentPs = float32(math.Float32frombits(v))
		case 22:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerNetRcvdBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ContainerNetRcvdBps = float32(math.Float32frombits(v))
		case 23:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerNetSentBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ContainerNetSentBps = float32(math.Float32frombits(v))
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoluntaryCtxSwitches", wireType)
			}
			m.VoluntaryCtxSwitches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.VoluntaryCtxSwitches |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoluntaryCtxSwitches", wireType)
			}
			m.InvoluntaryCtxSwitches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.InvoluntaryCtxSwitches |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByteKey = append(m.ByteKey[:0], data[iNdEx:postIndex]...)
			if m.ByteKey == nil {
				m.ByteKey = []byte{}
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerByteKey = append(m.ContainerByteKey[:0], data[iNdEx:postIndex]...)
			if m.ContainerByteKey == nil {
				m.ContainerByteKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.UserPct = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.SystemPct = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.TotalPct = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuLimit", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.CpuLimit = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemRss", wireType)
			}
			m.MemRss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemRss |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemCache", wireType)
			}
			m.MemCache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemCache |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemLimit", wireType)
			}
			m.MemLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemLimit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Rbps = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Wbps = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRcvdPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.NetRcvdPs = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetSentPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.NetSentPs = float32(math.Float32frombits(v))
		case 13:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRcvdBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.NetRcvdBps = float32(math.Float32frombits(v))
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetSentBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.NetSentBps = float32(math.Float32frombits(v))
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (ContainerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			m.Health = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Health |= (ContainerHealth(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Key |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			m.Started = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Started |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByteKey = append(m.ByteKey[:0], data[iNdEx:postIndex]...)
			if m.ByteKey == nil {
				m.ByteKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Os == nil {
				m.Os = &OSInfo{}
			}
			if err := m.Os.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpus = append(m.Cpus, &CPUInfo{})
			if err := m.Cpus[len(m.Cpus)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemory", wireType)
			}
			m.TotalMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalMemory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Family = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IOStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IOStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IOStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ReadRate = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.WriteRate = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBytesRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ReadBytesRate = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteBytesRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.WriteBytesRate = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connection) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Connection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Connection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Pid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Laddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Laddr == nil {
				m.Laddr = &Addr{}
			}
			if err := m.Laddr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Raddr == nil {
				m.Raddr = &Addr{}
			}
			if err := m.Raddr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesSent", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.BytesSent = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRecieved", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.BytesRecieved = float32(math.Float32frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Family |= (ConnectionFamily(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (ConnectionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PidCreateTime", wireType)
			}
			m.PidCreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PidCreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Addr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Addr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Addr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Port |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rss", wireType)
			}
			m.Rss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rss |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vms", wireType)
			}
			m.Vms = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Vms |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			m.Swap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Swap |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shared", wireType)
			}
			m.Shared = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Shared |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			m.Text = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Text |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lib", wireType)
			}
			m.Lib = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Lib |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			m.Data = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Data |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dirty", wireType)
			}
			m.Dirty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Dirty |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCpu", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastCpu = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.TotalPct = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.UserPct = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.SystemPct = float32(math.Float32frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumThreads", wireType)
			}
			m.NumThreads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NumThreads |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpus = append(m.Cpus, &SingleCPUStat{})
			if err := m.Cpus[len(m.Cpus)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nice", wireType)
			}
			m.Nice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Nice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserTime", wireType)
			}
			m.UserTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UserTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemTime", wireType)
			}
			m.SystemTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SystemTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleCPUStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleCPUStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleCPUStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.TotalPct = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Number |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Family = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoreId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cores", wireType)
			}
			m.Cores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Cores |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mhz", wireType)
			}
			m.Mhz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Mhz |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheSize", wireType)
			}
			m.CacheSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CacheSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Host) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Host: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Host: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			m.OrgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OrgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &HostTags{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllTags = append(m.AllTags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCpus", wireType)
			}
			m.NumCpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NumCpus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemory", wireType)
			}
			m.TotalMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalMemory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostTags) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostTags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostTags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			m.SourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SourceType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrimitives
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrimitives(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrimitives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPrimitives(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPrimitives
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPrimitives
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPrimitives
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPrimitives
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPrimitives(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPrimitives = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPrimitives   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("primitives/primitives.proto", fileDescriptorPrimitives) }

var fileDescriptorPrimitives = []byte{
	// 2095 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x59, 0x4b, 0x6f, 0xe4, 0xc6,
	0x11, 0x16, 0x39, 0x9c, 0x57, 0x49, 0x23, 0x71, 0x5b, 0xb2, 0x4c, 0xcb, 0x81, 0x30, 0x18, 0x18,
	0x86, 0xa2, 0x64, 0xb5, 0x8e, 0x1c, 0x18, 0x41, 0x1e, 0x4e, 0xbc, 0xa3, 0x2c, 0x56, 0x79, 0xd8,
	0x42, 0x4b, 0x1b, 0x1b, 0xce, 0x21, 0xa0, 0xc8, 0xde, 0x19, 0x62, 0x87, 0x0f, 0x90, 0x4d, 0x69,
	0xc7, 0xb7, 0x5c, 0x72, 0xf6, 0x25, 0x01, 0xf2, 0x1f, 0xfc, 0x0f, 0xf2, 0x07, 0x72, 0xcc, 0x29,
	0xa7, 0x1c, 0x82, 0x0d, 0xf2, 0x23, 0x72, 0x0b, 0xaa, 0xba, 0xf9, 0x9a, 0xd1, 0x6b, 0xb5, 0x3e,
	0xb1, 0xaa, 0xba, 0xab, 0xba, 0xa7, 0x59, 0xf5, 0x7d, 0xd5, 0x1c, 0x78, 0x37, 0x49, 0x83, 0x30,
	0x90, 0xc1, 0x85, 0xc8, 0x1e, 0x55, 0xe2, 0x41, 0x92, 0xc6, 0x32, 0x66, 0x43, 0xdf, 0x95, 0xae,
	0x1f, 0x4f, 0x50, 0xf5, 0x44, 0x96, 0xfd, 0xc1, 0x9d, 0x88, 0x48, 0x1e, 0x54, 0xf3, 0x46, 0xa7,
	0xb0, 0x31, 0x8e, 0x67, 0x33, 0xe1, 0xc9, 0x38, 0x3d, 0x95, 0xae, 0xcc, 0x33, 0xf6, 0x1e, 0x0c,
	0x5c, 0x0f, 0x47, 0xc7, 0xb3, 0x40, 0x44, 0x32, 0x73, 0x8c, 0xa1, 0xb1, 0xd7, 0xe6, 0x4d, 0x23,
	0xdb, 0x81, 0x5e, 0x10, 0x49, 0x91, 0x5e, 0xb8, 0x33, 0xc7, 0xa4, 0x09, 0xa5, 0x3e, 0xfa, 0x63,
	0x17, 0xba, 0x27, 0x6a, 0x45, 0x66, 0x43, 0xeb, 0x85, 0x98, 0x53, 0x8c, 0x01, 0x47, 0x11, 0x2d,
	0x49, 0xe0, 0x6b, 0x27, 0x14, 0xd9, 0x8f, 0xc1, 0x9a, 0xc6, 0x99, 0x74, 0x5a, 0x43, 0x63, 0x6f,
	0xf5, 0xf0, 0xfd, 0x83, 0xdb, 0x76, 0x7d, 0xf0, 0x34, 0xce, 0x24, 0x27, 0x1f, 0x36, 0x86, 0xae,
	0x17, 0x87, 0xa1, 0x1b, 0xf9, 0x8e, 0x45, 0xee, 0xdf, 0xbd, 0xdd, 0x7d, 0xac, 0x1c, 0x78, 0xe1,
	0xc9, 0x3e, 0x01, 0x2b, 0xcf, 0x44, 0xea, 0xb4, 0x29, 0xc2, 0xc3, 0xdb, 0x23, 0xe8, 0x5f, 0xf7,
	0x2c, 0x13, 0x29, 0x27, 0x57, 0x76, 0x04, 0x9d, 0x50, 0x84, 0x71, 0x3a, 0x77, 0xba, 0x14, 0xe4,
	0xfb, 0xb7, 0x07, 0xf9, 0x2d, 0xcd, 0xc7, 0x53, 0xe7, 0xda, 0x97, 0xfd, 0x04, 0x5a, 0x5e, 0x92,
	0x3b, 0xbd, 0x3b, 0xff, 0x92, 0x93, 0x67, 0xe4, 0x8f, 0x5e, 0x6c, 0x17, 0xc0, 0x4b, 0x85, 0x2b,
	0xc5, 0x59, 0x10, 0x0a, 0xa7, 0x3f, 0x34, 0xf6, 0x5a, 0xbc, 0x66, 0x61, 0xc7, 0xd0, 0xf7, 0xe2,
	0x48, 0xba, 0x41, 0x24, 0x52, 0x07, 0x68, 0x89, 0xef, 0xdd, 0xe5, 0xb0, 0xb4, 0x0b, 0xaf, 0xbc,
	0xd9, 0x10, 0x56, 0xe3, 0x44, 0x44, 0x4f, 0xfc, 0x71, 0x9c, 0x47, 0xd2, 0x59, 0xa5, 0x77, 0x59,
	0x37, 0xb1, 0x23, 0x68, 0x67, 0xd2, 0x95, 0xc2, 0x59, 0x1b, 0x1a, 0x7b, 0xeb, 0x87, 0x07, 0x77,
	0x3e, 0x53, 0xfc, 0x3d, 0x82, 0x2b, 0x67, 0xf6, 0x0b, 0xe8, 0x04, 0x31, 0x5a, 0x9c, 0x01, 0xed,
	0x77, 0xef, 0xf6, 0x30, 0xc7, 0x9f, 0xa9, 0x13, 0x55, 0x7e, 0xb8, 0xd3, 0x72, 0xdb, 0xc7, 0xbe,
	0xb3, 0x3e, 0x34, 0xf6, 0xfa, 0xbc, 0x6e, 0x62, 0x23, 0x58, 0x2b, 0xd5, 0x5f, 0x8b, 0xb9, 0xb3,
	0x41, 0xa9, 0xda, 0xb0, 0xb1, 0x43, 0xd8, 0xba, 0x88, 0x67, 0x79, 0x24, 0xdd, 0x74, 0x3e, 0x96,
	0x2f, 0x4f, 0x2f, 0x03, 0xe9, 0x4d, 0x45, 0xe6, 0xd8, 0x43, 0x63, 0xcf, 0xe2, 0x57, 0x8e, 0xb1,
	0x8f, 0x60, 0x3b, 0x88, 0xae, 0xf4, 0x7a, 0x40, 0x5e, 0xd7, 0x8c, 0x32, 0x07, 0xba, 0xe7, 0x73,
	0x29, 0x70, 0x2b, 0x6c, 0x68, 0xec, 0xad, 0xf1, 0x42, 0x65, 0xfb, 0x60, 0x97, 0xbb, 0x7a, 0xac,
	0xa7, 0x6c, 0xd2, 0x94, 0x25, 0xfb, 0xe8, 0xaf, 0x06, 0x74, 0x75, 0x9e, 0x33, 0x06, 0x96, 0x9b,
	0x4e, 0xb0, 0x90, 0x5b, 0x7b, 0x7d, 0x4e, 0x32, 0x56, 0xa1, 0x77, 0xe9, 0x53, 0xc9, 0xf5, 0x39,
	0x8a, 0x38, 0x2b, 0x8d, 0x63, 0x49, 0x65, 0xd4, 0xe7, 0x24, 0xb3, 0x6d, 0xe8, 0xc4, 0xd1, 0x51,
	0x90, 0xbd, 0xa0, 0xd2, 0xe8, 0x71, 0xad, 0xe1, 0xdc, 0x04, 0x8b, 0xb8, 0x43, 0x2f, 0x9e, 0x64,
	0x9c, 0x9b, 0x4c, 0xd2, 0x38, 0x4f, 0xa8, 0x02, 0xda, 0x5c, 0x6b, 0xb8, 0x92, 0x78, 0x29, 0x28,
	0xa7, 0xfb, 0x1c, 0xc5, 0xd1, 0x9f, 0x0d, 0x58, 0xad, 0x55, 0x10, 0x46, 0x8b, 0xdc, 0x50, 0x10,
	0x48, 0xf4, 0x39, 0xc9, 0xe8, 0x95, 0x57, 0x28, 0x91, 0x07, 0x3e, 0x5a, 0x26, 0x81, 0xda, 0x71,
	0x9b, 0xa3, 0x88, 0x7e, 0x02, 0x27, 0x59, 0x6a, 0x17, 0x28, 0x93, 0x0d, 0xa7, 0xb5, 0xb5, 0x4d,
	0xcf, 0xcb, 0xf2, 0x6a, 0xb7, 0x99, 0x9e, 0x97, 0xe1, 0xbc, 0xae, 0xb6, 0x4d, 0x02, 0x7f, 0xf4,
	0xa7, 0x0e, 0xf4, 0xcb, 0x74, 0xc7, 0x19, 0x72, 0x9e, 0x94, 0xbb, 0x42, 0x99, 0xad, 0x83, 0xa9,
	0x37, 0xd5, 0xe7, 0xa6, 0x8a, 0x42, 0x3b, 0x6f, 0xd5, 0x76, 0xbe, 0x05, 0xed, 0x20, 0x74, 0x27,
	0x42, 0x1f, 0xa4, 0x52, 0x10, 0x2f, 0xbd, 0x24, 0xff, 0x0d, 0xa6, 0x29, 0xed, 0xcd, 0xe4, 0xa5,
	0x8e, 0x39, 0xaa, 0xea, 0x5f, 0x0d, 0x77, 0x28, 0x3d, 0xea, 0x26, 0xf6, 0xa4, 0xa8, 0xa6, 0x1e,
	0x55, 0xd3, 0x07, 0xaf, 0x51, 0xb6, 0x8d, 0x7a, 0x3a, 0x86, 0xce, 0x54, 0xb8, 0x33, 0x39, 0x25,
	0x78, 0x58, 0x3f, 0xfc, 0xc1, 0x6b, 0x04, 0x7a, 0x4a, 0x8e, 0x5c, 0x07, 0xc0, 0x34, 0x55, 0xd8,
	0xe2, 0x13, 0x96, 0xb4, 0x78, 0xa1, 0x52, 0x22, 0x9d, 0x27, 0x19, 0xa1, 0x82, 0xc9, 0x49, 0x46,
	0xdb, 0x25, 0xda, 0xd6, 0x94, 0x0d, 0xe5, 0x82, 0x1a, 0x06, 0x15, 0x35, 0x7c, 0x07, 0xfa, 0x91,
	0x90, 0xdc, 0xbb, 0xf0, 0x4f, 0x32, 0x2a, 0x55, 0x93, 0x57, 0x06, 0x3d, 0x7a, 0x2a, 0x22, 0x79,
	0x92, 0x51, 0x95, 0xaa, 0x51, 0x65, 0x40, 0xf4, 0xd3, 0x53, 0x1f, 0x27, 0xaa, 0x30, 0x4d, 0x5e,
	0xb3, 0xe8, 0x71, 0x9c, 0x8c, 0xe3, 0x0f, 0xca, 0x71, 0x6d, 0xc1, 0xdf, 0x83, 0x40, 0x7e, 0xe2,
	0x49, 0x2a, 0x3b, 0x93, 0x17, 0x2a, 0xae, 0x9b, 0xcd, 0x33, 0x29, 0x42, 0x1c, 0xdb, 0x54, 0xeb,
	0x96, 0x06, 0x7c, 0xb1, 0x32, 0x96, 0xee, 0x0c, 0x07, 0xb7, 0xd4, 0x8b, 0x2d, 0x74, 0x2c, 0x89,
	0x50, 0x84, 0x3c, 0xcb, 0x9c, 0xb7, 0xe8, 0x9d, 0x6a, 0x0d, 0x7d, 0x42, 0x11, 0x8e, 0x5d, 0x6f,
	0x2a, 0x9c, 0x6d, 0x1a, 0x29, 0xf5, 0x92, 0x0c, 0xdf, 0xbe, 0x07, 0x19, 0x3a, 0xd0, 0xcd, 0xa4,
	0x9b, 0xe2, 0x3b, 0x71, 0xd4, 0x3b, 0xd1, 0x6a, 0x1d, 0x54, 0xde, 0x69, 0x82, 0x0a, 0xa6, 0xb9,
	0x3b, 0xc9, 0x9c, 0x1d, 0x05, 0x0e, 0x28, 0x8f, 0xfe, 0xd7, 0x2b, 0x0b, 0x94, 0x40, 0x54, 0x53,
	0xb6, 0x51, 0x51, 0x76, 0x93, 0x6b, 0xcc, 0x25, 0xae, 0xa9, 0xe8, 0xb0, 0xf5, 0xe6, 0x74, 0x68,
	0xdd, 0x8b, 0x0e, 0xb1, 0x36, 0x03, 0x4f, 0x14, 0x48, 0x80, 0x32, 0x1e, 0x83, 0x9c, 0xa6, 0xc2,
	0xf5, 0x33, 0x5d, 0xf8, 0x85, 0xba, 0xc8, 0x68, 0xbd, 0x65, 0x46, 0xd3, 0xe9, 0xda, 0xaf, 0xd2,
	0x75, 0x81, 0x5b, 0x60, 0x99, 0x5b, 0xbe, 0x80, 0x75, 0xaf, 0x51, 0x88, 0x54, 0x14, 0xf7, 0x29,
	0xe0, 0x85, 0x38, 0x8c, 0xc3, 0x5a, 0x52, 0x23, 0xcc, 0x7b, 0xd2, 0x6c, 0x23, 0x06, 0xfb, 0x3d,
	0x6c, 0x78, 0xcd, 0x6a, 0xa7, 0x32, 0xbb, 0x17, 0x4c, 0x2c, 0x46, 0xc2, 0xb6, 0xb2, 0x34, 0xf1,
	0xf3, 0xb2, 0x44, 0x9b, 0xc6, 0xc6, 0xac, 0xcf, 0xcf, 0xcb, 0x42, 0x6d, 0x1a, 0x97, 0x28, 0x9b,
	0x5d, 0x41, 0xd9, 0x55, 0xeb, 0xb0, 0x79, 0xcf, 0xd6, 0xe1, 0x00, 0x58, 0x19, 0xf1, 0xd3, 0x12,
	0x96, 0x54, 0x8d, 0x5f, 0x31, 0xb2, 0x38, 0x5f, 0x03, 0xd5, 0x5b, 0xcb, 0xf3, 0x35, 0x62, 0x7d,
	0x00, 0x9b, 0x8b, 0x51, 0x10, 0x9a, 0xb6, 0xc9, 0xe1, 0xaa, 0xa1, 0x45, 0x8f, 0x02, 0xcc, 0xde,
	0x5e, 0xf6, 0x28, 0x50, 0xed, 0xba, 0xc6, 0xc5, 0xb9, 0x57, 0xe3, 0xf2, 0xce, 0x5d, 0x1b, 0x97,
	0x9d, 0xdb, 0x1b, 0x97, 0x77, 0xaf, 0x69, 0x5c, 0xfe, 0x65, 0xc1, 0xa0, 0x91, 0xfb, 0x9a, 0x74,
	0x8d, 0x92, 0x74, 0x6b, 0x48, 0x6d, 0xde, 0x80, 0xd4, 0xad, 0x9b, 0x90, 0xda, 0x5a, 0x40, 0xea,
	0x9b, 0xe8, 0xb9, 0x42, 0xf1, 0xce, 0xb5, 0x28, 0xde, 0x5d, 0x40, 0x71, 0x35, 0xa6, 0xe2, 0xf5,
	0xca, 0x31, 0x15, 0xaf, 0xe0, 0xc7, 0xfe, 0x15, 0xfc, 0x08, 0x35, 0x7e, 0x6c, 0xb0, 0xe1, 0xea,
	0x8d, 0x6c, 0xb8, 0x76, 0x33, 0x1b, 0x0e, 0x6e, 0x61, 0xc3, 0xf5, 0x25, 0x36, 0x2c, 0x1b, 0x8e,
	0x8d, 0x6f, 0xab, 0xe1, 0xb0, 0xdf, 0xb4, 0xe1, 0xd0, 0xf8, 0xfb, 0xa0, 0xc2, 0xdf, 0x1a, 0xdd,
	0xb1, 0x6b, 0xe9, 0x6e, 0xb3, 0x91, 0x8a, 0xa3, 0xbf, 0x19, 0x00, 0xa7, 0x94, 0x12, 0xc7, 0xd1,
	0xf3, 0x18, 0xcf, 0x3d, 0xcf, 0xcb, 0xec, 0x22, 0x99, 0xfd, 0x08, 0xcc, 0x38, 0xa3, 0xd4, 0xba,
	0x13, 0x6a, 0x7c, 0x76, 0x8a, 0x91, 0xb8, 0x19, 0x67, 0xec, 0x67, 0x60, 0x79, 0x49, 0x9e, 0x39,
	0xad, 0x61, 0xeb, 0xce, 0x84, 0x45, 0xce, 0xe4, 0x86, 0x7c, 0x42, 0x09, 0xa9, 0x98, 0x90, 0xf2,
	0xb0, 0xc5, 0xeb, 0xa6, 0xd1, 0xd7, 0x06, 0x74, 0xd4, 0x7a, 0x57, 0x36, 0xcd, 0x3b, 0xd0, 0x4b,
	0x66, 0xae, 0x7c, 0x1e, 0xa7, 0xa1, 0x6e, 0x52, 0x4b, 0x1d, 0xb3, 0xf8, 0xb9, 0x1b, 0x06, 0xb3,
	0xb9, 0x6e, 0x56, 0xb5, 0x86, 0x47, 0x75, 0x21, 0xd2, 0x2c, 0x88, 0x23, 0xdd, 0xb0, 0x16, 0x2a,
	0x62, 0xf1, 0x0b, 0x91, 0x46, 0x62, 0xf6, 0x3b, 0x3d, 0xde, 0xa6, 0xf1, 0xa6, 0x91, 0xb6, 0xa4,
	0x80, 0x13, 0x97, 0x47, 0x32, 0xe5, 0x98, 0x37, 0x86, 0x2a, 0xa2, 0x42, 0xc7, 0x74, 0xbd, 0x4c,
	0x03, 0x29, 0x68, 0x50, 0x95, 0x6d, 0x65, 0xc0, 0xa5, 0x70, 0x26, 0x62, 0x40, 0x46, 0x33, 0x54,
	0xf1, 0x36, 0x8d, 0xec, 0x7d, 0x58, 0x27, 0x97, 0x6a, 0x9a, 0x2a, 0xe3, 0x05, 0xeb, 0xe8, 0x2f,
	0x2d, 0x80, 0x71, 0x1c, 0x45, 0xc2, 0x93, 0xf8, 0x3b, 0x96, 0xbb, 0x97, 0x9f, 0x42, 0x7b, 0xe6,
	0xfa, 0x7e, 0x71, 0xe1, 0xbf, 0x43, 0x93, 0xf5, 0x89, 0xef, 0xa7, 0x5c, 0x39, 0xa1, 0x77, 0x4a,
	0xde, 0x9d, 0xd7, 0xf3, 0x26, 0x27, 0x3c, 0x08, 0xcc, 0xc5, 0x0c, 0x2b, 0x8d, 0xa0, 0xc1, 0xe4,
	0x95, 0x01, 0x0f, 0x82, 0x14, 0x2e, 0xbc, 0x40, 0x5c, 0x08, 0x5f, 0x83, 0x44, 0xd3, 0xc8, 0x7e,
	0x55, 0xbe, 0x4b, 0xa0, 0xaa, 0x3a, 0xbc, 0x53, 0x55, 0xe9, 0xf3, 0x78, 0x42, 0x9e, 0xe5, 0xfb,
	0x3f, 0xd2, 0xd7, 0x9c, 0xd7, 0x69, 0x4c, 0x74, 0xa4, 0xb3, 0x79, 0x22, 0xf4, 0xc5, 0xe8, 0x3d,
	0x18, 0x24, 0x81, 0x3f, 0xae, 0x5a, 0xc2, 0x35, 0x4a, 0xde, 0xa6, 0x71, 0xf4, 0x1c, 0x2c, 0x3c,
	0x8a, 0xb2, 0xc7, 0x35, 0xee, 0xd1, 0xe3, 0x22, 0x1b, 0x24, 0xe5, 0x15, 0x2c, 0xa1, 0xab, 0x68,
	0x9c, 0x4a, 0x7d, 0x2f, 0x24, 0x79, 0xf4, 0x8d, 0x01, 0x50, 0xb5, 0x93, 0x98, 0x00, 0x69, 0xa6,
	0xbe, 0x63, 0x59, 0x1c, 0x45, 0xb4, 0x5c, 0x84, 0xaa, 0xc6, 0x2d, 0x8e, 0x22, 0xdd, 0x07, 0x2f,
	0xdd, 0x84, 0xc2, 0x58, 0x9c, 0x64, 0x2c, 0x99, 0x6c, 0xea, 0xa6, 0x42, 0xdd, 0x30, 0x2d, 0xae,
	0x35, 0x6a, 0x99, 0xc5, 0x4b, 0x45, 0x14, 0x16, 0x27, 0x19, 0x23, 0xce, 0x82, 0x73, 0xcd, 0x10,
	0x28, 0xe2, 0x2c, 0xfc, 0x5d, 0x9a, 0x1a, 0x48, 0xc6, 0xbb, 0xa1, 0x1f, 0xa4, 0x72, 0xae, 0x39,
	0x41, 0x29, 0xa3, 0x6f, 0x4c, 0xe8, 0xea, 0xd6, 0x15, 0xcb, 0x71, 0xe6, 0x66, 0x72, 0x9c, 0xe4,
	0xba, 0xb2, 0x0b, 0xb5, 0x41, 0x5f, 0xe6, 0x02, 0x7d, 0xd5, 0x28, 0xb1, 0x75, 0x03, 0x25, 0x5a,
	0x8b, 0x94, 0x88, 0x34, 0x90, 0x87, 0x67, 0xba, 0x25, 0x56, 0x9d, 0x72, 0xcd, 0xc2, 0xc6, 0x1a,
	0xd0, 0x3a, 0x04, 0x68, 0x8f, 0x6e, 0x7f, 0x51, 0xa7, 0x41, 0x34, 0x99, 0x89, 0xa2, 0x0f, 0x57,
	0xb0, 0x56, 0x34, 0xe2, 0xdd, 0x5a, 0x23, 0xbe, 0x03, 0x3d, 0xdc, 0x21, 0xa5, 0x4a, 0x8f, 0x52,
	0xa5, 0xd4, 0x71, 0x53, 0x6a, 0x87, 0xf5, 0xef, 0x58, 0x95, 0x65, 0xf4, 0x73, 0x18, 0x34, 0x96,
	0xb9, 0x0e, 0x0a, 0xaf, 0x3b, 0xad, 0xd1, 0x7f, 0x0d, 0x3a, 0x6f, 0x82, 0xd1, 0x6d, 0xe8, 0x44,
	0x79, 0x78, 0x2e, 0x52, 0x8d, 0x0f, 0x5a, 0x43, 0xfb, 0x85, 0x88, 0xfc, 0x38, 0xd5, 0xa9, 0xa6,
	0xb5, 0x6b, 0x61, 0x74, 0x0b, 0xda, 0x61, 0xec, 0x8b, 0x59, 0x71, 0xeb, 0x27, 0x05, 0x7f, 0x4a,
	0x32, 0x9d, 0x67, 0x81, 0xe7, 0xce, 0x8e, 0x7d, 0x8d, 0x9f, 0x35, 0x0b, 0x46, 0xf3, 0xe2, 0x54,
	0x1c, 0xab, 0x6f, 0x13, 0x7d, 0xae, 0x35, 0x8c, 0x86, 0x52, 0x71, 0x4b, 0x51, 0x0a, 0xe6, 0x58,
	0x38, 0xfd, 0x4a, 0x9f, 0x17, 0x8a, 0xf8, 0x76, 0x3d, 0xec, 0x37, 0x4e, 0x83, 0xaf, 0xd4, 0x49,
	0xb5, 0x79, 0x65, 0x18, 0xfd, 0xd3, 0x00, 0xeb, 0x69, 0x51, 0x33, 0x05, 0x00, 0x62, 0x07, 0xb5,
	0x05, 0xed, 0x38, 0x9d, 0x1c, 0x17, 0x9f, 0x57, 0x94, 0x72, 0xe5, 0xc7, 0x8c, 0x8f, 0xf5, 0xed,
	0xd0, 0xa2, 0x04, 0xd8, 0xbf, 0x5b, 0xa5, 0x9e, 0xb9, 0x93, 0x4c, 0xdd, 0x24, 0x31, 0x31, 0xdd,
	0xd9, 0x0c, 0x0d, 0x94, 0x43, 0x7d, 0x5e, 0xa8, 0x38, 0x12, 0xe5, 0xe1, 0x18, 0xb3, 0x4b, 0x5f,
	0xc5, 0xb4, 0xba, 0x48, 0x83, 0xbd, 0x65, 0x1a, 0xfc, 0x18, 0x7a, 0xc5, 0x3a, 0x94, 0x2d, 0x71,
	0x9e, 0x7a, 0xe2, 0xac, 0xf8, 0x58, 0x33, 0xe0, 0x35, 0x4b, 0x79, 0xbf, 0x35, 0xab, 0xfb, 0xed,
	0x7e, 0x00, 0xeb, 0xcd, 0x76, 0x85, 0xad, 0x42, 0x37, 0x8f, 0x5e, 0x44, 0xf1, 0x65, 0x64, 0xaf,
	0xa0, 0xa2, 0xbf, 0x65, 0xd8, 0x06, 0x5b, 0x07, 0x48, 0x05, 0xf5, 0x15, 0x41, 0x34, 0xb1, 0x4d,
	0x1c, 0x4c, 0xf3, 0x28, 0x42, 0xa5, 0xc5, 0x00, 0x3a, 0x89, 0x9b, 0x67, 0xc2, 0xb7, 0x2d, 0x94,
	0xc5, 0xcb, 0x00, 0x9d, 0xda, 0xac, 0x07, 0x96, 0x2f, 0x5c, 0xdf, 0xee, 0xec, 0x7f, 0x0a, 0x1b,
	0x0b, 0x0d, 0x0d, 0x7b, 0x00, 0x03, 0xbd, 0x96, 0x32, 0xd8, 0x2b, 0x6c, 0x0d, 0x7a, 0xe5, 0x12,
	0x06, 0x2e, 0xa1, 0x7a, 0x9e, 0xb9, 0x6d, 0xb2, 0x01, 0xf4, 0xf3, 0xa8, 0x50, 0x5b, 0xfb, 0x4f,
	0x60, 0xad, 0x7e, 0x83, 0x63, 0x6d, 0x30, 0x9e, 0xd9, 0x2b, 0xf8, 0x38, 0xb2, 0x0d, 0x7c, 0x70,
	0xdb, 0xc4, 0xc7, 0xa9, 0xdd, 0xc2, 0xc7, 0x99, 0x6d, 0xe1, 0xe3, 0x73, 0xbb, 0x8d, 0x8f, 0x2f,
	0xec, 0x0e, 0x3e, 0xbe, 0xb4, 0xbb, 0xfb, 0x23, 0x3a, 0x82, 0x1a, 0x90, 0xb3, 0x2e, 0xb4, 0xa4,
	0x97, 0xd8, 0x2b, 0x28, 0xe4, 0x7e, 0x62, 0x1b, 0xfb, 0x23, 0xb0, 0x17, 0x69, 0x83, 0x75, 0xc0,
	0xbc, 0xf8, 0xa1, 0xbd, 0x42, 0xcf, 0x8f, 0x6c, 0xe3, 0xf1, 0x2f, 0xff, 0xfe, 0x6a, 0xd7, 0xf8,
	0xc7, 0xab, 0x5d, 0xe3, 0xdf, 0xaf, 0x76, 0x8d, 0xaf, 0xff, 0xb3, 0xbb, 0xf2, 0xe5, 0x87, 0x93,
	0x40, 0x4e, 0xf3, 0xf3, 0x03, 0x2f, 0x0e, 0x1f, 0x1d, 0xb9, 0xd2, 0x3d, 0x8a, 0x27, 0x8f, 0x74,
	0xda, 0x3c, 0xd4, 0x69, 0xf3, 0x90, 0xd2, 0xa6, 0xf6, 0x7f, 0xc5, 0x79, 0x87, 0xfe, 0xb0, 0xf8,
	0xf0, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x32, 0xad, 0x6f, 0xf6, 0xcf, 0x18, 0x00, 0x00,
}
